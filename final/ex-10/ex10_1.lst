680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 24 Mar 2021      Time: 14:45:25          Source: C:\IDE68K\EM-LAB\EX10_1.SRC

                       1          section   code
                       2   ;********************************************************************************************************
                       3   ;                                               uC/OS-II
                       4   ;                                         The Real-Time Kernel
                       5   ;
                       6   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                       7   ;                                          All Rights Reserved
                       8   ;
                       9   ;
                      10   ;                                        IDE68K Specific boot code
                      11   ;
                      12   ;
                      13   ; File         : OS_BOOT.ASM
                      14   ; By           : Peter J. Fondse
                      15   ;********************************************************************************************************
                      16   
                      17   ;********************************************************************************************************
                      18   ;                                               NOTES
                      19   ;
                      20   ; This is the "Board Support Package" or BSP for the IDE68K simulator. It defines memory layout,
                      21   ; interrupt vectors and a few BIOS functions.
                      22   ;
                      23   ;********************************************************************************************************
                      24   
                      25   ;********************************************************************************************************
                      26   ;                                           REVISION HISTORY
                      27   ;
                      28   ; $Log$
                      29   ;
                      30   ;********************************************************************************************************
                      31   
          0000 0000   32   ROM        equ         $00000000       ; ROM starts at $00000000
          0080 0000   33   RAM        equ         $00800000       ; RAM starts at $00800000 (for example)
          0004 0000   34   RAMsize    equ         $00040000       ; Size of RAM (256 Kbyte for example)
                      35   
                      36   
00000000              37              org         ROM
          0000 0000   38   begin_ROM  equ         *
          0000 0000   39   code       equ         *
                      40   
00000000  0084 0000   41              dc.l        __stack         ; Vector #  0, 0x00000000: Initial SP
00000004  0000 0400   42              dc.l        startup         ; Vector #  1, 0x00000004: Initial PC
00000008  0000 0004   43              dc.l        $04             ; Vector #  2, 0x00000008: Bus Error
0000000C  0000 0008   44              dc.l        $08             ; Vector #  3, 0x0000000C: Address Error
00000010  0000 000C   45              dc.l        $0C             ; Vector #  4, 0x00000010: Illegal Instruction
00000014  0000 0010   46              dc.l        $10             ; Vector #  5, 0x00000014: Zero Division
00000018  0000 0014   47              dc.l        $14             ; Vector #  6, 0x00000018: CHK, CHK2 Instruction
0000001C  0000 0018   48              dc.l        $18             ; Vector #  7, 0x0000001C: TRAPxx, TRAPV Instructions
00000020  0000 001C   49              dc.l        $1C             ; Vector #  8, 0x00000020: Privilege Violation
00000024  0000 0020   50              dc.l        $20             ; Vector #  9, 0x00000024: Trace
00000028  0000 0024   51              dc.l        $24             ; Vector # 10, 0x00000028: Line 1010 Emulator
0000002C  0000 0028   52              dc.l        $28             ; Vector # 11, 0x0000002C: Line 1111 Emulator
00000030  0000 002C   53              dc.l        $2C             ; Vector # 12, 0x00000030: Hardware Breakpoint
00000034  0000 002C   54              dc.l        $2C             ; Vector # 13, 0x00000034: Coprocessor Protocol Violation
00000038  0000 002C   55              dc.l        $2C             ; Vector # 14, 0x00000038: Format error
0000003C  0000 002C   56              dc.l        $2C             ; Vector # 15, 0x0000003C: Format error
00000040  0000 0588   57              dc.l        _OSTickISR      ; Vector # 16, 0x00000040: Timer Tick ISR
00000044  0000 002C   58              dc.l        $2C             ; Vector # 17, 0x00000044: Reserved
00000048  0000 002C   59              dc.l        $2C             ; Vector # 18, 0x00000048: Reserved
0000004C  0000 002C   60              dc.l        $2C             ; Vector # 19, 0x0000004C: Reserved
00000050  0000 004C   61              dc.l        $4C             ; Vector # 20, 0x00000050: Reserved
00000054  0000 002C   62              dc.l        $2C             ; Vector # 21, 0x00000054: Reserved
00000058  0000 002C   63              dc.l        $2C             ; Vector # 22, 0x00000058: Reserved
0000005C  0000 002C   64              dc.l        $2C             ; Vector # 23, 0x0000005C: Reserved
00000060  0000 0030   65              dc.l        $30             ; Vector # 24, 0x00000060: Spurious interrupt
00000064  0000 0034   66              dc.l        $34             ; Vector # 25, 0x00000064: Level 1 Interrupt Autovector
00000068  0000 0038   67              dc.l        $38             ; Vector # 26, 0x00000068: Level 2 Interrupt Autovector
0000006C  0000 003C   68              dc.l        $3C             ; Vector # 27, 0x0000006C: Level 3 Interrupt Autovector
00000070  0000 0040   69              dc.l        $40             ; Vector # 28, 0x00000070: Level 4 Interrupt Autovector
00000074  0000 0044   70              dc.l        $44             ; Vector # 29, 0x00000074: Level 5 Interrupt Autovector
00000078  0000 0048   71              dc.l        $48             ; Vector # 30, 0x00000078: Level 6 Interrupt Autovector
0000007C  0000 004C   72              dc.l        $4C             ; Vector # 31, 0x0000007C: Level 7 Interrupt Autovector
00000080  0000 047C   73              dc.l        _OSCtxSw        ; Vector # 32, 0x00000080: Trap # 0 Context switch
00000084  0000 0054   74              dc.l        $54             ; Vector # 33, 0x00000084: Trap # 1
00000088  0000 0058   75              dc.l        $58             ; Vector # 34, 0x00000088: Trap # 2
0000008C  0000 005C   76              dc.l        $5C             ; Vector # 35, 0x0000008C: Trap # 3
00000090  0000 0060   77              dc.l        $60             ; Vector # 36, 0x00000090: Trap # 4
00000094  0000 0064   78              dc.l        $64             ; Vector # 37, 0x00000094: Trap # 5
00000098  0000 0068   79              dc.l        $68             ; Vector # 38, 0x00000098: Trap # 6
0000009C  0000 006C   80              dc.l        $6C             ; Vector # 39, 0x0000009C: Trap # 7
000000A0  0000 0070   81              dc.l        $70             ; Vector # 40, 0x000000A0: Trap # 8
000000A4  0000 0074   82              dc.l        $74             ; Vector # 41, 0x000000A4: Trap # 9
000000A8  0000 0078   83              dc.l        $78             ; Vector # 42, 0x000000A8: Trap #10
000000AC  0000 007C   84              dc.l        $7C             ; Vector # 43, 0x000000AC: Trap #11
000000B0  0000 0080   85              dc.l        $80             ; Vector # 44, 0x000000B0: Trap #12
000000B4  0000 0084   86              dc.l        $84             ; Vector # 45, 0x000000B4: Trap #13
000000B8  0000 0088   87              dc.l        $88             ; Vector # 46, 0x000000B8: Trap #14
000000BC  0000 008C   88              dc.l        $8C             ; Vector # 47, 0x000000BC: Trap #15 System call
000000C0  0000 0090   89              dc.l        $90             ; Vector # 48, 0x000000C0: Reserved
000000C4  0000 0094   90              dc.l        $94             ; Vector # 49, 0x000000C4: Reserved
000000C8  0000 0098   91              dc.l        $98             ; Vector # 50, 0x000000C8: Reserved
000000CC  0000 009C   92              dc.l        $9C             ; Vector # 51, 0x000000CC: Reserved
000000D0  0000 00A0   93              dc.l        $A0             ; Vector # 52, 0x000000D0: Reserved
000000D4  0000 00A4   94              dc.l        $A4             ; Vector # 53, 0x000000D4: Reserved
000000D8  0000 00A8   95              dc.l        $A8             ; Vector # 54, 0x000000D8: Reserved
000000DC  0000 00AC   96              dc.l        $AC             ; Vector # 55, 0x000000DC: Reserved
000000E0  0000 00B0   97              dc.l        $B0             ; Vector # 56, 0x000000E0: Reserved
000000E4  0000 00B4   98              dc.l        $B4             ; Vector # 57, 0x000000E4: Reserved
000000E8  0000 00B8   99              dc.l        $B8             ; Vector # 58, 0x000000E8: Reserved
000000EC  0000 00BC  100              dc.l        $BC             ; Vector # 59, 0x000000EC: Reserved
000000F0  0000 00C0  101              dc.l        $C0             ; Vector # 60, 0x000000F0: Reserved
000000F4  0000 00C4  102              dc.l        $C4             ; Vector # 61, 0x000000F4: Reserved
000000F8  0000 00C8  103              dc.l        $C8             ; Vector # 62, 0x000000F8: Reserved
000000FC  0000 00CC  104              dc.l        $CC             ; Vector # 63, 0x000000FC: Reserved
00000100  0000 0000  105              dc.l        0               ; Vector # 64, 0x00000100: User Defined Vector
00000104  0000 0000  106              dc.l        0               ; Vector # 65, 0x00000104: User Defined Vector
00000108  0000 0000  107              dc.l        0               ; Vector # 66, 0x00000108: User Defined Vector
0000010C  0000 0000  108              dc.l        0               ; Vector # 67, 0x0000010C: User Defined Vector
00000110  0000 0000  109              dc.l        0               ; Vector # 68, 0x00000110: User Defined Vector
00000114  0000 0000  110              dc.l        0               ; Vector # 69, 0x00000114: User Defined Vector
00000118  0000 0000  111              dc.l        0               ; Vector # 70, 0x00000118: User Defined Vector
0000011C  0000 0000  112              dc.l        0               ; Vector # 71, 0x0000011C: User Defined Vector
00000120  0000 0000  113              dc.l        0               ; Vector # 72, 0x00000120: User Defined Vector
00000124  0000 0000  114              dc.l        0               ; Vector # 73, 0x00000124: User Defined Vector
00000128  0000 0000  115              dc.l        0               ; Vector # 74, 0x00000128: User Defined Vector
0000012C  0000 0000  116              dc.l        0               ; Vector # 75, 0x0000012C: User Defined Vector
00000130  0000 0000  117              dc.l        0               ; Vector # 76, 0x00000130: User Defined Vector
00000134  0000 0000  118              dc.l        0               ; Vector # 77, 0x00000134: User Defined Vector
00000138  0000 0000  119              dc.l        0               ; Vector # 78, 0x00000138: User Defined Vector
0000013C  0000 0000  120              dc.l        0               ; Vector # 79, 0x0000013C: User Defined Vector
00000140  0000 0000  121              dc.l        0               ; Vector # 80, 0x00000140: User Defined Vector
00000144  0000 0000  122              dc.l        0               ; Vector # 81, 0x00000144: User Defined Vector
00000148  0000 0000  123              dc.l        0               ; Vector # 82, 0x00000148: User Defined Vector
0000014C  0000 0000  124              dc.l        0               ; Vector # 83, 0x0000014C: User Defined Vector
00000150  0000 0000  125              dc.l        0               ; Vector # 84, 0x00000150: User Defined Vector
00000154  0000 0000  126              dc.l        0               ; Vector # 85, 0x00000154: User Defined Vector
00000158  0000 0000  127              dc.l        0               ; Vector # 86, 0x00000158: User Defined Vector
0000015C  0000 0000  128              dc.l        0               ; Vector # 87, 0x0000015C: User Defined Vector
00000160  0000 0000  129              dc.l        0               ; Vector # 88, 0x00000160: User Defined Vector
00000164  0000 0000  130              dc.l        0               ; Vector # 89, 0x00000164: User Defined Vector
00000168  0000 0000  131              dc.l        0               ; Vector # 90, 0x00000168: User Defined Vector
0000016C  0000 0000  132              dc.l        0               ; Vector # 91, 0x0000016C: User Defined Vector
00000170  0000 0000  133              dc.l        0               ; Vector # 92, 0x00000170: User Defined Vector
00000174  0000 0000  134              dc.l        0               ; Vector # 93, 0x00000174: User Defined Vector
00000178  0000 0000  135              dc.l        0               ; Vector # 94, 0x00000178: User Defined Vector
0000017C  0000 0000  136              dc.l        0               ; Vector # 95, 0x0000017C: User Defined Vector
00000180  0000 0000  137              dc.l        0               ; Vector # 96, 0x00000180: User Defined Vector
00000184  0000 0000  138              dc.l        0               ; Vector # 97, 0x00000184: User Defined Vector
00000188  0000 0000  139              dc.l        0               ; Vector # 98, 0x00000188: User Defined Vector
0000018C  0000 0000  140              dc.l        0               ; Vector # 99, 0x0000018C: User Defined Vector
00000190  0000 0000  141              dc.l        0               ; Vector #100, 0x00000190: User Defined Vector
00000194  0000 0000  142              dc.l        0               ; Vector #101, 0x00000194: User Defined Vector
00000198  0000 0000  143              dc.l        0               ; Vector #102, 0x00000198: User Defined Vector
0000019C  0000 0000  144              dc.l        0               ; Vector #103, 0x0000019C: User Defined Vector
000001A0  0000 0000  145              dc.l        0               ; Vector #104, 0x000001A0: User Defined Vector
000001A4  0000 0000  146              dc.l        0               ; Vector #105, 0x000001A4: User Defined Vector
000001A8  0000 0000  147              dc.l        0               ; Vector #106, 0x000001A8: User Defined Vector
000001AC  0000 0000  148              dc.l        0               ; Vector #107, 0x000001AC: User Defined Vector
000001B0  0000 0000  149              dc.l        0               ; Vector #108, 0x000001B0: User Defined Vector
000001B4  0000 0000  150              dc.l        0               ; Vector #109, 0x000001B4: User Defined Vector
000001B8  0000 0000  151              dc.l        0               ; Vector #110, 0x000001B8: User Defined Vector
000001BC  0000 0000  152              dc.l        0               ; Vector #111, 0x000001BC: User Defined Vector
000001C0  0000 0000  153              dc.l        0               ; Vector #112, 0x000001C0: User Defined Vector
000001C4  0000 0000  154              dc.l        0               ; Vector #113, 0x000001C4: User Defined Vector
000001C8  0000 0000  155              dc.l        0               ; Vector #114, 0x000001C8: User Defined Vector
000001CC  0000 0000  156              dc.l        0               ; Vector #115, 0x000001CC: User Defined Vector
000001D0  0000 0000  157              dc.l        0               ; Vector #116, 0x000001D0: User Defined Vector
000001D4  0000 0000  158              dc.l        0               ; Vector #117, 0x000001D4: User Defined Vector
000001D8  0000 0000  159              dc.l        0               ; Vector #118, 0x000001D8: User Defined Vector
000001DC  0000 0000  160              dc.l        0               ; Vector #119, 0x000001DC: User Defined Vector
000001E0  0000 0000  161              dc.l        0               ; Vector #120, 0x000001E0: User Defined Vector
000001E4  0000 0000  162              dc.l        0               ; Vector #121, 0x000001E4: User Defined Vector
000001E8  0000 0000  163              dc.l        0               ; Vector #122, 0x000001E8: User Defined Vector
000001EC  0000 0000  164              dc.l        0               ; Vector #123, 0x000001EC: User Defined Vector
000001F0  0000 0000  165              dc.l        0               ; Vector #124, 0x000001F0: User Defined Vector
000001F4  0000 0000  166              dc.l        0               ; Vector #125, 0x000001F4: User Defined Vector
000001F8  0000 0000  167              dc.l        0               ; Vector #126, 0x000001F8: User Defined Vector
000001FC  0000 0000  168              dc.l        0               ; Vector #127, 0x000001FC: User Defined Vector
00000200  0000 0000  169              dc.l        0               ; Vector #128, 0x00000200: User Defined Vector
00000204  0000 0000  170              dc.l        0               ; Vector #129, 0x00000204: User Defined Vector
00000208  0000 0000  171              dc.l        0               ; Vector #130, 0x00000208: User Defined Vector
0000020C  0000 0000  172              dc.l        0               ; Vector #131, 0x0000020C: User Defined Vector
00000210  0000 0000  173              dc.l        0               ; Vector #132, 0x00000210: User Defined Vector
00000214  0000 0000  174              dc.l        0               ; Vector #133, 0x00000214: User Defined Vector
00000218  0000 0000  175              dc.l        0               ; Vector #134, 0x00000218: User Defined Vector
0000021C  0000 0000  176              dc.l        0               ; Vector #135, 0x0000021C: User Defined Vector
00000220  0000 0000  177              dc.l        0               ; Vector #136, 0x00000220: User Defined Vector
00000224  0000 0000  178              dc.l        0               ; Vector #137, 0x00000224: User Defined Vector
00000228  0000 0000  179              dc.l        0               ; Vector #138, 0x00000228: User Defined Vector
0000022C  0000 0000  180              dc.l        0               ; Vector #139, 0x0000022C: User Defined Vector
00000230  0000 0000  181              dc.l        0               ; Vector #140, 0x00000230: User Defined Vector
00000234  0000 0000  182              dc.l        0               ; Vector #141, 0x00000234: User Defined Vector
00000238  0000 0000  183              dc.l        0               ; Vector #142, 0x00000238: User Defined Vector
0000023C  0000 0000  184              dc.l        0               ; Vector #143, 0x0000023C: User Defined Vector
00000240  0000 0000  185              dc.l        0               ; Vector #144, 0x00000240: User Defined Vector
00000244  0000 0000  186              dc.l        0               ; Vector #145, 0x00000244: User Defined Vector
00000248  0000 0000  187              dc.l        0               ; Vector #146, 0x00000248: User Defined Vector
0000024C  0000 0000  188              dc.l        0               ; Vector #147, 0x0000024C: User Defined Vector
00000250  0000 0000  189              dc.l        0               ; Vector #148, 0x00000250: User Defined Vector
00000254  0000 0000  190              dc.l        0               ; Vector #149, 0x00000254: User Defined Vector
00000258  0000 0000  191              dc.l        0               ; Vector #150, 0x00000258: User Defined Vector
0000025C  0000 0000  192              dc.l        0               ; Vector #151, 0x0000025C: User Defined Vector
00000260  0000 0000  193              dc.l        0               ; Vector #152, 0x00000260: User Defined Vector
00000264  0000 0000  194              dc.l        0               ; Vector #153, 0x00000264: User Defined Vector
00000268  0000 0000  195              dc.l        0               ; Vector #154, 0x00000268: User Defined Vector
0000026C  0000 0000  196              dc.l        0               ; Vector #155, 0x0000026C: User Defined Vector
00000270  0000 0000  197              dc.l        0               ; Vector #156, 0x00000270: User Defined Vector
00000274  0000 0000  198              dc.l        0               ; Vector #157, 0x00000274: User Defined Vector
00000278  0000 0000  199              dc.l        0               ; Vector #158, 0x00000278: User Defined Vector
0000027C  0000 0000  200              dc.l        0               ; Vector #159, 0x0000027C: User Defined Vector
00000280  0000 0000  201              dc.l        0               ; Vector #160, 0x00000280: User Defined Vector
00000284  0000 0000  202              dc.l        0               ; Vector #161, 0x00000284: User Defined Vector
00000288  0000 0000  203              dc.l        0               ; Vector #162, 0x00000288: User Defined Vector
0000028C  0000 0000  204              dc.l        0               ; Vector #163, 0x0000028C: User Defined Vector
00000290  0000 0000  205              dc.l        0               ; Vector #164, 0x00000290: User Defined Vector
00000294  0000 0000  206              dc.l        0               ; Vector #165, 0x00000294: User Defined Vector
00000298  0000 0000  207              dc.l        0               ; Vector #166, 0x00000298: User Defined Vector
0000029C  0000 0000  208              dc.l        0               ; Vector #167, 0x0000029C: User Defined Vector
000002A0  0000 0000  209              dc.l        0               ; Vector #168, 0x000002A0: User Defined Vector
000002A4  0000 0000  210              dc.l        0               ; Vector #169, 0x000002A4: User Defined Vector
000002A8  0000 0000  211              dc.l        0               ; Vector #170, 0x000002A8: User Defined Vector
000002AC  0000 0000  212              dc.l        0               ; Vector #171, 0x000002AC: User Defined Vector
000002B0  0000 0000  213              dc.l        0               ; Vector #172, 0x000002B0: User Defined Vector
000002B4  0000 0000  214              dc.l        0               ; Vector #173, 0x000002B4: User Defined Vector
000002B8  0000 0000  215              dc.l        0               ; Vector #174, 0x000002B8: User Defined Vector
000002BC  0000 0000  216              dc.l        0               ; Vector #175, 0x000002BC: User Defined Vector
000002C0  0000 0000  217              dc.l        0               ; Vector #176, 0x000002C0: User Defined Vector
000002C4  0000 0000  218              dc.l        0               ; Vector #177, 0x000002C4: User Defined Vector
000002C8  0000 0000  219              dc.l        0               ; Vector #178, 0x000002C8: User Defined Vector
000002CC  0000 0000  220              dc.l        0               ; Vector #179, 0x000002CC: User Defined Vector
000002D0  0000 0000  221              dc.l        0               ; Vector #180, 0x000002D0: User Defined Vector
000002D4  0000 0000  222              dc.l        0               ; Vector #181, 0x000002D4: User Defined Vector
000002D8  0000 0000  223              dc.l        0               ; Vector #182, 0x000002D8: User Defined Vector
000002DC  0000 0000  224              dc.l        0               ; Vector #183, 0x000002DC: User Defined Vector
000002E0  0000 0000  225              dc.l        0               ; Vector #184, 0x000002E0: User Defined Vector
000002E4  0000 0000  226              dc.l        0               ; Vector #185, 0x000002E4: User Defined Vector
000002E8  0000 0000  227              dc.l        0               ; Vector #186, 0x000002E8: User Defined Vector
000002EC  0000 0000  228              dc.l        0               ; Vector #187, 0x000002EC: User Defined Vector
000002F0  0000 0000  229              dc.l        0               ; Vector #188, 0x000002F0: User Defined Vector
000002F4  0000 0000  230              dc.l        0               ; Vector #189, 0x000002F4: User Defined Vector
000002F8  0000 0000  231              dc.l        0               ; Vector #190, 0x000002F8: User Defined Vector
000002FC  0000 0000  232              dc.l        0               ; Vector #191, 0x000002FC: User Defined Vector
00000300  0000 0000  233              dc.l        0               ; Vector #192, 0x00000300: User Defined Vector
00000304  0000 0000  234              dc.l        0               ; Vector #193, 0x00000304: User Defined Vector
00000308  0000 0000  235              dc.l        0               ; Vector #194, 0x00000308: User Defined Vector
0000030C  0000 0000  236              dc.l        0               ; Vector #195, 0x0000030C: User Defined Vector
00000310  0000 0000  237              dc.l        0               ; Vector #196, 0x00000310: User Defined Vector
00000314  0000 0000  238              dc.l        0               ; Vector #197, 0x00000314: User Defined Vector
00000318  0000 0000  239              dc.l        0               ; Vector #198, 0x00000318: User Defined Vector
0000031C  0000 0000  240              dc.l        0               ; Vector #199, 0x0000031C: User Defined Vector
00000320  0000 0000  241              dc.l        0               ; Vector #200, 0x00000320: User Defined Vector
00000324  0000 0000  242              dc.l        0               ; Vector #201, 0x00000324: User Defined Vector
00000328  0000 0000  243              dc.l        0               ; Vector #202, 0x00000328: User Defined Vector
0000032C  0000 0000  244              dc.l        0               ; Vector #203, 0x0000032C: User Defined Vector
00000330  0000 0000  245              dc.l        0               ; Vector #204, 0x00000330: User Defined Vector
00000334  0000 0000  246              dc.l        0               ; Vector #205, 0x00000334: User Defined Vector
00000338  0000 0000  247              dc.l        0               ; Vector #206, 0x00000338: User Defined Vector
0000033C  0000 0000  248              dc.l        0               ; Vector #207, 0x0000033C: User Defined Vector
00000340  0000 0000  249              dc.l        0               ; Vector #208, 0x00000340: User Defined Vector
00000344  0000 0000  250              dc.l        0               ; Vector #209, 0x00000344: User Defined Vector
00000348  0000 0000  251              dc.l        0               ; Vector #210, 0x00000348: User Defined Vector
0000034C  0000 0000  252              dc.l        0               ; Vector #211, 0x0000034C: User Defined Vector
00000350  0000 0000  253              dc.l        0               ; Vector #212, 0x00000350: User Defined Vector
00000354  0000 0000  254              dc.l        0               ; Vector #213, 0x00000354: User Defined Vector
00000358  0000 0000  255              dc.l        0               ; Vector #214, 0x00000358: User Defined Vector
0000035C  0000 0000  256              dc.l        0               ; Vector #215, 0x0000035C: User Defined Vector
00000360  0000 0000  257              dc.l        0               ; Vector #216, 0x00000360: User Defined Vector
00000364  0000 0000  258              dc.l        0               ; Vector #217, 0x00000364: User Defined Vector
00000368  0000 0000  259              dc.l        0               ; Vector #218, 0x00000368: User Defined Vector
0000036C  0000 0000  260              dc.l        0               ; Vector #219, 0x0000036C: User Defined Vector
00000370  0000 0000  261              dc.l        0               ; Vector #220, 0x00000370: User Defined Vector
00000374  0000 0000  262              dc.l        0               ; Vector #221, 0x00000374: User Defined Vector
00000378  0000 0000  263              dc.l        0               ; Vector #222, 0x00000378: User Defined Vector
0000037C  0000 0000  264              dc.l        0               ; Vector #223, 0x0000037C: User Defined Vector
00000380  0000 0000  265              dc.l        0               ; Vector #224, 0x00000380: User Defined Vector
00000384  0000 0000  266              dc.l        0               ; Vector #225, 0x00000384: User Defined Vector
00000388  0000 0000  267              dc.l        0               ; Vector #226, 0x00000388: User Defined Vector
0000038C  0000 0000  268              dc.l        0               ; Vector #227, 0x0000038C: User Defined Vector
00000390  0000 0000  269              dc.l        0               ; Vector #228, 0x00000390: User Defined Vector
00000394  0000 0000  270              dc.l        0               ; Vector #229, 0x00000394: User Defined Vector
00000398  0000 0000  271              dc.l        0               ; Vector #230, 0x00000398: User Defined Vector
0000039C  0000 0000  272              dc.l        0               ; Vector #231, 0x0000039C: User Defined Vector
000003A0  0000 0000  273              dc.l        0               ; Vector #232, 0x000003A0: User Defined Vector
000003A4  0000 0000  274              dc.l        0               ; Vector #233, 0x000003A4: User Defined Vector
000003A8  0000 0000  275              dc.l        0               ; Vector #234, 0x000003A8: User Defined Vector
000003AC  0000 0000  276              dc.l        0               ; Vector #235, 0x000003AC: User Defined Vector
000003B0  0000 0000  277              dc.l        0               ; Vector #236, 0x000003B0: User Defined Vector
000003B4  0000 0000  278              dc.l        0               ; Vector #237, 0x000003B4: User Defined Vector
000003B8  0000 0000  279              dc.l        0               ; Vector #238, 0x000003B8: User Defined Vector
000003BC  0000 0000  280              dc.l        0               ; Vector #239, 0x000003BC: User Defined Vector
000003C0  0000 0000  281              dc.l        0               ; Vector #240, 0x000003C0: User Defined Vector
000003C4  0000 0000  282              dc.l        0               ; Vector #241, 0x000003C4: User Defined Vector
000003C8  0000 0000  283              dc.l        0               ; Vector #242, 0x000003C8: User Defined Vector
000003CC  0000 0000  284              dc.l        0               ; Vector #243, 0x000003CC: User Defined Vector
000003D0  0000 0000  285              dc.l        0               ; Vector #244, 0x000003D0: User Defined Vector
000003D4  0000 0000  286              dc.l        0               ; Vector #245, 0x000003D4: User Defined Vector
000003D8  0000 0000  287              dc.l        0               ; Vector #246, 0x000003D8: User Defined Vector
000003DC  0000 0000  288              dc.l        0               ; Vector #247, 0x000003DC: User Defined Vector
000003E0  0000 0000  289              dc.l        0               ; Vector #248, 0x000003E0: User Defined Vector
000003E4  0000 0000  290              dc.l        0               ; Vector #249, 0x000003E4: User Defined Vector
000003E8  0000 0000  291              dc.l        0               ; Vector #250, 0x000003E8: User Defined Vector
000003EC  0000 0000  292              dc.l        0               ; Vector #251, 0x000003EC: User Defined Vector
000003F0  0000 0000  293              dc.l        0               ; Vector #252, 0x000003F0: User Defined Vector
000003F4  0000 0000  294              dc.l        0               ; Vector #253, 0x000003F4: User Defined Vector
000003F8  0000 0000  295              dc.l        0               ; Vector #254, 0x000003F8: User Defined Vector
000003FC  0000 0000  296              dc.l        0               ; Vector #255, 0x000003FC: User Defined Vector
                     297   startup:
00000400  41F9 0080  298              lea         bss,A0
00000404  0000      
00000406  4218       299              clr.b       (A0)+           ; set bss section to zero
00000408  B1FC 0080  300              cmp.l       #heap,A0
0000040C  1432      
0000040E  65F6       301              bcs.s       *-8
00000410  23FC FFFF  302              move.l      #-1,__ungetbuf  ; init ungetbuffer for keyboard input
00000414  FFFF 0080 
00000418  0000      
0000041A  23FC 0000  303              move.l      #(end_ROM-begin_ROM),__romsize
0000041E  5BE8 0080 
00000422  000C      
00000424  23FC 0000  304              move.l      #(end_RAM-begin_RAM),__ramsize
00000428  1432 0080 
0000042C  0010      
0000042E  4EB9 0000  305              jsr         _main
00000432  583A      
                     306   
                     307   __exit:                                ; exit() and _exit()functions
00000434  4E4F       308              trap        #15
00000436  0000       309              dc.w        0               ; IDE68K system call 0 -> EXIT (no return)
00000438  60C6       310              bra         startup         ; when re-started after exit() call
                     311   
                     312   __putch:                               ; Basic character output routine
0000043A  202F 0004  313              move.l      4(A7),D0
0000043E  4E4F       314              trap        #15
00000440  0001       315              dc.w        1               ; IDE68K system call 1 -> PUTCH
00000442  4E75       316              rts
                     317   
                     318   __getch:                               ; Basic character input routine
00000444  4E4F       319              trap        #15
00000446  0003       320              dc.w        3               ; IDE68K system call 3 -> GETCH
00000448  4880       321              ext.w       D0
0000044A  48C0       322              ext.l       D0              ; D0.L is char, sign extended to 32 bits
0000044C  4E75       323              rts
                     324   
                     325   __kbhit:
0000044E  4E4F       326              trap        #15
00000450  0004       327              dc.w        4               ; IDE68K system call 4 -> KBHIT
00000452  56C0       328              sne         D0              ; D0.B = $FF if char in buffer, $00 if not
00000454  4E75       329              rts
                     330   
                     331   __time:
00000456  4E4F       332              trap        #15             ; IDE68K system call 40 -> GETTIME
00000458  0028       333              dc.w        40              ; D0 = seconds since Jan 1, 1970, 00:00:00 hr UTC
0000045A  4E75       334              rts
                     335   
                     336   __localoffset:
0000045C  4E4F       337              trap        #15             ; IDE68K system call 41 -> LOCALOFFSET
0000045E  0029       338              dc.w        41              ; D0 = offset in seconds between UTC and local time
00000460  4E75       339              rts
                     340   
                     341   ;********************************************************************************************************
                     342   ;                                               uC/OS-II
                     343   ;                                         The Real-Time Kernel
                     344   ;
                     345   ;                            (c) Copyright 1999, Jean J. Labrosse, Weston, FL
                     346   ;                                          All Rights Reserved
                     347   ;
                     348   ;
                     349   ;                                     68000 Specific assembly code
                     350   ;                                               IDE68K
                     351   ;
                     352   ; File         : OS_CPU_A.ASM
                     353   ; By           : Jean J. Labrosse, Peter J. Fondse
                     354   ;********************************************************************************************************
                     355   
                     356   
                     357   ;********************************************************************************************************
                     358   ;                                            REVISION HISTORY
                     359   ;
                     360   ; $Log$
                     361   ;
                     362   ;********************************************************************************************************
                     363   
                     364   
                     365   ;********************************************************************************************************
                     366   ;                                          PUBLIC DECLARATIONS
                     367   ;********************************************************************************************************
                     368   
                     369   
                     370   ;********************************************************************************************************
                     371   ;                                         EXTERNAL DECLARATIONS
                     372   ;********************************************************************************************************
                     373   
                     374   
                     375   ;********************************************************************************************************
                     376   ;                               START HIGHEST PRIORITY TASK READY-TO-RUN
                     377   ;
                     378   ; Description : This function is called by OSStart() to start the highest priority task that was created
                     379   ;               by your application before calling OSStart().
                     380   ;
                     381   ; Arguments   : none
                     382   ;
                     383   ; Note(s)     : 1) The stack frame is assumed to look as follows:
                     384   ;
                     385   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)        Low Memory
                     386   ;                                            +  2         D0    (L)
                     387   ;                                            +  4         D1    (H)
                     388   ;                                            +  6         D1    (L)
                     389   ;                                            +  8         D2    (H)
                     390   ;                                            + 10         D2    (L)
                     391   ;                                            + 12         D3    (H)
                     392   ;                                            + 14         D3    (L)
                     393   ;                                            + 16         D4    (H)
                     394   ;                                            + 18         D4    (L)
                     395   ;                                            + 20         D5    (H)
                     396   ;                                            + 22         D5    (L)
                     397   ;                                            + 24         D6    (H)
                     398   ;                                            + 26         D6    (L)
                     399   ;                                            + 28         D7    (H)
                     400   ;                                            + 30         D7    (L)
                     401   ;                                            + 32         A0    (H)
                     402   ;                                            + 34         A0    (L)
                     403   ;                                            + 36         A1    (H)
                     404   ;                                            + 38         A1    (L)
                     405   ;                                            + 40         A2    (H)
                     406   ;                                            + 42         A2    (L)
                     407   ;                                            + 44         A3    (H)
                     408   ;                                            + 46         A3    (L)
                     409   ;                                            + 48         A4    (H)
                     410   ;                                            + 50         A4    (L)
                     411   ;                                            + 52         A5    (H)
                     412   ;                                            + 54         A5    (L)
                     413   ;                                            + 56         A6    (H)
                     414   ;                                            + 58         A6    (L)
                     415   ;                                            + 60         OS_INITIAL_SR
                     416   ;                                            + 62         task  (H)
                     417   ;                                            + 64         task  (L)
                     418   ;                                            + 66         task  (H)
                     419   ;                                            + 68         task  (L)
                     420   ;                                            + 70         pdata (H)
                     421   ;                                            + 72         pdata (L)        High Memory
                     422   ;
                     423   ;               2) OSStartHighRdy() MUST:
                     424   ;                      a) Call OSTaskSwHook() then,
                     425   ;                      b) Set OSRunning to TRUE,
                     426   ;                      c) Switch to the highest priority task.
                     427   ;********************************************************************************************************
                     428   
                     429   
                     430   _OSStartHighRdy:
00000462  4EB9 0000  431           jsr       _OSTaskSwHook            ; Invoke user defined context switch hook
00000466  06EC      
00000468  5239 0080  432           addq.b    #1,_OSRunning            ; Indicate that we are multitasking
0000046C  0258      
0000046E  2079 0080  433           move.l    _OSTCBHighRdy,A0         ; Point to TCB of highest priority task ready to run
00000472  0368      
00000474  2E50       434           move.l    (A0),A7                  ; Get the stack pointer of the task to resume
00000476  4CDF 7FFF  435           movem.l   (A7)+,A0-A6/D0-D7        ; Restore the CPU registers
0000047A  4E73       436           rte                                ; Run task
                     437   
                     438   ;********************************************************************************************************
                     439   ;                                       TASK LEVEL CONTEXT SWITCH
                     440   ;
                     441   ; Description : This function is called when a task makes a higher priority task ready-to-run.
                     442   ;               Called with TRAP #0 instruction (see vector table entry at address 0x0080 in boot.asm)
                     443   ;
                     444   ; Arguments   : none
                     445   ;
                     446   ; Note(s)     : 1) Upon entry,
                     447   ;                  OSTCBCur     points to the OS_TCB of the task to suspend
                     448   ;                  OSTCBHighRdy points to the OS_TCB of the task to resume
                     449   ;
                     450   ;               2) The stack frame of the task to suspend looks as follows (the registers for
                     451   ;                  task to suspend need to be saved):
                     452   ;
                     453   ;                                         SP +  0  ---->  SR                   Low Memory
                     454   ;                                            +  2         PC of task  (H)
                     455   ;                                            +  4         PC of task  (L)      High Memory
                     456   ;
                     457   ;               3) The stack frame of the task to resume looks as follows:
                     458   ;
                     459   ;                  OSTCBHighRdy->OSTCBStkPtr +  0  ---->  D0    (H)           Low Memory
                     460   ;                                            +  2         D0    (L)
                     461   ;                                            +  4         D1    (H)
                     462   ;                                            +  6         D1    (L)
                     463   ;                                            +  8         D2    (H)
                     464   ;                                            + 10         D2    (L)
                     465   ;                                            + 12         D3    (H)
                     466   ;                                            + 14         D3    (L)
                     467   ;                                            + 16         D4    (H)
                     468   ;                                            + 18         D4    (L)
                     469   ;                                            + 20         D5    (H)
                     470   ;                                            + 22         D5    (L)
                     471   ;                                            + 24         D6    (H)
                     472   ;                                            + 26         D6    (L)
                     473   ;                                            + 28         D7    (H)
                     474   ;                                            + 30         D7    (L)
                     475   ;                                            + 32         A0    (H)
                     476   ;                                            + 34         A0    (L)
                     477   ;                                            + 36         A1    (H)
                     478   ;                                            + 38         A1    (L)
                     479   ;                                            + 40         A2    (H)
                     480   ;                                            + 42         A2    (L)
                     481   ;                                            + 44         A3    (H)
                     482   ;                                            + 46         A3    (L)
                     483   ;                                            + 48         A4    (H)
                     484   ;                                            + 50         A4    (L)
                     485   ;                                            + 52         A5    (H)
                     486   ;                                            + 54         A5    (L)
                     487   ;                                            + 56         A6    (H)
                     488   ;                                            + 58         A6    (L)
                     489   ;                                            + 60         OS_INITIAL_SR       (See OS_CPU.H)
                     490   ;                                            + 62         PC of task  (H)
                     491   ;                                            + 64         PC of task  (L)     High Memory
                     492   ;********************************************************************************************************
                     493   
                     494   _OSCtxSw:
0000047C  48E7 FFFE  495           movem.l   A0-A6/D0-D7,-(A7)              ; Save the registers of the current task
00000480  2079 0080  496           move.l    _OSTCBCur,A0                   ; Save the stack pointer in the suspended task TCB
00000484  0360      
00000486  208F       497           move.l    A7,(A0)
00000488  4EB9 0000  498           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
0000048C  06EC      
0000048E  13F9 0080  499           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
00000492  024C 0080 
00000496  024A      
00000498  2079 0080  500           move.l    _OSTCBHighRdy,A0               ; OSTCBCur  = OSTCBHighRdy
0000049C  0368      
0000049E  23C8 0080  501           move.l    A0,_OSTCBCur
000004A2  0360      
000004A4  2E50       502           move.l    (A0),A7                        ; Get the stack pointer of the task to resume
000004A6  4CDF 7FFF  503           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
000004AA  4E73       504           rte                                      ; Run task
                     505   
                     506   ;********************************************************************************************************
                     507   ;                                      INTERRUPT LEVEL CONTEXT SWITCH
                     508   ;
                     509   ; Description : This function is called from OSIntExit() in OS_CORE.C
                     510   ;               Provided for backward compatibility.
                     511   ;               The ISR MUST NOT call OSIntExit(), but should jump to OSIntExit68K().
                     512   ;********************************************************************************************************
                     513   
                     514   _OSIntCtxSw:
000004AC  DFFC 0000  515           adda.l    #10,A7                         ; Adjust the stack
000004B0  000A      
000004B2  2279 0080  516           move.l    _OSTCBCur,A1                   ; Save the stack pointer in the suspended task TCB
000004B6  0360      
000004B8  228F       517           move.l    A7,(A1)
000004BA  4EB9 0000  518           jsr       _OSTaskSwHook                  ; Invoke user defined context switch hook
000004BE  06EC      
000004C0  2279 0080  519           move.l    _OSTCBHighRdy,A1               ; OSTCBCur  = OSTCBHighRdy
000004C4  0368      
000004C6  23C9 0080  520           move.l    A1,_OSTCBCur
000004CA  0360      
000004CC  2E51       521           move.l    (A1),A7                        ; Get the stack pointer of the task to resume
000004CE  13F9 0080  522           move.b    _OSPrioHighRdy,_OSPrioCur      ; OSPrioCur = OSPrioHighRdy
000004D2  024C 0080 
000004D6  024A      
000004D8  4CDF 7FFF  523           movem.l   (A7)+,A0-A6/D0-D7              ; Restore the CPU registers
000004DC  4E73       524           rte                                      ; Run task
                     525   
                     526   ;********************************************************************************************************
                     527   ;                           INTERRUPT EXIT FUNCTION (IDE68K specific)
                     528   ;
                     529   ; Description : ISR's (written in Assembly) must directly JUMP to OSIntExit68K
                     530   ;
                     531   ; Notes       : You must NOT call OSIntExit() to exit an ISR with IDE68K, but JUMP to OSIntExit68K().
                     532   ;
                     533   ; Stack frame upon entry:
                     534   ;
                     535   ;                  SP +  0  ---->  D0    (H)
                     536   ;                     +  2         D0    (L)
                     537   ;                     +  4         D1    (H)
                     538   ;                     +  6         D1    (L)
                     539   ;                     +  8         D2    (H)
                     540   ;                     + 10         D2    (L)
                     541   ;                     + 12         D3    (H)
                     542   ;                     + 14         D3    (L)
                     543   ;                     + 16         D4    (H)
                     544   ;                     + 18         D4    (L)
                     545   ;                     + 20         D5    (H)
                     546   ;                     + 22         D5    (L)
                     547   ;                     + 24         D6    (H)
                     548   ;                     + 26         D6    (L)
                     549   ;                     + 28         D7    (H)
                     550   ;                     + 30         D7    (L)
                     551   ;                     + 32         A0    (H)
                     552   ;                     + 34         A0    (L)
                     553   ;                     + 36         A1    (H)
                     554   ;                     + 38         A1    (L)
                     555   ;                     + 40         A2    (H)
                     556   ;                     + 42         A2    (L)
                     557   ;                     + 44         A3    (H)
                     558   ;                     + 46         A3    (L)
                     559   ;                     + 48         A4    (H)
                     560   ;                     + 50         A4    (L)
                     561   ;                     + 52         A5    (H)
                     562   ;                     + 54         A5    (L)
                     563   ;                     + 56         A6    (H)
                     564   ;                     + 58         A6    (L)
                     565   ;                     + 60         Task or ISR's SR
                     566   ;                     + 62         PC of task  (H)
                     567   ;                     + 64         PC of task  (L)                   High Memory
                     568   ;********************************************************************************************************
                     569   
                     570   OSIntExit68K:
000004DE  5339 0080  571           subq.b    #1,_OSIntNesting              ; if (--OSIntNesting == 0)
000004E2  0246      
000004E4  6600 009C  572           bne       OSIntExit68K_1
000004E8  4A39 0080  573           tst.b     _OSLockNesting                ; if (OSLockNesting == 0)
000004EC  0248      
000004EE  6600 0092  574           bne       OSIntExit68K_1
000004F2  302F 003C  575           move.w    (60,A7),D0                    ;  if (LAST nested ISR)
000004F6  C07C 0700  576           and.w     #$0700,D0
000004FA  6600 0086  577           bne       OSIntExit68K_1
000004FE  41F9 0000  578           lea       _OSUnMapTbl,A0                ;  y = OSUnMapTbl[OSRdyGrp];
00000502  5AE0      
00000504  4280       579           clr.l     D0
00000506  1039 0080  580           move.b    _OSRdyGrp,D0
0000050A  024E      
0000050C  1230 0800  581           move.b    0(A0,D0.L),D1                 ;  y in D1
00000510  41F9 0080  582           lea       _OSRdyTbl,A0                  ;  OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
00000514  0250      
00000516  4280       583           clr.l     D0
00000518  1001       584           move.b    D1,D0
0000051A  41F0 0800  585           lea       0(A0,D0.L),A0
0000051E  4280       586           clr.l     D0
00000520  1010       587           move.b    (A0),D0                       ;  OSRdyTbl[y] in D0
00000522  41F9 0000  588           lea       _OSUnMapTbl,A0
00000526  5AE0      
00000528  41F0 0800  589           lea       0(A0,D0.L),A0                 ;  &OSUnMapTbl[OSRdyTbl[y]] in A0
0000052C  1001       590           move.b    D1,D0
0000052E  E708       591           lsl.b     #3,D0                         ;  (y << 3) in D0
00000530  D010       592           add.b     (A0),D0
00000532  13C0 0080  593           move.b    D0,_OSPrioHighRdy
00000536  024C      
00000538  B039 0080  594           cmp.b     _OSPrioCur,D0                 ;  if (OSPrioCur != OSPrioHighRdy) {
0000053C  024A      
0000053E  6742       595           beq.s     OSIntExit68K_1
00000540  41F9 0080  596           lea       _OSTCBPrioTbl,A0              ;    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
00000544  0370      
00000546  4281       597           clr.l     D1
00000548  1200       598           move.b    D0,D1
0000054A  E589       599           lsl.l     #2,D1
0000054C  41F0 1800  600           lea       0(A0,D1.L),A0
00000550  23D0 0080  601           move.l    (A0),_OSTCBHighRdy
00000554  0368      
00000556  52B9 0080  602           addq.l    #1,_OSCtxSwCtr                ;    OSCtxSwCtr++;
0000055A  0016      
0000055C  2079 0080  603           move.l    _OSTCBCur,A0                  ;    Save the stack pointer in the suspended task TCB
00000560  0360      
00000562  208F       604           move.l    A7,(A0)
00000564  4EB9 0000  605           jsr       _OSTaskSwHook                 ;    Invoke user defined context switch hook
00000568  06EC      
0000056A  2079 0080  606           move.l    _OSTCBHighRdy,A0              ;    OSTCBCur  = OSTCBHighRdy
0000056E  0368      
00000570  23C8 0080  607           move.l    A0,_OSTCBCur
00000574  0360      
00000576  13F9 0080  608           move.b    _OSPrioHighRdy,_OSPrioCur     ;    OSPrioCur = OSPrioHighRdy
0000057A  024C 0080 
0000057E  024A      
00000580  2E50       609           move.l    (A0),A7                       ;    Get the stack pointer of the task to resume
                     610   OSIntExit68K_1:
00000582  4CDF 7FFF  611           movem.l   (A7)+,A0-A6/D0-D7             ;  Restore the CPU registers
00000586  4E73       612           rte                                     ;  Return to task or nested ISR
                     613   
                     614   ;********************************************************************************************************
                     615   ;                                           SYSTEM TICK ISR
                     616   ;
                     617   ; Description : This function is the ISR used to notify uC/OS-II that a system tick has occurred.
                     618   ;
                     619   ; Arguments   : none
                     620   ;
                     621   ; Notes       : 1) You MUST increment 'OSIntNesting' and NOT call OSIntEnter()
                     622   ;               2) You MUST save ALL the CPU registers as shown below
                     623   ;               3) You MUST JUMP to OSIntExit68K() instead of call the function.
                     624   ;********************************************************************************************************
                     625   
                     626   _OSTickISR:
00000588  007C 0700  627           or.w      #$0700,SR                     ; Disable ALL interrupts
0000058C  5239 0080  628           addq.b    #1,_OSIntNesting              ; OSIntNesting++;
00000590  0246      
00000592  48E7 FFFE  629           movem.l   A0-A6/D0-D7,-(A7)             ; Save the registers of the current task
00000596  4EB9 0000  630           jsr       _OSTimeTick                   ; Call uC/OS-II's tick updating function
0000059A  0D4A      
0000059C  6000 FF40  631           bra       OSIntExit68K                  ; Exit ISR
                     632   ; C:\IDE68K\EM-LAB\OS_CPU_C.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     633   ; /*
                     634   ; *********************************************************************************************************
                     635   ; *                                               uC/OS-II
                     636   ; *                                         The Real-Time Kernel
                     637   ; *
                     638   ; *                            (c) Copyright 2000, Jean J. Labrosse, Weston, FL
                     639   ; *                                          All Rights Reserved
                     640   ; *
                     641   ; *
                     642   ; *                                         68000 Specific C code
                     643   ; *                                                IDE68K
                     644   ; *
                     645   ; * File         : OS_CPU_C.C
                     646   ; * By           : Jean J. Labrosse
                     647   ; *********************************************************************************************************
                     648   ; */
                     649   ; #ifndef  OS_MASTER_FILE
                     650   ; #include <ucos_ii.h>
                     651   ; #endif
                     652   ; /*
                     653   ; *********************************************************************************************************
                     654   ; *                                           REVISION HISTORY
                     655   ; *
                     656   ; * $Log$
                     657   ; *
                     658   ; *********************************************************************************************************
                     659   ; */
                     660   ; #if OS_TMR_EN > 0
                     661   ; INT8U OSTmrTickCtr;
                     662   ; #endif
                     663   ; /*$PAGE*/
                     664   ; /*
                     665   ; *********************************************************************************************************
                     666   ; *                                        INITIALIZE A TASK'S STACK
                     667   ; *
                     668   ; * Description: This function is called by either OSTaskCreate() or OSTaskCreateExt() to initialize the
                     669   ; *              stack frame of the task being created.  This function is highly processor specific.
                     670   ; *
                     671   ; * Arguments  : task          is a pointer to the task code
                     672   ; *
                     673   ; *              pdata         is a pointer to a user supplied data area that will be passed to the task
                     674   ; *                            when the task first executes.
                     675   ; *
                     676   ; *              ptos          is a pointer to the top of stack.  It is assumed that 'ptos' points to
                     677   ; *                            a 'free' entry on the task stack.  If OS_STK_GROWTH is set to 1 then
                     678   ; *                            'ptos' will contain the HIGHEST valid address of the stack.  Similarly, if
                     679   ; *                            OS_STK_GROWTH is set to 0, the 'ptos' will contains the LOWEST valid address
                     680   ; *                            of the stack.
                     681   ; *
                     682   ; *              opt           specifies options that can be used to alter the behavior of OSTaskStkInit().
                     683   ; *                            (see uCOS_II.H for OS_TASK_OPT_???).
                     684   ; *
                     685   ; * Returns    : Always returns the location of the new top-of-stack' once the processor registers have
                     686   ; *              been placed on the stack in the proper order.
                     687   ; *
                     688   ; * Note(s)    : 1) The initial value of the Status Register (SR) is OS_INITIAL_SR sets the 683xx processor
                     689   ; *                 to run in SUPERVISOR mode.  It is assumed that all uC/OS-II tasks run in supervisor
                     690   ; *                 mode.
                     691   ; *              2) You can pass the above options in the 'opt' argument.  You MUST only use the upper
                     692   ; *                 8 bits of 'opt' because the lower bits are reserved by uC/OS-II.  If you make changes
                     693   ; *                 to the code below, you will need to ensure that it doesn't affect the behaviour of
                     694   ; *                 OSTaskIdle() and OSTaskStat().
                     695   ; *              3) Registers are initialized to make them easy to differentiate with a debugger.
                     696   ; *********************************************************************************************************
                     697   ; */
                     698   ; OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *ptos, INT16U opt)
                     699   ; {
                     700   _OSTaskStkInit:
000005A0  4E56 0000  701          link      A6,#0
000005A4  48E7 3000  702          movem.l   D2/D3,-(A7)
                     703   ; INT32U  *pstk32;
                     704   ; INT16U  *pstk16;
                     705   ; opt       = opt;                                  /* 'opt' is not used, prevent warning            */
                     706   ; /* Load stack pointer and align on 32-bit bound  */
                     707   ; pstk32    = (INT32U *)((INT32U)ptos & 0xFFFFFFFCL);
000005A8  202E 0010  708          move.l    16(A6),D0
000005AC  C0BC 7FFF  709          and.l     #2147483647,D0
000005B0  FFFF      
000005B2  2400       710          move.l    D0,D2
                     711   ; /* -- SIMULATE CALL TO FUNCTION WITH ARGUMENT -- */
                     712   ; *--pstk32 = (INT32U)pdata;                        /*    pdata                                      */
000005B4  5982       713          subq.l    #4,D2
000005B6  2042       714          move.l    D2,A0
000005B8  20AE 000C  715          move.l    12(A6),(A0)
                     716   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
000005BC  5982       717          subq.l    #4,D2
000005BE  2042       718          move.l    D2,A0
000005C0  20AE 0008  719          move.l    8(A6),(A0)
                     720   ; /* ------ SIMULATE INTERRUPT STACK FRAME ------- */
                     721   ; *--pstk32 = (INT32U)task;                         /*    Task return address                        */
000005C4  5982       722          subq.l    #4,D2
000005C6  2042       723          move.l    D2,A0
000005C8  20AE 0008  724          move.l    8(A6),(A0)
                     725   ; pstk16    = (INT16U *)pstk32;                     /* Switch to 16-bit wide stack                   */
000005CC  2602       726          move.l    D2,D3
                     727   ; *--pstk16 = (INT16U)OS_INITIAL_SR;                /*    Initial Status Register value for the task */
000005CE  5583       728          subq.l    #2,D3
000005D0  2043       729          move.l    D3,A0
000005D2  30BC 2000  730          move.w    #8192,(A0)
                     731   ; pstk32    = (INT32U *)pstk16;                     /* Switch to 32-bit wide stack                   */
000005D6  2403       732          move.l    D3,D2
                     733   ; /* ------- SAVE ALL PROCESSOR REGISTERS -------- */
                     734   ; *--pstk32 = (INT32U)0x00A600A6L;                  /* Register A6                                   */
000005D8  5982       735          subq.l    #4,D2
000005DA  2042       736          move.l    D2,A0
000005DC  20BC 00A6  737          move.l    #10879142,(A0)
000005E0  00A6      
                     738   ; *--pstk32 = (INT32U)0x00A500A5L;                  /* Register A5                                   */
000005E2  5982       739          subq.l    #4,D2
000005E4  2042       740          move.l    D2,A0
000005E6  20BC 00A5  741          move.l    #10813605,(A0)
000005EA  00A5      
                     742   ; *--pstk32 = (INT32U)0x00A400A4L;                  /* Register A4                                   */
000005EC  5982       743          subq.l    #4,D2
000005EE  2042       744          move.l    D2,A0
000005F0  20BC 00A4  745          move.l    #10748068,(A0)
000005F4  00A4      
                     746   ; *--pstk32 = (INT32U)0x00A300A3L;                  /* Register A3                                   */
000005F6  5982       747          subq.l    #4,D2
000005F8  2042       748          move.l    D2,A0
000005FA  20BC 00A3  749          move.l    #10682531,(A0)
000005FE  00A3      
                     750   ; *--pstk32 = (INT32U)0x00A200A2L;                  /* Register A2                                   */
00000600  5982       751          subq.l    #4,D2
00000602  2042       752          move.l    D2,A0
00000604  20BC 00A2  753          move.l    #10616994,(A0)
00000608  00A2      
                     754   ; *--pstk32 = (INT32U)0x00A100A1L;                  /* Register A1                                   */
0000060A  5982       755          subq.l    #4,D2
0000060C  2042       756          move.l    D2,A0
0000060E  20BC 00A1  757          move.l    #10551457,(A0)
00000612  00A1      
                     758   ; *--pstk32 = (INT32U)0x00A000A0L;                  /* Register A0                                   */
00000614  5982       759          subq.l    #4,D2
00000616  2042       760          move.l    D2,A0
00000618  20BC 00A0  761          move.l    #10485920,(A0)
0000061C  00A0      
                     762   ; *--pstk32 = (INT32U)0x00D700D7L;                  /* Register D7                                   */
0000061E  5982       763          subq.l    #4,D2
00000620  2042       764          move.l    D2,A0
00000622  20BC 00D7  765          move.l    #14090455,(A0)
00000626  00D7      
                     766   ; *--pstk32 = (INT32U)0x00D600D6L;                  /* Register D6                                   */
00000628  5982       767          subq.l    #4,D2
0000062A  2042       768          move.l    D2,A0
0000062C  20BC 00D6  769          move.l    #14024918,(A0)
00000630  00D6      
                     770   ; *--pstk32 = (INT32U)0x00D500D5L;                  /* Register D5                                   */
00000632  5982       771          subq.l    #4,D2
00000634  2042       772          move.l    D2,A0
00000636  20BC 00D5  773          move.l    #13959381,(A0)
0000063A  00D5      
                     774   ; *--pstk32 = (INT32U)0x00D400D4L;                  /* Register D4                                   */
0000063C  5982       775          subq.l    #4,D2
0000063E  2042       776          move.l    D2,A0
00000640  20BC 00D4  777          move.l    #13893844,(A0)
00000644  00D4      
                     778   ; *--pstk32 = (INT32U)0x00D300D3L;                  /* Register D3                                   */
00000646  5982       779          subq.l    #4,D2
00000648  2042       780          move.l    D2,A0
0000064A  20BC 00D3  781          move.l    #13828307,(A0)
0000064E  00D3      
                     782   ; *--pstk32 = (INT32U)0x00D200D2L;                  /* Register D2                                   */
00000650  5982       783          subq.l    #4,D2
00000652  2042       784          move.l    D2,A0
00000654  20BC 00D2  785          move.l    #13762770,(A0)
00000658  00D2      
                     786   ; *--pstk32 = (INT32U)0x00D100D1L;                  /* Register D1                                   */
0000065A  5982       787          subq.l    #4,D2
0000065C  2042       788          move.l    D2,A0
0000065E  20BC 00D1  789          move.l    #13697233,(A0)
00000662  00D1      
                     790   ; *--pstk32 = (INT32U)0x00D000D0L;                  /* Register D0                                   */
00000664  5982       791          subq.l    #4,D2
00000666  2042       792          move.l    D2,A0
00000668  20BC 00D0  793          move.l    #13631696,(A0)
0000066C  00D0      
                     794   ; return ((OS_STK *)pstk32);                        /* Return pointer to new top-of-stack            */
0000066E  2002       795          move.l    D2,D0
00000670  4CDF 000C  796          movem.l   (A7)+,D2/D3
00000674  4E5E       797          unlk      A6
00000676  4E75       798          rts
                     799   ; }
                     800   ; /*$PAGE*/
                     801   ; /*
                     802   ; *********************************************************************************************************
                     803   ; *                                             GET ISR VECTOR
                     804   ; *
                     805   ; * Description: This function is called to get the address of the exception handler specified by 'vect'.
                     806   ; *              It is assumed that the VBR (Vector Base Register) is set to 0x00000000.
                     807   ; *
                     808   ; * Arguments  : vect     is the vector number
                     809   ; *
                     810   ; * Note(s)    : 1) Interrupts are disabled during this call
                     811   ; *              2) It is assumed that the VBR (Vector Base Register) is set to 0x00000000.
                     812   ; *********************************************************************************************************
                     813   ; */
                     814   ; void *OSVectGet(INT8U vect)
                     815   ; {
                     816   _OSVectGet:
00000678  4E56 FFFC  817          link      A6,#-4
                     818   ; void *addr;
                     819   ; OS_ENTER_CRITICAL();
0000067C  40E7       820          dc.w      16615
0000067E  007C       821          dc.w      124
00000680  0700       822          dc.w      1792
                     823   ; addr = (void *)(*(INT32U *)((INT16U)vect * 4));
00000682  102E 000B  824          move.b    11(A6),D0
00000686  C07C 00FF  825          and.w     #255,D0
0000068A  C0FC 0004  826          mulu.w    #4,D0
0000068E  C0BC 0000  827          and.l     #65535,D0
00000692  FFFF      
00000694  2040       828          move.l    D0,A0
00000696  2D50 FFFC  829          move.l    (A0),-4(A6)
                     830   ; OS_EXIT_CRITICAL();
0000069A  46DF       831          dc.w      18143
                     832   ; return (addr);
0000069C  202E FFFC  833          move.l    -4(A6),D0
000006A0  4E5E       834          unlk      A6
000006A2  4E75       835          rts
                     836   ; }
                     837   ; /*
                     838   ; *********************************************************************************************************
                     839   ; *                                             SET ISR VECTOR
                     840   ; *
                     841   ; * Description: This function is called to set the contents of an exception vector.  The function assumes
                     842   ; *              that the VBR (Vector Base Register) is set to 0x00000000.
                     843   ; *
                     844   ; * Arguments  : vect     is the vector number
                     845   ; *              addr     is the address of the ISR handler
                     846   ; *
                     847   ; * Note(s)    : 1) Interrupts are disabled during this call
                     848   ; *********************************************************************************************************
                     849   ; */
                     850   ; void OSVectSet(INT8U vect, void (*addr)(void))
                     851   ; {
                     852   _OSVectSet:
000006A4  4E56 FFFC  853          link      A6,#-4
                     854   ; INT32U *pvect;
                     855   ; pvect = (INT32U *)((INT16U)vect * 4);
000006A8  102E 000B  856          move.b    11(A6),D0
000006AC  C07C 00FF  857          and.w     #255,D0
000006B0  C0FC 0004  858          mulu.w    #4,D0
000006B4  C0BC 0000  859          and.l     #65535,D0
000006B8  FFFF      
000006BA  2D40 FFFC  860          move.l    D0,-4(A6)
                     861   ; OS_ENTER_CRITICAL();
000006BE  40E7       862          dc.w      16615
000006C0  007C       863          dc.w      124
000006C2  0700       864          dc.w      1792
                     865   ; *pvect = (INT32U)addr;
000006C4  206E FFFC  866          move.l    -4(A6),A0
000006C8  20AE 000C  867          move.l    12(A6),(A0)
                     868   ; OS_EXIT_CRITICAL();
000006CC  46DF       869          dc.w      18143
000006CE  4E5E       870          unlk      A6
000006D0  4E75       871          rts
                     872   ; }
                     873   ; /*$PAGE*/
                     874   ; #if OS_CPU_HOOKS_EN
                     875   ; /*
                     876   ; *********************************************************************************************************
                     877   ; *                                       OS INITIALIZATION HOOK
                     878   ; *                                            (BEGINNING)
                     879   ; *
                     880   ; * Description: This function is called by OSInit() at the beginning of OSInit().
                     881   ; *
                     882   ; * Arguments  : none
                     883   ; *
                     884   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                     885   ; *********************************************************************************************************
                     886   ; */
                     887   ; void OSInitHookBegin(void)
                     888   ; {
                     889   _OSInitHookBegin:
000006D2  4E75       890          rts
                     891   ; }
                     892   ; /*
                     893   ; *********************************************************************************************************
                     894   ; *                                       OS INITIALIZATION HOOK
                     895   ; *                                               (END)
                     896   ; *
                     897   ; * Description: This function is called by OSInit() at the end of OSInit().
                     898   ; *
                     899   ; * Arguments  : none
                     900   ; *
                     901   ; * Note(s)    : 1) Interrupts should be disabled during this call.
                     902   ; *********************************************************************************************************
                     903   ; */
                     904   ; void OSInitHookEnd(void)
                     905   ; {
                     906   _OSInitHookEnd:
                     907   ; #if OS_TMR_EN > 0
                     908   ; OSTmrTickCtr = 0;
000006D4  4239 0080  909          clr.b     _OSTmrTickCtr.L
000006D8  0014      
000006DA  4E75       910          rts
                     911   ; #endif
                     912   ; }
                     913   ; /*
                     914   ; *********************************************************************************************************
                     915   ; *                                          TASK CREATION HOOK
                     916   ; *
                     917   ; * Description: This function is called when a task is created.
                     918   ; *
                     919   ; * Arguments  : ptcb   is a pointer to the task control block of the task being created.
                     920   ; *
                     921   ; * Note(s)    : 1) Interrupts are disabled during this call.
                     922   ; *********************************************************************************************************
                     923   ; */
                     924   ; void OSTaskCreateHook(OS_TCB *ptcb)
                     925   ; {
                     926   _OSTaskCreateHook:
000006DC  4E56 0000  927          link      A6,#0
                     928   ; ptcb = ptcb;                       /* Prevent compiler warning                                     */
000006E0  4E5E       929          unlk      A6
000006E2  4E75       930          rts
                     931   ; }
                     932   ; /*
                     933   ; *********************************************************************************************************
                     934   ; *                                           TASK DELETION HOOK
                     935   ; *
                     936   ; * Description: This function is called when a task is deleted.
                     937   ; *
                     938   ; * Arguments  : ptcb   is a pointer to the task control block of the task being deleted.
                     939   ; *
                     940   ; * Note(s)    : 1) Interrupts are disabled during this call.
                     941   ; *********************************************************************************************************
                     942   ; */
                     943   ; void OSTaskDelHook(OS_TCB *ptcb)
                     944   ; {
                     945   _OSTaskDelHook:
000006E4  4E56 0000  946          link      A6,#0
                     947   ; ptcb = ptcb;                       /* Prevent compiler warning                                     */
000006E8  4E5E       948          unlk      A6
000006EA  4E75       949          rts
                     950   ; }
                     951   ; /*
                     952   ; *********************************************************************************************************
                     953   ; *                                           TASK SWITCH HOOK
                     954   ; *
                     955   ; * Description: This function is called when a task switch is performed.  This allows you to perform other
                     956   ; *              operations during a context switch.
                     957   ; *
                     958   ; * Arguments  : none
                     959   ; *
                     960   ; * Note(s)    : 1) Interrupts are disabled during this call.
                     961   ; *              2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
                     962   ; *                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
                     963   ; *                 task being switched out (i.e. the preempted task).
                     964   ; *********************************************************************************************************
                     965   ; */
                     966   ; void OSTaskSwHook(void)
                     967   ; {
                     968   _OSTaskSwHook:
000006EC  4E75       969          rts
                     970   ; }
                     971   ; /*
                     972   ; *********************************************************************************************************
                     973   ; *                                           TASK IDLE HOOK
                     974   ; *
                     975   ; * Description: This function is called when a idle task is performed.  This allows you to perform other
                     976   ; *              operations during the idle task.
                     977   ; *
                     978   ; * Arguments  : none
                     979   ; *
                     980   ; * Note(s)    : none
                     981   ; *********************************************************************************************************
                     982   ; */
                     983   ; void OSTaskIdleHook(void)
                     984   ; {
                     985   _OSTaskIdleHook:
000006EE  4E75       986          rts
                     987   ; }
                     988   ; /*
                     989   ; *********************************************************************************************************
                     990   ; *                                           TASK RETURN HOOK
                     991   ; *
                     992   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                     993   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                     994   ; *
                     995   ; * Arguments  : Pointer to currently running TCB
                     996   ; *
                     997   ; * Note(s)    : none
                     998   ; *********************************************************************************************************
                     999   ; */
                    1000   ; void OSTaskReturnHook(OS_TCB *ptcb)
                    1001   ; {
                    1002   _OSTaskReturnHook:
000006F0  4E56 0000 1003          link      A6,#0
                    1004   ; ptcb = ptcb;                       /* Prevent compiler warning                                     */
000006F4  4E5E      1005          unlk      A6
000006F6  4E75      1006          rts
                    1007   ; }
                    1008   ; /*
                    1009   ; *********************************************************************************************************
                    1010   ; *                                           STATISTIC TASK HOOK
                    1011   ; *
                    1012   ; * Description: This function is called every second by uC/OS-II's statistics task.  This allows your
                    1013   ; *              application to add functionality to the statistics task.
                    1014   ; *
                    1015   ; * Arguments  : none
                    1016   ; *********************************************************************************************************
                    1017   ; */
                    1018   ; void OSTaskStatHook(void)
                    1019   ; {
                    1020   _OSTaskStatHook:
000006F8  4E75      1021          rts
                    1022   ; }
                    1023   ; /*
                    1024   ; *********************************************************************************************************
                    1025   ; *                                               TICK HOOK
                    1026   ; *
                    1027   ; * Description: This function is called every tick.
                    1028   ; *
                    1029   ; * Arguments  : none
                    1030   ; *
                    1031   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1032   ; *********************************************************************************************************
                    1033   ; */
                    1034   ; void OSTimeTickHook(void)
                    1035   ; {
                    1036   _OSTimeTickHook:
                    1037   ; #if OS_TMR_EN > 0
                    1038   ; if (OSTmrUsed > 0 && ++OSTmrTickCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
000006FA  3039 0080 1039          move.w    _OSTmrUsed.L,D0
000006FE  0CBC      
00000700  0C40 0000 1040          cmp.w     #0,D0
00000704  631E      1041          bls.s     OSTimeTickHook_1
00000706  5239 0080 1042          addq.b    #1,_OSTmrTickCtr.L
0000070A  0014      
0000070C  1039 0080 1043          move.b    _OSTmrTickCtr.L,D0
00000710  0014      
00000712  0C00 000A 1044          cmp.b     #10,D0
00000716  650C      1045          blo.s     OSTimeTickHook_1
                    1046   ; OSTmrTickCtr = 0;
00000718  4239 0080 1047          clr.b     _OSTmrTickCtr.L
0000071C  0014      
                    1048   ; OSTmrSignal();
0000071E  4EB9 0000 1049          jsr       _OSTmrSignal
00000722  53C4      
                    1050   OSTimeTickHook_1:
00000724  4E75      1051          rts
                    1052   ; }
                    1053   ; #endif
                    1054   ; }
                    1055   ; /*
                    1056   ; *********************************************************************************************************
                    1057   ; *                                           OSTCBInit() HOOK
                    1058   ; *
                    1059   ; * Description: This function is called by OSTCBInit() after setting up most of the TCB.
                    1060   ; *
                    1061   ; * Arguments  : ptcb    is a pointer to the TCB of the task being created.
                    1062   ; *
                    1063   ; * Note(s)    : 1) Interrupts may or may not be ENABLED during this call.
                    1064   ; *********************************************************************************************************
                    1065   ; */
                    1066   ; #if OS_VERSION > 203
                    1067   ; void OSTCBInitHook (OS_TCB *ptcb)
                    1068   ; {
                    1069   _OSTCBInitHook:
00000726  4E56 0000 1070          link      A6,#0
                    1071   ; ptcb = ptcb;                                           /* Prevent compiler warning                 */
0000072A  4E5E      1072          unlk      A6
0000072C  4E75      1073          rts
                    1074   ; }
                    1075   ; #endif
                    1076   ; #endif // OS_CPU_HOOKS_EN
                    1077   ; C:\IDE68K\EM-LAB\UCOS_II.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1078   ; /*
                    1079   ; *********************************************************************************************************
                    1080   ; *                                                uC/OS-II
                    1081   ; *                                          The Real-Time Kernel
                    1082   ; *                                             CORE FUNCTIONS
                    1083   ; *
                    1084   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    1085   ; *                                           All Rights Reserved
                    1086   ; *
                    1087   ; * File    : OS_CORE.C
                    1088   ; * By      : Jean J. Labrosse
                    1089   ; * Version : V2.92.07
                    1090   ; *
                    1091   ; * LICENSING TERMS:
                    1092   ; * ---------------
                    1093   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    1094   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    1095   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    1096   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    1097   ; * licensing fee.
                    1098   ; *********************************************************************************************************
                    1099   ; */
                    1100   ; #define  MICRIUM_SOURCE
                    1101   ; #ifndef  OS_MASTER_FILE
                    1102   ; #define  OS_GLOBALS
                    1103   ; #include <ucos_ii.h>
                    1104   ; #endif
                    1105   ; /*
                    1106   ; *********************************************************************************************************
                    1107   ; *                                      PRIORITY RESOLUTION TABLE
                    1108   ; *
                    1109   ; * Note: Index into table is bit pattern to resolve highest priority
                    1110   ; *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
                    1111   ; *********************************************************************************************************
                    1112   ; */
                    1113   ; INT8U  const  OSUnMapTbl[256] = {
                    1114   ; 0u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x00 to 0x0F                   */
                    1115   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x10 to 0x1F                   */
                    1116   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x20 to 0x2F                   */
                    1117   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x30 to 0x3F                   */
                    1118   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x40 to 0x4F                   */
                    1119   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x50 to 0x5F                   */
                    1120   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x60 to 0x6F                   */
                    1121   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x70 to 0x7F                   */
                    1122   ; 7u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x80 to 0x8F                   */
                    1123   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0x90 to 0x9F                   */
                    1124   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xA0 to 0xAF                   */
                    1125   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xB0 to 0xBF                   */
                    1126   ; 6u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xC0 to 0xCF                   */
                    1127   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xD0 to 0xDF                   */
                    1128   ; 5u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, /* 0xE0 to 0xEF                   */
                    1129   ; 4u, 0u, 1u, 0u, 2u, 0u, 1u, 0u, 3u, 0u, 1u, 0u, 2u, 0u, 1u, 0u  /* 0xF0 to 0xFF                   */
                    1130   ; };
                    1131   ; /*$PAGE*/
                    1132   ; /*
                    1133   ; *********************************************************************************************************
                    1134   ; *                                         FUNCTION PROTOTYPES
                    1135   ; *********************************************************************************************************
                    1136   ; */
                    1137   ; static  void  OS_InitEventList(void);
                    1138   ; static  void  OS_InitMisc(void);
                    1139   ; static  void  OS_InitRdyList(void);
                    1140   ; static  void  OS_InitTaskIdle(void);
                    1141   ; #if OS_TASK_STAT_EN > 0u
                    1142   ; static  void  OS_InitTaskStat(void);
                    1143   ; #endif
                    1144   ; static  void  OS_InitTCBList(void);
                    1145   ; static  void  OS_SchedNew(void);
                    1146   ; /*$PAGE*/
                    1147   ; /*
                    1148   ; *********************************************************************************************************
                    1149   ; *                        GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1150   ; *
                    1151   ; * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
                    1152   ; *
                    1153   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1154   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
                    1155   ; *                        type is irrelevant.
                    1156   ; *
                    1157   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the semaphore,
                    1158   ; *                        mutex, mailbox or queue.
                    1159   ; *
                    1160   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1161   ; *
                    1162   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    1163   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1164   ; *                                                   control block type.
                    1165   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1166   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1167   ; *                        OS_ERR_NAME_GET_ISR        if you are trying to call this function from an ISR
                    1168   ; *
                    1169   ; * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
                    1170   ; *********************************************************************************************************
                    1171   ; */
                    1172   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1173   ; INT8U  OSEventNameGet (OS_EVENT   *pevent,
                    1174   ; INT8U     **pname,
                    1175   ; INT8U      *perr)
                    1176   ; {
                    1177   _OSEventNameGet:
0000072E  4E56 FFFC 1178          link      A6,#-4
00000732  2F02      1179          move.l    D2,-(A7)
00000734  242E 0010 1180          move.l    16(A6),D2
                    1181   ; INT8U      len;
                    1182   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1183   ; OS_CPU_SR  cpu_sr = 0u;
                    1184   ; #endif
                    1185   ; #ifdef OS_SAFETY_CRITICAL
                    1186   ; if (perr == (INT8U *)0) {
                    1187   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1188   ; return (0u);
                    1189   ; }
                    1190   ; #endif
                    1191   ; #if OS_ARG_CHK_EN > 0u
                    1192   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1193   ; *perr = OS_ERR_PEVENT_NULL;
                    1194   ; return (0u);
                    1195   ; }
                    1196   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1197   ; *perr = OS_ERR_PNAME_NULL;
                    1198   ; return (0u);
                    1199   ; }
                    1200   ; #endif
                    1201   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000738  1039 0080 1202          move.b    _OSIntNesting.L,D0
0000073C  0246      
0000073E  0C00 0000 1203          cmp.b     #0,D0
00000742  630C      1204          bls.s     OSEventNameGet_1
                    1205   ; *perr  = OS_ERR_NAME_GET_ISR;
00000744  2042      1206          move.l    D2,A0
00000746  10BC 0011 1207          move.b    #17,(A0)
                    1208   ; return (0u);
0000074A  4200      1209          clr.b     D0
0000074C  6000 0066 1210          bra       OSEventNameGet_3
                    1211   OSEventNameGet_1:
                    1212   ; }
                    1213   ; switch (pevent->OSEventType) {
00000750  206E 0008 1214          move.l    8(A6),A0
00000754  1010      1215          move.b    (A0),D0
00000756  C0BC 0000 1216          and.l     #255,D0
0000075A  00FF      
0000075C  5380      1217          subq.l    #1,D0
0000075E  651C      1218          blo.s     OSEventNameGet_4
00000760  0C80 0000 1219          cmp.l     #4,D0
00000764  0004      
00000766  6414      1220          bhs.s     OSEventNameGet_4
00000768  E380      1221          asl.l     #1,D0
0000076A  303B 0806 1222          move.w    OSEventNameGet_6(PC,D0.L),D0
0000076E  4EFB 0002 1223          jmp       OSEventNameGet_6(PC,D0.W)
                    1224   OSEventNameGet_6:
00000772  0008      1225          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000774  0008      1226          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000776  0008      1227          dc.w      OSEventNameGet_7-OSEventNameGet_6
00000778  0008      1228          dc.w      OSEventNameGet_7-OSEventNameGet_6
                    1229   OSEventNameGet_7:
                    1230   ; case OS_EVENT_TYPE_SEM:
                    1231   ; case OS_EVENT_TYPE_MUTEX:
                    1232   ; case OS_EVENT_TYPE_MBOX:
                    1233   ; case OS_EVENT_TYPE_Q:
                    1234   ; break;
0000077A  600A      1235          bra.s     OSEventNameGet_5
                    1236   OSEventNameGet_4:
                    1237   ; default:
                    1238   ; *perr = OS_ERR_EVENT_TYPE;
0000077C  2042      1239          move.l    D2,A0
0000077E  10BC 0001 1240          move.b    #1,(A0)
                    1241   ; return (0u);
00000782  4200      1242          clr.b     D0
00000784  602E      1243          bra.s     OSEventNameGet_3
                    1244   OSEventNameGet_5:
                    1245   ; }
                    1246   ; OS_ENTER_CRITICAL();
00000786  40E7      1247          dc.w      16615
00000788  007C      1248          dc.w      124
0000078A  0700      1249          dc.w      1792
                    1250   ; *pname = pevent->OSEventName;
0000078C  206E 0008 1251          move.l    8(A6),A0
00000790  226E 000C 1252          move.l    12(A6),A1
00000794  22A8 0012 1253          move.l    18(A0),(A1)
                    1254   ; len    = OS_StrLen(*pname);
00000798  206E 000C 1255          move.l    12(A6),A0
0000079C  2F10      1256          move.l    (A0),-(A7)
0000079E  4EB9 0000 1257          jsr       _OS_StrLen
000007A2  14A2      
000007A4  584F      1258          addq.w    #4,A7
000007A6  1D40 FFFF 1259          move.b    D0,-1(A6)
                    1260   ; OS_EXIT_CRITICAL();
000007AA  46DF      1261          dc.w      18143
                    1262   ; *perr  = OS_ERR_NONE;
000007AC  2042      1263          move.l    D2,A0
000007AE  4210      1264          clr.b     (A0)
                    1265   ; return (len);
000007B0  102E FFFF 1266          move.b    -1(A6),D0
                    1267   OSEventNameGet_3:
000007B4  241F      1268          move.l    (A7)+,D2
000007B6  4E5E      1269          unlk      A6
000007B8  4E75      1270          rts
                    1271   ; }
                    1272   ; #endif
                    1273   ; /*$PAGE*/
                    1274   ; /*
                    1275   ; *********************************************************************************************************
                    1276   ; *                        ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
                    1277   ; *
                    1278   ; * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
                    1279   ; *
                    1280   ; * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
                    1281   ; *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
                    1282   ; *                        matter the actual type.
                    1283   ; *
                    1284   ; *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
                    1285   ; *                        mutex, mailbox or queue.
                    1286   ; *
                    1287   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    1288   ; *
                    1289   ; *                        OS_ERR_NONE                if the requested task is resumed
                    1290   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
                    1291   ; *                                                   control block type.
                    1292   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    1293   ; *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
                    1294   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    1295   ; *
                    1296   ; * Returns    : None
                    1297   ; *********************************************************************************************************
                    1298   ; */
                    1299   ; #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
                    1300   ; void  OSEventNameSet (OS_EVENT  *pevent,
                    1301   ; INT8U     *pname,
                    1302   ; INT8U     *perr)
                    1303   ; {
                    1304   _OSEventNameSet:
000007BA  4E56 0000 1305          link      A6,#0
000007BE  2F02      1306          move.l    D2,-(A7)
000007C0  242E 0010 1307          move.l    16(A6),D2
                    1308   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    1309   ; OS_CPU_SR  cpu_sr = 0u;
                    1310   ; #endif
                    1311   ; #ifdef OS_SAFETY_CRITICAL
                    1312   ; if (perr == (INT8U *)0) {
                    1313   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1314   ; return;
                    1315   ; }
                    1316   ; #endif
                    1317   ; #if OS_ARG_CHK_EN > 0u
                    1318   ; if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
                    1319   ; *perr = OS_ERR_PEVENT_NULL;
                    1320   ; return;
                    1321   ; }
                    1322   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    1323   ; *perr = OS_ERR_PNAME_NULL;
                    1324   ; return;
                    1325   ; }
                    1326   ; #endif
                    1327   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000007C4  1039 0080 1328          move.b    _OSIntNesting.L,D0
000007C8  0246      
000007CA  0C00 0000 1329          cmp.b     #0,D0
000007CE  630A      1330          bls.s     OSEventNameSet_1
                    1331   ; *perr = OS_ERR_NAME_SET_ISR;
000007D0  2042      1332          move.l    D2,A0
000007D2  10BC 0012 1333          move.b    #18,(A0)
                    1334   ; return;
000007D6  6000 004C 1335          bra       OSEventNameSet_3
                    1336   OSEventNameSet_1:
                    1337   ; }
                    1338   ; switch (pevent->OSEventType) {
000007DA  206E 0008 1339          move.l    8(A6),A0
000007DE  1010      1340          move.b    (A0),D0
000007E0  C0BC 0000 1341          and.l     #255,D0
000007E4  00FF      
000007E6  5380      1342          subq.l    #1,D0
000007E8  651C      1343          blo.s     OSEventNameSet_4
000007EA  0C80 0000 1344          cmp.l     #4,D0
000007EE  0004      
000007F0  6414      1345          bhs.s     OSEventNameSet_4
000007F2  E380      1346          asl.l     #1,D0
000007F4  303B 0806 1347          move.w    OSEventNameSet_6(PC,D0.L),D0
000007F8  4EFB 0002 1348          jmp       OSEventNameSet_6(PC,D0.W)
                    1349   OSEventNameSet_6:
000007FC  0008      1350          dc.w      OSEventNameSet_7-OSEventNameSet_6
000007FE  0008      1351          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000800  0008      1352          dc.w      OSEventNameSet_7-OSEventNameSet_6
00000802  0008      1353          dc.w      OSEventNameSet_7-OSEventNameSet_6
                    1354   OSEventNameSet_7:
                    1355   ; case OS_EVENT_TYPE_SEM:
                    1356   ; case OS_EVENT_TYPE_MUTEX:
                    1357   ; case OS_EVENT_TYPE_MBOX:
                    1358   ; case OS_EVENT_TYPE_Q:
                    1359   ; break;
00000804  6008      1360          bra.s     OSEventNameSet_5
                    1361   OSEventNameSet_4:
                    1362   ; default:
                    1363   ; *perr = OS_ERR_EVENT_TYPE;
00000806  2042      1364          move.l    D2,A0
00000808  10BC 0001 1365          move.b    #1,(A0)
                    1366   ; return;
0000080C  6016      1367          bra.s     OSEventNameSet_3
                    1368   OSEventNameSet_5:
                    1369   ; }
                    1370   ; OS_ENTER_CRITICAL();
0000080E  40E7      1371          dc.w      16615
00000810  007C      1372          dc.w      124
00000812  0700      1373          dc.w      1792
                    1374   ; pevent->OSEventName = pname;
00000814  206E 0008 1375          move.l    8(A6),A0
00000818  216E 000C 1376          move.l    12(A6),18(A0)
0000081C  0012      
                    1377   ; OS_EXIT_CRITICAL();
0000081E  46DF      1378          dc.w      18143
                    1379   ; *perr = OS_ERR_NONE;
00000820  2042      1380          move.l    D2,A0
00000822  4210      1381          clr.b     (A0)
                    1382   OSEventNameSet_3:
00000824  241F      1383          move.l    (A7)+,D2
00000826  4E5E      1384          unlk      A6
00000828  4E75      1385          rts
                    1386   ; }
                    1387   ; #endif
                    1388   ; /*$PAGE*/
                    1389   ; /*
                    1390   ; *********************************************************************************************************
                    1391   ; *                                       PEND ON MULTIPLE EVENTS
                    1392   ; *
                    1393   ; * Description: This function waits for multiple events.  If multiple events are ready at the start of the
                    1394   ; *              pend call, then all available events are returned as ready.  If the task must pend on the
                    1395   ; *              multiple events, then only the first posted or aborted event is returned as ready.
                    1396   ; *
                    1397   ; * Arguments  : pevents_pend  is a pointer to a NULL-terminated array of event control blocks to wait for.
                    1398   ; *
                    1399   ; *              pevents_rdy   is a pointer to an array to return which event control blocks are available
                    1400   ; *                            or ready.  The size of the array MUST be greater than or equal to the size
                    1401   ; *                            of the 'pevents_pend' array, including terminating NULL.
                    1402   ; *
                    1403   ; *              pmsgs_rdy     is a pointer to an array to return messages from any available message-type
                    1404   ; *                            events.  The size of the array MUST be greater than or equal to the size of
                    1405   ; *                            the 'pevents_pend' array, excluding the terminating NULL.  Since NULL
                    1406   ; *                            messages are valid messages, this array cannot be NULL-terminated.  Instead,
                    1407   ; *                            every available message-type event returns its messages in the 'pmsgs_rdy'
                    1408   ; *                            array at the same index as the event is returned in the 'pevents_rdy' array.
                    1409   ; *                            All other 'pmsgs_rdy' array indices are filled with NULL messages.
                    1410   ; *
                    1411   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    1412   ; *                            wait for the resources up to the amount of time specified by this argument.
                    1413   ; *                            If you specify 0, however, your task will wait forever for the specified
                    1414   ; *                            events or, until the resources becomes available (or the events occur).
                    1415   ; *
                    1416   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    1417   ; *                            messages are:
                    1418   ; *
                    1419   ; *                            OS_ERR_NONE         The call was successful and your task owns the resources
                    1420   ; *                                                or, the events you are waiting for occurred; check the
                    1421   ; *                                                'pevents_rdy' array for which events are available.
                    1422   ; *                            OS_ERR_PEND_ABORT   The wait on the events was aborted; check the
                    1423   ; *                                                'pevents_rdy' array for which events were aborted.
                    1424   ; *                            OS_ERR_TIMEOUT      The events were not received within the specified
                    1425   ; *                                                'timeout'.
                    1426   ; *                            OS_ERR_PEVENT_NULL  If 'pevents_pend', 'pevents_rdy', or 'pmsgs_rdy' is a
                    1427   ; *                                                NULL pointer.
                    1428   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to an array of semaphores,
                    1429   ; *                                                mailboxes, and/or queues.
                    1430   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    1431   ; *                                                would lead to a suspension.
                    1432   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked.
                    1433   ; *
                    1434   ; * Returns    : >  0          the number of events returned as ready or aborted.
                    1435   ; *              == 0          if no events are returned as ready because of timeout or upon error.
                    1436   ; *
                    1437   ; * Notes      : 1) a. Validate 'pevents_pend' array as valid OS_EVENTs :
                    1438   ; *
                    1439   ; *                        semaphores, mailboxes, queues
                    1440   ; *
                    1441   ; *                 b. Return ALL available events and messages, if any
                    1442   ; *
                    1443   ; *                 c. Add    current task priority as pending to   each events's wait list
                    1444   ; *                      Performed in OS_EventTaskWaitMulti()
                    1445   ; *
                    1446   ; *                 d. Wait on any of multiple events
                    1447   ; *
                    1448   ; *                 e. Remove current task priority as pending from each events's wait list
                    1449   ; *                      Performed in OS_EventTaskRdy(), if events posted or aborted
                    1450   ; *
                    1451   ; *                 f. Return any event posted or aborted, if any
                    1452   ; *                      else
                    1453   ; *                    Return timeout
                    1454   ; *
                    1455   ; *              2) 'pevents_rdy' initialized to NULL PRIOR to all other validation or function handling in
                    1456   ; *                 case of any error(s).
                    1457   ; *********************************************************************************************************
                    1458   ; */
                    1459   ; /*$PAGE*/
                    1460   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    1461   ; INT16U  OSEventPendMulti (OS_EVENT  **pevents_pend,
                    1462   ; OS_EVENT  **pevents_rdy,
                    1463   ; void      **pmsgs_rdy,
                    1464   ; INT32U      timeout,
                    1465   ; INT8U      *perr)
                    1466   ; {
                    1467   _OSEventPendMulti:
0000082A  4E56 FFFC 1468          link      A6,#-4
0000082E  48E7 3F38 1469          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
00000832  45F9 0080 1470          lea       _OSTCBCur.L,A2
00000836  0360      
00000838  282E 0018 1471          move.l    24(A6),D4
0000083C  2A2E 000C 1472          move.l    12(A6),D5
00000840  266E 0010 1473          move.l    16(A6),A3
00000844  286E 0008 1474          move.l    8(A6),A4
                    1475   ; OS_EVENT  **pevents;
                    1476   ; OS_EVENT   *pevent;
                    1477   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    1478   ; OS_Q       *pq;
                    1479   ; #endif
                    1480   ; BOOLEAN     events_rdy;
                    1481   ; INT16U      events_rdy_nbr;
                    1482   ; INT8U       events_stat;
                    1483   ; #if (OS_CRITICAL_METHOD == 3u)                          /* Allocate storage for CPU status register    */
                    1484   ; OS_CPU_SR   cpu_sr = 0u;
                    1485   ; #endif
                    1486   ; #ifdef OS_SAFETY_CRITICAL
                    1487   ; if (perr == (INT8U *)0) {
                    1488   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    1489   ; return (0u);
                    1490   ; }
                    1491   ; #endif
                    1492   ; #if (OS_ARG_CHK_EN > 0u)
                    1493   ; if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
                    1494   ; *perr =  OS_ERR_PEVENT_NULL;
                    1495   ; return (0u);
                    1496   ; }
                    1497   ; if (*pevents_pend  == (OS_EVENT *)0) {              /* Validate 'pevents_pend'                     */
                    1498   ; *perr =  OS_ERR_PEVENT_NULL;
                    1499   ; return (0u);
                    1500   ; }
                    1501   ; if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
                    1502   ; *perr =  OS_ERR_PEVENT_NULL;
                    1503   ; return (0u);
                    1504   ; }
                    1505   ; if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
                    1506   ; *perr =  OS_ERR_PEVENT_NULL;
                    1507   ; return (0u);
                    1508   ; }
                    1509   ; #endif
                    1510   ; *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
00000848  2045      1511          move.l    D5,A0
0000084A  4290      1512          clr.l     (A0)
                    1513   ; pevents     =  pevents_pend;
0000084C  2E0C      1514          move.l    A4,D7
                    1515   ; pevent      = *pevents;
0000084E  2047      1516          move.l    D7,A0
00000850  2410      1517          move.l    (A0),D2
                    1518   ; while  (pevent != (OS_EVENT *)0) {
                    1519   OSEventPendMulti_1:
00000852  4A82      1520          tst.l     D2
00000854  6700 0046 1521          beq       OSEventPendMulti_3
                    1522   ; switch (pevent->OSEventType) {                  /* Validate event block types                  */
00000858  2042      1523          move.l    D2,A0
0000085A  1010      1524          move.b    (A0),D0
0000085C  C0BC 0000 1525          and.l     #255,D0
00000860  00FF      
00000862  5380      1526          subq.l    #1,D0
00000864  6522      1527          blo.s     OSEventPendMulti_10
00000866  0C80 0000 1528          cmp.l     #5,D0
0000086A  0005      
0000086C  641A      1529          bhs.s     OSEventPendMulti_10
0000086E  E380      1530          asl.l     #1,D0
00000870  303B 0806 1531          move.w    OSEventPendMulti_6(PC,D0.L),D0
00000874  4EFB 0002 1532          jmp       OSEventPendMulti_6(PC,D0.W)
                    1533   OSEventPendMulti_6:
00000878  000C      1534          dc.w      OSEventPendMulti_8-OSEventPendMulti_6
0000087A  000E      1535          dc.w      OSEventPendMulti_9-OSEventPendMulti_6
0000087C  000A      1536          dc.w      OSEventPendMulti_7-OSEventPendMulti_6
0000087E  0010      1537          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
00000880  0010      1538          dc.w      OSEventPendMulti_10-OSEventPendMulti_6
                    1539   OSEventPendMulti_7:
                    1540   ; #if (OS_SEM_EN  > 0u)
                    1541   ; case OS_EVENT_TYPE_SEM:
                    1542   ; break;
00000882  6010      1543          bra.s     OSEventPendMulti_5
                    1544   OSEventPendMulti_8:
                    1545   ; #endif
                    1546   ; #if (OS_MBOX_EN > 0u)
                    1547   ; case OS_EVENT_TYPE_MBOX:
                    1548   ; break;
00000884  600E      1549          bra.s     OSEventPendMulti_5
                    1550   OSEventPendMulti_9:
                    1551   ; #endif
                    1552   ; #if ((OS_Q_EN   > 0u) && (OS_MAX_QS > 0u))
                    1553   ; case OS_EVENT_TYPE_Q:
                    1554   ; break;
00000886  600C      1555          bra.s     OSEventPendMulti_5
                    1556   OSEventPendMulti_10:
                    1557   ; #endif
                    1558   ; case OS_EVENT_TYPE_MUTEX:
                    1559   ; case OS_EVENT_TYPE_FLAG:
                    1560   ; default:
                    1561   ; *perr = OS_ERR_EVENT_TYPE;
00000888  2044      1562          move.l    D4,A0
0000088A  10BC 0001 1563          move.b    #1,(A0)
                    1564   ; return (0u);
0000088E  4240      1565          clr.w     D0
00000890  6000 02C2 1566          bra       OSEventPendMulti_13
                    1567   OSEventPendMulti_5:
                    1568   ; }
                    1569   ; pevents++;
00000894  5887      1570          addq.l    #4,D7
                    1571   ; pevent = *pevents;
00000896  2047      1572          move.l    D7,A0
00000898  2410      1573          move.l    (A0),D2
0000089A  60B6      1574          bra       OSEventPendMulti_1
                    1575   OSEventPendMulti_3:
                    1576   ; }
                    1577   ; if (OSIntNesting  > 0u) {                           /* See if called from ISR ...                  */
0000089C  1039 0080 1578          move.b    _OSIntNesting.L,D0
000008A0  0246      
000008A2  0C00 0000 1579          cmp.b     #0,D0
000008A6  630C      1580          bls.s     OSEventPendMulti_14
                    1581   ; *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
000008A8  2044      1582          move.l    D4,A0
000008AA  10BC 0002 1583          move.b    #2,(A0)
                    1584   ; return (0u);
000008AE  4240      1585          clr.w     D0
000008B0  6000 02A2 1586          bra       OSEventPendMulti_13
                    1587   OSEventPendMulti_14:
                    1588   ; }
                    1589   ; if (OSLockNesting > 0u) {                           /* See if called with scheduler locked ...     */
000008B4  1039 0080 1590          move.b    _OSLockNesting.L,D0
000008B8  0248      
000008BA  0C00 0000 1591          cmp.b     #0,D0
000008BE  630C      1592          bls.s     OSEventPendMulti_16
                    1593   ; *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
000008C0  2044      1594          move.l    D4,A0
000008C2  10BC 000D 1595          move.b    #13,(A0)
                    1596   ; return (0u);
000008C6  4240      1597          clr.w     D0
000008C8  6000 028A 1598          bra       OSEventPendMulti_13
                    1599   OSEventPendMulti_16:
                    1600   ; }
                    1601   ; /*$PAGE*/
                    1602   ; events_rdy     =  OS_FALSE;
000008CC  422E FFFE 1603          clr.b     -2(A6)
                    1604   ; events_rdy_nbr =  0u;
000008D0  4243      1605          clr.w     D3
                    1606   ; events_stat    =  OS_STAT_RDY;
000008D2  422E FFFF 1607          clr.b     -1(A6)
                    1608   ; pevents        =  pevents_pend;
000008D6  2E0C      1609          move.l    A4,D7
                    1610   ; pevent         = *pevents;
000008D8  2047      1611          move.l    D7,A0
000008DA  2410      1612          move.l    (A0),D2
                    1613   ; OS_ENTER_CRITICAL();
000008DC  40E7      1614          dc.w      16615
000008DE  007C      1615          dc.w      124
000008E0  0700      1616          dc.w      1792
                    1617   ; while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
                    1618   OSEventPendMulti_18:
000008E2  4A82      1619          tst.l     D2
000008E4  6700 010A 1620          beq       OSEventPendMulti_20
                    1621   ; switch (pevent->OSEventType) {
000008E8  2042      1622          move.l    D2,A0
000008EA  1010      1623          move.b    (A0),D0
000008EC  C0BC 0000 1624          and.l     #255,D0
000008F0  00FF      
000008F2  5380      1625          subq.l    #1,D0
000008F4  6500 00DE 1626          blo       OSEventPendMulti_27
000008F8  0C80 0000 1627          cmp.l     #5,D0
000008FC  0005      
000008FE  6400 00D4 1628          bhs       OSEventPendMulti_27
00000902  E380      1629          asl.l     #1,D0
00000904  303B 0806 1630          move.w    OSEventPendMulti_23(PC,D0.L),D0
00000908  4EFB 0002 1631          jmp       OSEventPendMulti_23(PC,D0.W)
                    1632   OSEventPendMulti_23:
0000090C  003A      1633          dc.w      OSEventPendMulti_25-OSEventPendMulti_23
0000090E  0068      1634          dc.w      OSEventPendMulti_26-OSEventPendMulti_23
00000910  000A      1635          dc.w      OSEventPendMulti_24-OSEventPendMulti_23
00000912  00C8      1636          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
00000914  00C8      1637          dc.w      OSEventPendMulti_27-OSEventPendMulti_23
                    1638   OSEventPendMulti_24:
                    1639   ; #if (OS_SEM_EN > 0u)
                    1640   ; case OS_EVENT_TYPE_SEM:
                    1641   ; if (pevent->OSEventCnt > 0u) {         /* If semaphore count > 0, resource available; */
00000916  2042      1642          move.l    D2,A0
00000918  3028 0006 1643          move.w    6(A0),D0
0000091C  0C40 0000 1644          cmp.w     #0,D0
00000920  631A      1645          bls.s     OSEventPendMulti_30
                    1646   ; pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
00000922  2002      1647          move.l    D2,D0
00000924  5C80      1648          addq.l    #6,D0
00000926  2040      1649          move.l    D0,A0
00000928  5350      1650          subq.w    #1,(A0)
                    1651   ; *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
0000092A  2045      1652          move.l    D5,A0
0000092C  5885      1653          addq.l    #4,D5
0000092E  2082      1654          move.l    D2,(A0)
                    1655   ; events_rdy   =  OS_TRUE;
00000930  1D7C 0001 1656          move.b    #1,-2(A6)
00000934  FFFE      
                    1657   ; *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
00000936  429B      1658          clr.l     (A3)+
                    1659   ; events_rdy_nbr++;
00000938  5243      1660          addq.w    #1,D3
0000093A  6006      1661          bra.s     OSEventPendMulti_31
                    1662   OSEventPendMulti_30:
                    1663   ; } else {
                    1664   ; events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
0000093C  002E 0001 1665          or.b      #1,-1(A6)
00000940  FFFF      
                    1666   OSEventPendMulti_31:
                    1667   ; }
                    1668   ; break;
00000942  6000 00A2 1669          bra       OSEventPendMulti_22
                    1670   OSEventPendMulti_25:
                    1671   ; #endif
                    1672   ; #if (OS_MBOX_EN > 0u)
                    1673   ; case OS_EVENT_TYPE_MBOX:
                    1674   ; if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
00000946  2042      1675          move.l    D2,A0
00000948  2028 0002 1676          move.l    2(A0),D0
0000094C  671C      1677          beq.s     OSEventPendMulti_32
                    1678   ; /* ... return available message,           ... */
                    1679   ; *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
0000094E  2042      1680          move.l    D2,A0
00000950  26E8 0002 1681          move.l    2(A0),(A3)+
                    1682   ; pevent->OSEventPtr  = (void *)0;
00000954  2042      1683          move.l    D2,A0
00000956  42A8 0002 1684          clr.l     2(A0)
                    1685   ; *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
0000095A  2045      1686          move.l    D5,A0
0000095C  5885      1687          addq.l    #4,D5
0000095E  2082      1688          move.l    D2,(A0)
                    1689   ; events_rdy         =  OS_TRUE;
00000960  1D7C 0001 1690          move.b    #1,-2(A6)
00000964  FFFE      
                    1691   ; events_rdy_nbr++;
00000966  5243      1692          addq.w    #1,D3
00000968  6006      1693          bra.s     OSEventPendMulti_33
                    1694   OSEventPendMulti_32:
                    1695   ; } else {
                    1696   ; events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
0000096A  002E 0002 1697          or.b      #2,-1(A6)
0000096E  FFFF      
                    1698   OSEventPendMulti_33:
                    1699   ; }
                    1700   ; break;
00000970  6000 0074 1701          bra       OSEventPendMulti_22
                    1702   OSEventPendMulti_26:
                    1703   ; #endif
                    1704   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    1705   ; case OS_EVENT_TYPE_Q:
                    1706   ; pq = (OS_Q *)pevent->OSEventPtr;
00000974  2042      1707          move.l    D2,A0
00000976  2C28 0002 1708          move.l    2(A0),D6
                    1709   ; if (pq->OSQEntries > 0u) {             /* If queue NOT empty;                     ... */
0000097A  2046      1710          move.l    D6,A0
0000097C  3028 0016 1711          move.w    22(A0),D0
00000980  0C40 0000 1712          cmp.w     #0,D0
00000984  6300 0046 1713          bls       OSEventPendMulti_34
                    1714   ; /* ... return available message,           ... */
                    1715   ; *pmsgs_rdy++ = (void *)*pq->OSQOut++;
00000988  2006      1716          move.l    D6,D0
0000098A  0680 0000 1717          add.l     #16,D0
0000098E  0010      
00000990  2040      1718          move.l    D0,A0
00000992  2250      1719          move.l    (A0),A1
00000994  5890      1720          addq.l    #4,(A0)
00000996  26D1      1721          move.l    (A1),(A3)+
                    1722   ; if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
00000998  2046      1723          move.l    D6,A0
0000099A  2246      1724          move.l    D6,A1
0000099C  2028 0010 1725          move.l    16(A0),D0
000009A0  B0A9 0008 1726          cmp.l     8(A1),D0
000009A4  660A      1727          bne.s     OSEventPendMulti_36
                    1728   ; pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
000009A6  2046      1729          move.l    D6,A0
000009A8  2246      1730          move.l    D6,A1
000009AA  2368 0004 1731          move.l    4(A0),16(A1)
000009AE  0010      
                    1732   OSEventPendMulti_36:
                    1733   ; }
                    1734   ; pq->OSQEntries--;                  /* Update number of queue entries              */
000009B0  2006      1735          move.l    D6,D0
000009B2  0680 0000 1736          add.l     #22,D0
000009B6  0016      
000009B8  2040      1737          move.l    D0,A0
000009BA  5350      1738          subq.w    #1,(A0)
                    1739   ; *pevents_rdy++ = pevent;            /* ... and return available queue event        */
000009BC  2045      1740          move.l    D5,A0
000009BE  5885      1741          addq.l    #4,D5
000009C0  2082      1742          move.l    D2,(A0)
                    1743   ; events_rdy   = OS_TRUE;
000009C2  1D7C 0001 1744          move.b    #1,-2(A6)
000009C6  FFFE      
                    1745   ; events_rdy_nbr++;
000009C8  5243      1746          addq.w    #1,D3
000009CA  6006      1747          bra.s     OSEventPendMulti_35
                    1748   OSEventPendMulti_34:
                    1749   ; } else {
                    1750   ; events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
000009CC  002E 0004 1751          or.b      #4,-1(A6)
000009D0  FFFF      
                    1752   OSEventPendMulti_35:
                    1753   ; }
                    1754   ; break;
000009D2  6012      1755          bra.s     OSEventPendMulti_22
                    1756   OSEventPendMulti_27:
                    1757   ; #endif
                    1758   ; case OS_EVENT_TYPE_MUTEX:
                    1759   ; case OS_EVENT_TYPE_FLAG:
                    1760   ; default:
                    1761   ; OS_EXIT_CRITICAL();
000009D4  46DF      1762          dc.w      18143
                    1763   ; *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
000009D6  2045      1764          move.l    D5,A0
000009D8  4290      1765          clr.l     (A0)
                    1766   ; *perr        =  OS_ERR_EVENT_TYPE;
000009DA  2044      1767          move.l    D4,A0
000009DC  10BC 0001 1768          move.b    #1,(A0)
                    1769   ; return (events_rdy_nbr);
000009E0  3003      1770          move.w    D3,D0
000009E2  6000 0170 1771          bra       OSEventPendMulti_13
                    1772   OSEventPendMulti_22:
                    1773   ; }
                    1774   ; pevents++;
000009E6  5887      1775          addq.l    #4,D7
                    1776   ; pevent = *pevents;
000009E8  2047      1777          move.l    D7,A0
000009EA  2410      1778          move.l    (A0),D2
000009EC  6000 FEF4 1779          bra       OSEventPendMulti_18
                    1780   OSEventPendMulti_20:
                    1781   ; }
                    1782   ; if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
000009F0  102E FFFE 1783          move.b    -2(A6),D0
000009F4  0C00 0001 1784          cmp.b     #1,D0
000009F8  6610      1785          bne.s     OSEventPendMulti_38
                    1786   ; *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
000009FA  2045      1787          move.l    D5,A0
000009FC  4290      1788          clr.l     (A0)
                    1789   ; OS_EXIT_CRITICAL();
000009FE  46DF      1790          dc.w      18143
                    1791   ; *perr        =  OS_ERR_NONE;
00000A00  2044      1792          move.l    D4,A0
00000A02  4210      1793          clr.b     (A0)
                    1794   ; return (events_rdy_nbr);
00000A04  3003      1795          move.w    D3,D0
00000A06  6000 014C 1796          bra       OSEventPendMulti_13
                    1797   OSEventPendMulti_38:
                    1798   ; }
                    1799   ; /*$PAGE*/
                    1800   ; /* Otherwise, must wait until any event occurs */
                    1801   ; OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
00000A0A  2052      1802          move.l    (A2),A0
00000A0C  102E FFFF 1803          move.b    -1(A6),D0
00000A10  803C 0080 1804          or.b      #128,D0
00000A14  8128 0032 1805          or.b      D0,50(A0)
                    1806   ; OS_STAT_MULTI;           /* ... pend on multiple events                 */
                    1807   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00000A18  2052      1808          move.l    (A2),A0
00000A1A  4228 0033 1809          clr.b     51(A0)
                    1810   ; OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
00000A1E  2052      1811          move.l    (A2),A0
00000A20  216E 0014 1812          move.l    20(A6),46(A0)
00000A24  002E      
                    1813   ; OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
00000A26  2F0C      1814          move.l    A4,-(A7)
00000A28  4EB9 0000 1815          jsr       _OS_EventTaskWaitMulti
00000A2C  0F80      
00000A2E  584F      1816          addq.w    #4,A7
                    1817   ; OS_EXIT_CRITICAL();
00000A30  46DF      1818          dc.w      18143
                    1819   ; OS_Sched();                                         /* Find next highest priority task ready       */
00000A32  4EB9 0000 1820          jsr       _OS_Sched
00000A36  13F8      
                    1821   ; OS_ENTER_CRITICAL();
00000A38  40E7      1822          dc.w      16615
00000A3A  007C      1823          dc.w      124
00000A3C  0700      1824          dc.w      1792
                    1825   ; switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
00000A3E  2052      1826          move.l    (A2),A0
00000A40  1028 0033 1827          move.b    51(A0),D0
00000A44  C0BC 0000 1828          and.l     #255,D0
00000A48  00FF      
00000A4A  0C80 0000 1829          cmp.l     #1,D0
00000A4E  0001      
00000A50  6700 0046 1830          beq       OSEventPendMulti_44
00000A54  6208      1831          bhi.s     OSEventPendMulti_46
00000A56  4A80      1832          tst.l     D0
00000A58  6710      1833          beq.s     OSEventPendMulti_42
00000A5A  6000 003C 1834          bra       OSEventPendMulti_44
                    1835   OSEventPendMulti_46:
00000A5E  0C80 0000 1836          cmp.l     #2,D0
00000A62  0002      
00000A64  6704      1837          beq.s     OSEventPendMulti_42
00000A66  6000 0030 1838          bra       OSEventPendMulti_44
                    1839   OSEventPendMulti_42:
                    1840   ; case OS_STAT_PEND_OK:
                    1841   ; case OS_STAT_PEND_ABORT:
                    1842   ; pevent = OSTCBCur->OSTCBEventPtr;
00000A6A  2052      1843          move.l    (A2),A0
00000A6C  2428 001C 1844          move.l    28(A0),D2
                    1845   ; if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
00000A70  4A82      1846          tst.l     D2
00000A72  670E      1847          beq.s     OSEventPendMulti_47
                    1848   ; *pevents_rdy++   =  pevent;             /* ... return available event ...              */
00000A74  2045      1849          move.l    D5,A0
00000A76  5885      1850          addq.l    #4,D5
00000A78  2082      1851          move.l    D2,(A0)
                    1852   ; *pevents_rdy     = (OS_EVENT *)0;       /* ... & NULL terminate return event array     */
00000A7A  2045      1853          move.l    D5,A0
00000A7C  4290      1854          clr.l     (A0)
                    1855   ; events_rdy_nbr =  1;
00000A7E  7601      1856          moveq     #1,D3
00000A80  6014      1857          bra.s     OSEventPendMulti_48
                    1858   OSEventPendMulti_47:
                    1859   ; } else {                                   /* Else NO event available, handle as timeout  */
                    1860   ; OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
00000A82  2052      1861          move.l    (A2),A0
00000A84  117C 0001 1862          move.b    #1,51(A0)
00000A88  0033      
                    1863   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
00000A8A  2F0C      1864          move.l    A4,-(A7)
00000A8C  2F12      1865          move.l    (A2),-(A7)
00000A8E  4EB9 0000 1866          jsr       _OS_EventTaskRemoveMulti
00000A92  1070      
00000A94  504F      1867          addq.w    #8,A7
                    1868   OSEventPendMulti_48:
                    1869   ; }
                    1870   ; break;
00000A96  600C      1871          bra.s     OSEventPendMulti_41
                    1872   OSEventPendMulti_44:
                    1873   ; case OS_STAT_PEND_TO:                           /* If events timed out, ...                    */
                    1874   ; default:                                        /* ... remove task from events' wait lists     */
                    1875   ; OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
00000A98  2F0C      1876          move.l    A4,-(A7)
00000A9A  2F12      1877          move.l    (A2),-(A7)
00000A9C  4EB9 0000 1878          jsr       _OS_EventTaskRemoveMulti
00000AA0  1070      
00000AA2  504F      1879          addq.w    #8,A7
                    1880   ; break;
                    1881   OSEventPendMulti_41:
                    1882   ; }
                    1883   ; switch (OSTCBCur->OSTCBStatPend) {
00000AA4  2052      1884          move.l    (A2),A0
00000AA6  1028 0033 1885          move.b    51(A0),D0
00000AAA  C0BC 0000 1886          and.l     #255,D0
00000AAE  00FF      
00000AB0  0C80 0000 1887          cmp.l     #1,D0
00000AB4  0001      
00000AB6  6700 0072 1888          beq       OSEventPendMulti_53
00000ABA  6208      1889          bhi.s     OSEventPendMulti_55
00000ABC  4A80      1890          tst.l     D0
00000ABE  6712      1891          beq.s     OSEventPendMulti_51
00000AC0  6000 0068 1892          bra       OSEventPendMulti_53
                    1893   OSEventPendMulti_55:
00000AC4  0C80 0000 1894          cmp.l     #2,D0
00000AC8  0002      
00000ACA  6700 0054 1895          beq       OSEventPendMulti_52
00000ACE  6000 005A 1896          bra       OSEventPendMulti_53
                    1897   OSEventPendMulti_51:
                    1898   ; case OS_STAT_PEND_OK:
                    1899   ; switch (pevent->OSEventType) {             /* Return event's message                      */
00000AD2  2042      1900          move.l    D2,A0
00000AD4  1010      1901          move.b    (A0),D0
00000AD6  C0BC 0000 1902          and.l     #255,D0
00000ADA  00FF      
00000ADC  5380      1903          subq.l    #1,D0
00000ADE  6528      1904          blo.s     OSEventPendMulti_62
00000AE0  0C80 0000 1905          cmp.l     #5,D0
00000AE4  0005      
00000AE6  6420      1906          bhs.s     OSEventPendMulti_62
00000AE8  E380      1907          asl.l     #1,D0
00000AEA  303B 0806 1908          move.w    OSEventPendMulti_58(PC,D0.L),D0
00000AEE  4EFB 0002 1909          jmp       OSEventPendMulti_58(PC,D0.W)
                    1910   OSEventPendMulti_58:
00000AF2  000E      1911          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
00000AF4  000E      1912          dc.w      OSEventPendMulti_60-OSEventPendMulti_58
00000AF6  000A      1913          dc.w      OSEventPendMulti_59-OSEventPendMulti_58
00000AF8  0016      1914          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
00000AFA  0016      1915          dc.w      OSEventPendMulti_62-OSEventPendMulti_58
                    1916   OSEventPendMulti_59:
                    1917   ; #if (OS_SEM_EN > 0u)
                    1918   ; case OS_EVENT_TYPE_SEM:
                    1919   ; *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
00000AFC  429B      1920          clr.l     (A3)+
                    1921   ; break;
00000AFE  601A      1922          bra.s     OSEventPendMulti_57
                    1923   OSEventPendMulti_60:
                    1924   ; #endif
                    1925   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    1926   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    1927   ; case OS_EVENT_TYPE_MBOX:
                    1928   ; case OS_EVENT_TYPE_Q:
                    1929   ; *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
00000B00  2052      1930          move.l    (A2),A0
00000B02  26E8 0024 1931          move.l    36(A0),(A3)+
                    1932   ; break;
00000B06  6012      1933          bra.s     OSEventPendMulti_57
                    1934   OSEventPendMulti_62:
                    1935   ; #endif
                    1936   ; case OS_EVENT_TYPE_MUTEX:
                    1937   ; case OS_EVENT_TYPE_FLAG:
                    1938   ; default:
                    1939   ; OS_EXIT_CRITICAL();
00000B08  46DF      1940          dc.w      18143
                    1941   ; *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
00000B0A  2045      1942          move.l    D5,A0
00000B0C  4290      1943          clr.l     (A0)
                    1944   ; *perr        =  OS_ERR_EVENT_TYPE;
00000B0E  2044      1945          move.l    D4,A0
00000B10  10BC 0001 1946          move.b    #1,(A0)
                    1947   ; return (events_rdy_nbr);
00000B14  3003      1948          move.w    D3,D0
00000B16  6000 003C 1949          bra       OSEventPendMulti_13
                    1950   OSEventPendMulti_57:
                    1951   ; }
                    1952   ; *perr = OS_ERR_NONE;
00000B1A  2044      1953          move.l    D4,A0
00000B1C  4210      1954          clr.b     (A0)
                    1955   ; break;
00000B1E  6012      1956          bra.s     OSEventPendMulti_50
                    1957   OSEventPendMulti_52:
                    1958   ; case OS_STAT_PEND_ABORT:
                    1959   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
00000B20  429B      1960          clr.l     (A3)+
                    1961   ; *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
00000B22  2044      1962          move.l    D4,A0
00000B24  10BC 000E 1963          move.b    #14,(A0)
                    1964   ; break;
00000B28  6008      1965          bra.s     OSEventPendMulti_50
                    1966   OSEventPendMulti_53:
                    1967   ; case OS_STAT_PEND_TO:
                    1968   ; default:
                    1969   ; *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
00000B2A  429B      1970          clr.l     (A3)+
                    1971   ; *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
00000B2C  2044      1972          move.l    D4,A0
00000B2E  10BC 000A 1973          move.b    #10,(A0)
                    1974   ; break;
                    1975   OSEventPendMulti_50:
                    1976   ; }
                    1977   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
00000B32  2052      1978          move.l    (A2),A0
00000B34  4228 0032 1979          clr.b     50(A0)
                    1980   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
00000B38  2052      1981          move.l    (A2),A0
00000B3A  4228 0033 1982          clr.b     51(A0)
                    1983   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
00000B3E  2052      1984          move.l    (A2),A0
00000B40  42A8 001C 1985          clr.l     28(A0)
                    1986   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00000B44  2052      1987          move.l    (A2),A0
00000B46  42A8 0020 1988          clr.l     32(A0)
                    1989   ; #if ((OS_MBOX_EN > 0u) ||                 \
                    1990   ; ((OS_Q_EN    > 0u) && (OS_MAX_QS > 0u)))
                    1991   ; OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
00000B4A  2052      1992          move.l    (A2),A0
00000B4C  42A8 0024 1993          clr.l     36(A0)
                    1994   ; #endif
                    1995   ; OS_EXIT_CRITICAL();
00000B50  46DF      1996          dc.w      18143
                    1997   ; return (events_rdy_nbr);
00000B52  3003      1998          move.w    D3,D0
                    1999   OSEventPendMulti_13:
00000B54  4CDF 1CFC 2000          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
00000B58  4E5E      2001          unlk      A6
00000B5A  4E75      2002          rts
                    2003   ; }
                    2004   ; #endif
                    2005   ; /*$PAGE*/
                    2006   ; /*
                    2007   ; *********************************************************************************************************
                    2008   ; *                                           INITIALIZATION
                    2009   ; *
                    2010   ; * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
                    2011   ; *              creating any uC/OS-II object and, prior to calling OSStart().
                    2012   ; *
                    2013   ; * Arguments  : none
                    2014   ; *
                    2015   ; * Returns    : none
                    2016   ; *********************************************************************************************************
                    2017   ; */
                    2018   ; void  OSInit (void)
                    2019   ; {
                    2020   _OSInit:
                    2021   ; OSInitHookBegin();                                           /* Call port specific initialization code   */
00000B5C  4EB8 06D2 2022          jsr       _OSInitHookBegin
                    2023   ; OS_InitMisc();                                               /* Initialize miscellaneous variables       */
00000B60  4EB9 0000 2024          jsr       @ucos_ii_OS_InitMisc
00000B64  11B8      
                    2025   ; OS_InitRdyList();                                            /* Initialize the Ready List                */
00000B66  4EB9 0000 2026          jsr       @ucos_ii_OS_InitRdyList
00000B6A  11FC      
                    2027   ; OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
00000B6C  4EB9 0000 2028          jsr       @ucos_ii_OS_InitTCBList
00000B70  12F4      
                    2029   ; OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
00000B72  4EB9 0000 2030          jsr       @ucos_ii_OS_InitEventList
00000B76  1110      
                    2031   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    2032   ; OS_FlagInit();                                               /* Initialize the event flag structures     */
00000B78  4EB9 0000 2033          jsr       _OS_FlagInit
00000B7C  2106      
                    2034   ; #endif
                    2035   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    2036   ; OS_MemInit();                                                /* Initialize the memory manager            */
00000B7E  4EB9 0000 2037          jsr       _OS_MemInit
00000B82  29C4      
                    2038   ; #endif
                    2039   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    2040   ; OS_QInit();                                                  /* Initialize the message queue structures  */
00000B84  4EB9 0000 2041          jsr       _OS_QInit
00000B88  3B2A      
                    2042   ; #endif
                    2043   ; OS_InitTaskIdle();                                           /* Create the Idle Task                     */
00000B8A  4EB9 0000 2044          jsr       @ucos_ii_OS_InitTaskIdle
00000B8E  123C      
                    2045   ; #if OS_TASK_STAT_EN > 0u
                    2046   ; OS_InitTaskStat();                                           /* Create the Statistic Task                */
00000B90  4EB9 0000 2047          jsr       @ucos_ii_OS_InitTaskStat
00000B94  1298      
                    2048   ; #endif
                    2049   ; #if OS_TMR_EN > 0u
                    2050   ; OSTmr_Init();                                                /* Initialize the Timer Manager             */
00000B96  4EB9 0000 2051          jsr       _OSTmr_Init
00000B9A  547C      
                    2052   ; #endif
                    2053   ; OSInitHookEnd();                                             /* Call port specific init. code            */
00000B9C  4EB8 06D4 2054          jsr       _OSInitHookEnd
00000BA0  4E75      2055          rts
                    2056   ; #if OS_DEBUG_EN > 0u
                    2057   ; OSDebugInit();
                    2058   ; #endif
                    2059   ; }
                    2060   ; /*$PAGE*/
                    2061   ; /*
                    2062   ; *********************************************************************************************************
                    2063   ; *                                              ENTER ISR
                    2064   ; *
                    2065   ; * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
                    2066   ; *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
                    2067   ; *              only perform rescheduling at the last nested ISR.
                    2068   ; *
                    2069   ; * Arguments  : none
                    2070   ; *
                    2071   ; * Returns    : none
                    2072   ; *
                    2073   ; * Notes      : 1) This function should be called with interrupts already disabled
                    2074   ; *              2) Your ISR can directly increment OSIntNesting without calling this function because
                    2075   ; *                 OSIntNesting has been declared 'global'.
                    2076   ; *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
                    2077   ; *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2078   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2079   ; *                 end of the ISR.
                    2080   ; *              5) You are allowed to nest interrupts up to 255 levels deep.
                    2081   ; *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
                    2082   ; *                 OSIntEnter() is always called with interrupts disabled.
                    2083   ; *********************************************************************************************************
                    2084   ; */
                    2085   ; void  OSIntEnter (void)
                    2086   ; {
                    2087   _OSIntEnter:
                    2088   ; if (OSRunning == OS_TRUE) {
00000BA2  1039 0080 2089          move.b    _OSRunning.L,D0
00000BA6  0258      
00000BA8  0C00 0001 2090          cmp.b     #1,D0
00000BAC  6612      2091          bne.s     OSIntEnter_3
                    2092   ; if (OSIntNesting < 255u) {
00000BAE  1039 0080 2093          move.b    _OSIntNesting.L,D0
00000BB2  0246      
00000BB4  0C00 00FF 2094          cmp.b     #255,D0
00000BB8  6406      2095          bhs.s     OSIntEnter_3
                    2096   ; OSIntNesting++;                      /* Increment ISR nesting level                        */
00000BBA  5239 0080 2097          addq.b    #1,_OSIntNesting.L
00000BBE  0246      
                    2098   OSIntEnter_3:
00000BC0  4E75      2099          rts
                    2100   ; }
                    2101   ; }
                    2102   ; }
                    2103   ; /*$PAGE*/
                    2104   ; /*
                    2105   ; *********************************************************************************************************
                    2106   ; *                                              EXIT ISR
                    2107   ; *
                    2108   ; * Description: This function is used to notify uC/OS-II that you have completed servicing an ISR.  When
                    2109   ; *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
                    2110   ; *              a new, high-priority task, is ready to run.
                    2111   ; *
                    2112   ; * Arguments  : none
                    2113   ; *
                    2114   ; * Returns    : none
                    2115   ; *
                    2116   ; * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
                    2117   ; *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
                    2118   ; *                 end of the ISR.
                    2119   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    2120   ; *********************************************************************************************************
                    2121   ; */
                    2122   ; void  OSIntExit (void)
                    2123   ; {
                    2124   _OSIntExit:
                    2125   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2126   ; OS_CPU_SR  cpu_sr = 0u;
                    2127   ; #endif
                    2128   ; if (OSRunning == OS_TRUE) {
00000BC2  1039 0080 2129          move.b    _OSRunning.L,D0
00000BC6  0258      
00000BC8  0C00 0001 2130          cmp.b     #1,D0
00000BCC  6600 0078 2131          bne       OSIntExit_1
                    2132   ; OS_ENTER_CRITICAL();
00000BD0  40E7      2133          dc.w      16615
00000BD2  007C      2134          dc.w      124
00000BD4  0700      2135          dc.w      1792
                    2136   ; if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
00000BD6  1039 0080 2137          move.b    _OSIntNesting.L,D0
00000BDA  0246      
00000BDC  0C00 0000 2138          cmp.b     #0,D0
00000BE0  6306      2139          bls.s     OSIntExit_3
                    2140   ; OSIntNesting--;
00000BE2  5339 0080 2141          subq.b    #1,_OSIntNesting.L
00000BE6  0246      
                    2142   OSIntExit_3:
                    2143   ; }
                    2144   ; if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
00000BE8  1039 0080 2145          move.b    _OSIntNesting.L,D0
00000BEC  0246      
00000BEE  6600 0054 2146          bne       OSIntExit_9
                    2147   ; if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
00000BF2  1039 0080 2148          move.b    _OSLockNesting.L,D0
00000BF6  0248      
00000BF8  664A      2149          bne.s     OSIntExit_9
                    2150   ; OS_SchedNew();
00000BFA  4EB9 0000 2151          jsr       @ucos_ii_OS_SchedNew
00000BFE  145C      
                    2152   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00000C00  1039 0080 2153          move.b    _OSPrioHighRdy.L,D0
00000C04  024C      
00000C06  C0BC 0000 2154          and.l     #255,D0
00000C0A  00FF      
00000C0C  E588      2155          lsl.l     #2,D0
00000C0E  41F9 0080 2156          lea       _OSTCBPrioTbl.L,A0
00000C12  0370      
00000C14  23F0 0800 2157          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00000C18  0080 0368 
                    2158   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
00000C1C  1039 0080 2159          move.b    _OSPrioHighRdy.L,D0
00000C20  024C      
00000C22  B039 0080 2160          cmp.b     _OSPrioCur.L,D0
00000C26  024A      
00000C28  671A      2161          beq.s     OSIntExit_9
                    2162   ; #if OS_TASK_PROFILE_EN > 0u
                    2163   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
00000C2A  2039 0080 2164          move.l    _OSTCBHighRdy.L,D0
00000C2E  0368      
00000C30  0680 0000 2165          add.l     #58,D0
00000C34  003A      
00000C36  2040      2166          move.l    D0,A0
00000C38  5290      2167          addq.l    #1,(A0)
                    2168   ; #endif
                    2169   ; OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00000C3A  52B9 0080 2170          addq.l    #1,_OSCtxSwCtr.L
00000C3E  0016      
                    2171   ; OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
00000C40  4EB8 04AC 2172          jsr       _OSIntCtxSw
                    2173   OSIntExit_9:
                    2174   ; }
                    2175   ; }
                    2176   ; }
                    2177   ; OS_EXIT_CRITICAL();
00000C44  46DF      2178          dc.w      18143
                    2179   OSIntExit_1:
00000C46  4E75      2180          rts
                    2181   ; }
                    2182   ; }
                    2183   ; /*$PAGE*/
                    2184   ; /*
                    2185   ; *********************************************************************************************************
                    2186   ; *                         INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
                    2187   ; *
                    2188   ; * Description: This function is called by the application code to indicate that all initialization has
                    2189   ; *              been completed and that kernel objects are no longer allowed to be created.
                    2190   ; *
                    2191   ; * Arguments  : none
                    2192   ; *
                    2193   ; * Returns    : none
                    2194   ; *
                    2195   ; * Note(s)    : 1) You should call this function when you no longer want to allow application code to
                    2196   ; *                 create kernel objects.
                    2197   ; *              2) You need to define the macro 'OS_SAFETY_CRITICAL_IEC61508'
                    2198   ; *********************************************************************************************************
                    2199   ; */
                    2200   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    2201   ; void  OSSafetyCriticalStart (void)
                    2202   ; {
                    2203   ; OSSafetyCriticalStartFlag = OS_TRUE;
                    2204   ; }
                    2205   ; #endif
                    2206   ; /*$PAGE*/
                    2207   ; /*
                    2208   ; *********************************************************************************************************
                    2209   ; *                                         PREVENT SCHEDULING
                    2210   ; *
                    2211   ; * Description: This function is used to prevent rescheduling to take place.  This allows your application
                    2212   ; *              to prevent context switches until you are ready to permit context switching.
                    2213   ; *
                    2214   ; * Arguments  : none
                    2215   ; *
                    2216   ; * Returns    : none
                    2217   ; *
                    2218   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2219   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2220   ; *********************************************************************************************************
                    2221   ; */
                    2222   ; #if OS_SCHED_LOCK_EN > 0u
                    2223   ; void  OSSchedLock (void)
                    2224   ; {
                    2225   _OSSchedLock:
                    2226   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2227   ; OS_CPU_SR  cpu_sr = 0u;
                    2228   ; #endif
                    2229   ; if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
00000C48  1039 0080 2230          move.b    _OSRunning.L,D0
00000C4C  0258      
00000C4E  0C00 0001 2231          cmp.b     #1,D0
00000C52  6622      2232          bne.s     OSSchedLock_1
                    2233   ; OS_ENTER_CRITICAL();
00000C54  40E7      2234          dc.w      16615
00000C56  007C      2235          dc.w      124
00000C58  0700      2236          dc.w      1792
                    2237   ; if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
00000C5A  1039 0080 2238          move.b    _OSIntNesting.L,D0
00000C5E  0246      
00000C60  6612      2239          bne.s     OSSchedLock_5
                    2240   ; if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
00000C62  1039 0080 2241          move.b    _OSLockNesting.L,D0
00000C66  0248      
00000C68  0C00 00FF 2242          cmp.b     #255,D0
00000C6C  6406      2243          bhs.s     OSSchedLock_5
                    2244   ; OSLockNesting++;                 /* Increment lock nesting level                       */
00000C6E  5239 0080 2245          addq.b    #1,_OSLockNesting.L
00000C72  0248      
                    2246   OSSchedLock_5:
                    2247   ; }
                    2248   ; }
                    2249   ; OS_EXIT_CRITICAL();
00000C74  46DF      2250          dc.w      18143
                    2251   OSSchedLock_1:
00000C76  4E75      2252          rts
                    2253   ; }
                    2254   ; }
                    2255   ; #endif
                    2256   ; /*$PAGE*/
                    2257   ; /*
                    2258   ; *********************************************************************************************************
                    2259   ; *                                          ENABLE SCHEDULING
                    2260   ; *
                    2261   ; * Description: This function is used to re-allow rescheduling.
                    2262   ; *
                    2263   ; * Arguments  : none
                    2264   ; *
                    2265   ; * Returns    : none
                    2266   ; *
                    2267   ; * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
                    2268   ; *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
                    2269   ; *********************************************************************************************************
                    2270   ; */
                    2271   ; #if OS_SCHED_LOCK_EN > 0u
                    2272   ; void  OSSchedUnlock (void)
                    2273   ; {
                    2274   _OSSchedUnlock:
                    2275   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    2276   ; OS_CPU_SR  cpu_sr = 0u;
                    2277   ; #endif
                    2278   ; if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
00000C78  1039 0080 2279          move.b    _OSRunning.L,D0
00000C7C  0258      
00000C7E  0C00 0001 2280          cmp.b     #1,D0
00000C82  6600 003E 2281          bne       OSSchedUnlock_4
                    2282   ; OS_ENTER_CRITICAL();
00000C86  40E7      2283          dc.w      16615
00000C88  007C      2284          dc.w      124
00000C8A  0700      2285          dc.w      1792
                    2286   ; if (OSIntNesting == 0u) {                          /* Can't call from an ISR                   */
00000C8C  1039 0080 2287          move.b    _OSIntNesting.L,D0
00000C90  0246      
00000C92  662C      2288          bne.s     OSSchedUnlock_3
                    2289   ; if (OSLockNesting > 0u) {                      /* Do not decrement if already 0            */
00000C94  1039 0080 2290          move.b    _OSLockNesting.L,D0
00000C98  0248      
00000C9A  0C00 0000 2291          cmp.b     #0,D0
00000C9E  631C      2292          bls.s     OSSchedUnlock_5
                    2293   ; OSLockNesting--;                           /* Decrement lock nesting level             */
00000CA0  5339 0080 2294          subq.b    #1,_OSLockNesting.L
00000CA4  0248      
                    2295   ; if (OSLockNesting == 0u) {                 /* See if scheduler is enabled              */
00000CA6  1039 0080 2296          move.b    _OSLockNesting.L,D0
00000CAA  0248      
00000CAC  660A      2297          bne.s     OSSchedUnlock_7
                    2298   ; OS_EXIT_CRITICAL();
00000CAE  46DF      2299          dc.w      18143
                    2300   ; OS_Sched();                            /* See if a HPT is ready                    */
00000CB0  4EB9 0000 2301          jsr       _OS_Sched
00000CB4  13F8      
00000CB6  6002      2302          bra.s     OSSchedUnlock_8
                    2303   OSSchedUnlock_7:
                    2304   ; } else {
                    2305   ; OS_EXIT_CRITICAL();
00000CB8  46DF      2306          dc.w      18143
                    2307   OSSchedUnlock_8:
00000CBA  6002      2308          bra.s     OSSchedUnlock_6
                    2309   OSSchedUnlock_5:
                    2310   ; }
                    2311   ; } else {
                    2312   ; OS_EXIT_CRITICAL();
00000CBC  46DF      2313          dc.w      18143
                    2314   OSSchedUnlock_6:
00000CBE  6002      2315          bra.s     OSSchedUnlock_4
                    2316   OSSchedUnlock_3:
                    2317   ; }
                    2318   ; } else {
                    2319   ; OS_EXIT_CRITICAL();
00000CC0  46DF      2320          dc.w      18143
                    2321   OSSchedUnlock_4:
00000CC2  4E75      2322          rts
                    2323   ; }
                    2324   ; }
                    2325   ; }
                    2326   ; #endif
                    2327   ; /*$PAGE*/
                    2328   ; /*
                    2329   ; *********************************************************************************************************
                    2330   ; *                                         START MULTITASKING
                    2331   ; *
                    2332   ; * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
                    2333   ; *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
                    2334   ; *              and you MUST have created at least one task.
                    2335   ; *
                    2336   ; * Arguments  : none
                    2337   ; *
                    2338   ; * Returns    : none
                    2339   ; *
                    2340   ; * Note       : OSStartHighRdy() MUST:
                    2341   ; *                 a) Call OSTaskSwHook() then,
                    2342   ; *                 b) Set OSRunning to OS_TRUE.
                    2343   ; *                 c) Load the context of the task pointed to by OSTCBHighRdy.
                    2344   ; *                 d_ Execute the task.
                    2345   ; *********************************************************************************************************
                    2346   ; */
                    2347   ; void  OSStart (void)
                    2348   ; {
                    2349   _OSStart:
                    2350   ; if (OSRunning == OS_FALSE) {
00000CC4  1039 0080 2351          move.b    _OSRunning.L,D0
00000CC8  0258      
00000CCA  663A      2352          bne.s     OSStart_1
                    2353   ; OS_SchedNew();                               /* Find highest priority's task priority number   */
00000CCC  4EB9 0000 2354          jsr       @ucos_ii_OS_SchedNew
00000CD0  145C      
                    2355   ; OSPrioCur     = OSPrioHighRdy;
00000CD2  13F9 0080 2356          move.b    _OSPrioHighRdy.L,_OSPrioCur.L
00000CD6  024C 0080 
00000CDA  024A      
                    2357   ; OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
00000CDC  1039 0080 2358          move.b    _OSPrioHighRdy.L,D0
00000CE0  024C      
00000CE2  C0BC 0000 2359          and.l     #255,D0
00000CE6  00FF      
00000CE8  E588      2360          lsl.l     #2,D0
00000CEA  41F9 0080 2361          lea       _OSTCBPrioTbl.L,A0
00000CEE  0370      
00000CF0  23F0 0800 2362          move.l    0(A0,D0.L),_OSTCBHighRdy.L
00000CF4  0080 0368 
                    2363   ; OSTCBCur      = OSTCBHighRdy;
00000CF8  23F9 0080 2364          move.l    _OSTCBHighRdy.L,_OSTCBCur.L
00000CFC  0368 0080 
00000D00  0360      
                    2365   ; OSStartHighRdy();                            /* Execute target specific code to start task     */
00000D02  4EB8 0462 2366          jsr       _OSStartHighRdy
                    2367   OSStart_1:
00000D06  4E75      2368          rts
                    2369   ; }
                    2370   ; }
                    2371   ; /*$PAGE*/
                    2372   ; /*
                    2373   ; *********************************************************************************************************
                    2374   ; *                                      STATISTICS INITIALIZATION
                    2375   ; *
                    2376   ; * Description: This function is called by your application to establish CPU usage by first determining
                    2377   ; *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
                    2378   ; *              during that time.  CPU usage is then determined by a low priority task which keeps track
                    2379   ; *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
                    2380   ; *              determined by:
                    2381   ; *
                    2382   ; *                                             OSIdleCtr
                    2383   ; *                 CPU Usage (%) = 100 * (1 - ------------)
                    2384   ; *                                            OSIdleCtrMax
                    2385   ; *
                    2386   ; * Arguments  : none
                    2387   ; *
                    2388   ; * Returns    : none
                    2389   ; *********************************************************************************************************
                    2390   ; */
                    2391   ; #if OS_TASK_STAT_EN > 0u
                    2392   ; void  OSStatInit (void)
                    2393   ; {
                    2394   _OSStatInit:
                    2395   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    2396   ; OS_CPU_SR  cpu_sr = 0u;
                    2397   ; #endif
                    2398   ; OSTimeDly(2u);                               /* Synchronize with clock tick                        */
00000D08  4878 0002 2399          pea       2
00000D0C  4EB9 0000 2400          jsr       _OSTimeDly
00000D10  4BF4      
00000D12  584F      2401          addq.w    #4,A7
                    2402   ; OS_ENTER_CRITICAL();
00000D14  40E7      2403          dc.w      16615
00000D16  007C      2404          dc.w      124
00000D18  0700      2405          dc.w      1792
                    2406   ; OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
00000D1A  42B9 0080 2407          clr.l     _OSIdleCtr.L
00000D1E  025C      
                    2408   ; OS_EXIT_CRITICAL();
00000D20  46DF      2409          dc.w      18143
                    2410   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
00000D22  4878 000A 2411          pea       10
00000D26  4EB9 0000 2412          jsr       _OSTimeDly
00000D2A  4BF4      
00000D2C  584F      2413          addq.w    #4,A7
                    2414   ; OS_ENTER_CRITICAL();
00000D2E  40E7      2415          dc.w      16615
00000D30  007C      2416          dc.w      124
00000D32  0700      2417          dc.w      1792
                    2418   ; OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
00000D34  23F9 0080 2419          move.l    _OSIdleCtr.L,_OSIdleCtrMax.L
00000D38  025C 0080 
00000D3C  013C      
                    2420   ; OSStatRdy    = OS_TRUE;
00000D3E  13FC 0001 2421          move.b    #1,_OSStatRdy.L
00000D42  0080 0144 
                    2422   ; OS_EXIT_CRITICAL();
00000D46  46DF      2423          dc.w      18143
00000D48  4E75      2424          rts
                    2425   ; }
                    2426   ; #endif
                    2427   ; /*$PAGE*/
                    2428   ; /*
                    2429   ; *********************************************************************************************************
                    2430   ; *                                         PROCESS SYSTEM TICK
                    2431   ; *
                    2432   ; * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
                    2433   ; *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
                    2434   ; *              called by a high priority task.
                    2435   ; *
                    2436   ; * Arguments  : none
                    2437   ; *
                    2438   ; * Returns    : none
                    2439   ; *********************************************************************************************************
                    2440   ; */
                    2441   ; void  OSTimeTick (void)
                    2442   ; {
                    2443   _OSTimeTick:
00000D4A  2F02      2444          move.l    D2,-(A7)
                    2445   ; OS_TCB    *ptcb;
                    2446   ; #if OS_TICK_STEP_EN > 0u
                    2447   ; BOOLEAN    step;
                    2448   ; #endif
                    2449   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
                    2450   ; OS_CPU_SR  cpu_sr = 0u;
                    2451   ; #endif
                    2452   ; #if OS_TIME_TICK_HOOK_EN > 0u
                    2453   ; OSTimeTickHook();                                      /* Call user definable hook                     */
00000D4C  4EB8 06FA 2454          jsr       _OSTimeTickHook
                    2455   ; #endif
                    2456   ; #if OS_TIME_GET_SET_EN > 0u
                    2457   ; OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
00000D50  40E7      2458          dc.w      16615
00000D52  007C      2459          dc.w      124
00000D54  0700      2460          dc.w      1792
                    2461   ; OSTime++;
00000D56  52B9 0080 2462          addq.l    #1,_OSTime.L
00000D5A  0CB6      
                    2463   ; OS_EXIT_CRITICAL();
00000D5C  46DF      2464          dc.w      18143
                    2465   ; #endif
                    2466   ; if (OSRunning == OS_TRUE) {
00000D5E  1039 0080 2467          move.b    _OSRunning.L,D0
00000D62  0258      
00000D64  0C00 0001 2468          cmp.b     #1,D0
00000D68  6600 00A2 2469          bne       OSTimeTick_5
                    2470   ; #if OS_TICK_STEP_EN > 0u
                    2471   ; switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
                    2472   ; case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                    2473   ; step = OS_TRUE;
                    2474   ; break;
                    2475   ; case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                    2476   ; step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
                    2477   ; break;
                    2478   ; case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                    2479   ; step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
                    2480   ; OSTickStepState = OS_TICK_STEP_WAIT;
                    2481   ; break;
                    2482   ; default:                                       /* Invalid case, correct situation              */
                    2483   ; step            = OS_TRUE;
                    2484   ; OSTickStepState = OS_TICK_STEP_DIS;
                    2485   ; break;
                    2486   ; }
                    2487   ; if (step == OS_FALSE) {                            /* Return if waiting for step command           */
                    2488   ; return;
                    2489   ; }
                    2490   ; #endif
                    2491   ; ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
00000D6C  2439 0080 2492          move.l    _OSTCBList.L,D2
00000D70  036C      
                    2493   ; while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
                    2494   OSTimeTick_3:
00000D72  2042      2495          move.l    D2,A0
00000D74  1028 0034 2496          move.b    52(A0),D0
00000D78  0C00 003F 2497          cmp.b     #63,D0
00000D7C  6700 008E 2498          beq       OSTimeTick_5
                    2499   ; OS_ENTER_CRITICAL();
00000D80  40E7      2500          dc.w      16615
00000D82  007C      2501          dc.w      124
00000D84  0700      2502          dc.w      1792
                    2503   ; if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
00000D86  2042      2504          move.l    D2,A0
00000D88  2028 002E 2505          move.l    46(A0),D0
00000D8C  6700 0072 2506          beq       OSTimeTick_12
                    2507   ; ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
00000D90  2002      2508          move.l    D2,D0
00000D92  0680 0000 2509          add.l     #46,D0
00000D96  002E      
00000D98  2040      2510          move.l    D0,A0
00000D9A  5390      2511          subq.l    #1,(A0)
                    2512   ; if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
00000D9C  2042      2513          move.l    D2,A0
00000D9E  2028 002E 2514          move.l    46(A0),D0
00000DA2  6600 005C 2515          bne       OSTimeTick_12
                    2516   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
00000DA6  2042      2517          move.l    D2,A0
00000DA8  1028 0032 2518          move.b    50(A0),D0
00000DAC  C03C 0037 2519          and.b     #55,D0
00000DB0  6714      2520          beq.s     OSTimeTick_10
                    2521   ; ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
00000DB2  2042      2522          move.l    D2,A0
00000DB4  7037      2523          moveq     #55,D0
00000DB6  4600      2524          not.b     D0
00000DB8  C128 0032 2525          and.b     D0,50(A0)
                    2526   ; ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
00000DBC  2042      2527          move.l    D2,A0
00000DBE  117C 0001 2528          move.b    #1,51(A0)
00000DC2  0033      
00000DC4  6006      2529          bra.s     OSTimeTick_11
                    2530   OSTimeTick_10:
                    2531   ; } else {
                    2532   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00000DC6  2042      2533          move.l    D2,A0
00000DC8  4228 0033 2534          clr.b     51(A0)
                    2535   OSTimeTick_11:
                    2536   ; }
                    2537   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
00000DCC  2042      2538          move.l    D2,A0
00000DCE  1028 0032 2539          move.b    50(A0),D0
00000DD2  C03C 0008 2540          and.b     #8,D0
00000DD6  6628      2541          bne.s     OSTimeTick_12
                    2542   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
00000DD8  2042      2543          move.l    D2,A0
00000DDA  1028 0038 2544          move.b    56(A0),D0
00000DDE  8139 0080 2545          or.b      D0,_OSRdyGrp.L
00000DE2  024E      
                    2546   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00000DE4  2042      2547          move.l    D2,A0
00000DE6  1028 0036 2548          move.b    54(A0),D0
00000DEA  C0BC 0000 2549          and.l     #255,D0
00000DEE  00FF      
00000DF0  41F9 0080 2550          lea       _OSRdyTbl.L,A0
00000DF4  0250      
00000DF6  2242      2551          move.l    D2,A1
00000DF8  1229 0037 2552          move.b    55(A1),D1
00000DFC  8330 0800 2553          or.b      D1,0(A0,D0.L)
                    2554   OSTimeTick_12:
                    2555   ; }
                    2556   ; }
                    2557   ; }
                    2558   ; ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
00000E00  2042      2559          move.l    D2,A0
00000E02  2428 0014 2560          move.l    20(A0),D2
                    2561   ; OS_EXIT_CRITICAL();
00000E06  46DF      2562          dc.w      18143
00000E08  6000 FF68 2563          bra       OSTimeTick_3
                    2564   OSTimeTick_5:
00000E0C  241F      2565          move.l    (A7)+,D2
00000E0E  4E75      2566          rts
                    2567   ; }
                    2568   ; }
                    2569   ; }
                    2570   ; /*$PAGE*/
                    2571   ; /*
                    2572   ; *********************************************************************************************************
                    2573   ; *                                             GET VERSION
                    2574   ; *
                    2575   ; * Description: This function is used to return the version number of uC/OS-II.  The returned value 
                    2576   ; *              corresponds to uC/OS-II's version number multiplied by 10000.  In other words, version 
                    2577   ; *              2.01.00 would be returned as 20100.
                    2578   ; *
                    2579   ; * Arguments  : none
                    2580   ; *
                    2581   ; * Returns    : The version number of uC/OS-II multiplied by 10000.
                    2582   ; *********************************************************************************************************
                    2583   ; */
                    2584   ; INT16U  OSVersion (void)
                    2585   ; {
                    2586   _OSVersion:
                    2587   ; return (OS_VERSION);
00000E10  303C 7217 2588          move.w    #29207,D0
00000E14  4E75      2589          rts
                    2590   ; }
                    2591   ; /*$PAGE*/
                    2592   ; /*
                    2593   ; *********************************************************************************************************
                    2594   ; *                                           DUMMY FUNCTION
                    2595   ; *
                    2596   ; * Description: This function doesn't do anything.  It is called by OSTaskDel().
                    2597   ; *
                    2598   ; * Arguments  : none
                    2599   ; *
                    2600   ; * Returns    : none
                    2601   ; *********************************************************************************************************
                    2602   ; */
                    2603   ; #if OS_TASK_DEL_EN > 0u
                    2604   ; void  OS_Dummy (void)
                    2605   ; {
                    2606   _OS_Dummy:
00000E16  4E75      2607          rts
                    2608   ; }
                    2609   ; #endif
                    2610   ; /*$PAGE*/
                    2611   ; /*
                    2612   ; *********************************************************************************************************
                    2613   ; *                           MAKE TASK READY TO RUN BASED ON EVENT OCCURING
                    2614   ; *
                    2615   ; * Description: This function is called by other uC/OS-II services and is used to ready a task that was
                    2616   ; *              waiting for an event to occur.
                    2617   ; *
                    2618   ; * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
                    2619   ; *
                    2620   ; *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
                    2621   ; *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
                    2622   ; *                          service functions.
                    2623   ; *
                    2624   ; *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
                    2625   ; *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
                    2626   ; *
                    2627   ; *              pend_stat   is used to indicate the readied task's pending status:
                    2628   ; *
                    2629   ; *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
                    2630   ; *                                               an abort.
                    2631   ; *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
                    2632   ; *
                    2633   ; * Returns    : none
                    2634   ; *
                    2635   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2636   ; *********************************************************************************************************
                    2637   ; */
                    2638   ; #if (OS_EVENT_EN)
                    2639   ; INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
                    2640   ; void      *pmsg,
                    2641   ; INT8U      msk,
                    2642   ; INT8U      pend_stat)
                    2643   ; {
                    2644   _OS_EventTaskRdy:
00000E18  4E56 FFFC 2645          link      A6,#-4
00000E1C  48E7 3C00 2646          movem.l   D2/D3/D4/D5,-(A7)
00000E20  262E 0008 2647          move.l    8(A6),D3
                    2648   ; OS_TCB   *ptcb;
                    2649   ; INT8U     y;
                    2650   ; INT8U     x;
                    2651   ; INT8U     prio;
                    2652   ; #if OS_LOWEST_PRIO > 63u
                    2653   ; OS_PRIO  *ptbl;
                    2654   ; #endif
                    2655   ; #if OS_LOWEST_PRIO <= 63u
                    2656   ; y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
00000E24  2043      2657          move.l    D3,A0
00000E26  1028 0008 2658          move.b    8(A0),D0
00000E2A  C0BC 0000 2659          and.l     #255,D0
00000E2E  00FF      
00000E30  41F9 0000 2660          lea       _OSUnMapTbl.L,A0
00000E34  5AE0      
00000E36  1830 0800 2661          move.b    0(A0,D0.L),D4
                    2662   ; x    = OSUnMapTbl[pevent->OSEventTbl[y]];
00000E3A  2043      2663          move.l    D3,A0
00000E3C  C8BC 0000 2664          and.l     #255,D4
00000E40  00FF      
00000E42  D1C4      2665          add.l     D4,A0
00000E44  1028 000A 2666          move.b    10(A0),D0
00000E48  C0BC 0000 2667          and.l     #255,D0
00000E4C  00FF      
00000E4E  41F9 0000 2668          lea       _OSUnMapTbl.L,A0
00000E52  5AE0      
00000E54  1D70 0800 2669          move.b    0(A0,D0.L),-1(A6)
00000E58  FFFF      
                    2670   ; prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
00000E5A  1004      2671          move.b    D4,D0
00000E5C  E708      2672          lsl.b     #3,D0
00000E5E  D02E FFFF 2673          add.b     -1(A6),D0
00000E62  1A00      2674          move.b    D0,D5
                    2675   ; #else
                    2676   ; if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
                    2677   ; y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
                    2678   ; } else {
                    2679   ; y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
                    2680   ; }
                    2681   ; ptbl = &pevent->OSEventTbl[y];
                    2682   ; if ((*ptbl & 0xFFu) != 0u) {
                    2683   ; x = OSUnMapTbl[*ptbl & 0xFFu];
                    2684   ; } else {
                    2685   ; x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
                    2686   ; }
                    2687   ; prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
                    2688   ; #endif
                    2689   ; ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
00000E64  CABC 0000 2690          and.l     #255,D5
00000E68  00FF      
00000E6A  2005      2691          move.l    D5,D0
00000E6C  E588      2692          lsl.l     #2,D0
00000E6E  41F9 0080 2693          lea       _OSTCBPrioTbl.L,A0
00000E72  0370      
00000E74  2430 0800 2694          move.l    0(A0,D0.L),D2
                    2695   ; ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
00000E78  2042      2696          move.l    D2,A0
00000E7A  42A8 002E 2697          clr.l     46(A0)
                    2698   ; #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
                    2699   ; ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
00000E7E  2042      2700          move.l    D2,A0
00000E80  216E 000C 2701          move.l    12(A6),36(A0)
00000E84  0024      
                    2702   ; #else
                    2703   ; pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
                    2704   ; #endif
                    2705   ; ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
00000E86  2042      2706          move.l    D2,A0
00000E88  102E 0013 2707          move.b    19(A6),D0
00000E8C  4600      2708          not.b     D0
00000E8E  C128 0032 2709          and.b     D0,50(A0)
                    2710   ; ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
00000E92  2042      2711          move.l    D2,A0
00000E94  116E 0017 2712          move.b    23(A6),51(A0)
00000E98  0033      
                    2713   ; /* See if task is ready (could be susp'd)      */
                    2714   ; if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
00000E9A  2042      2715          move.l    D2,A0
00000E9C  1028 0032 2716          move.b    50(A0),D0
00000EA0  C03C 0008 2717          and.b     #8,D0
00000EA4  6622      2718          bne.s     OS_EventTaskRdy_1
                    2719   ; OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
00000EA6  2042      2720          move.l    D2,A0
00000EA8  1028 0038 2721          move.b    56(A0),D0
00000EAC  8139 0080 2722          or.b      D0,_OSRdyGrp.L
00000EB0  024E      
                    2723   ; OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
00000EB2  C8BC 0000 2724          and.l     #255,D4
00000EB6  00FF      
00000EB8  41F9 0080 2725          lea       _OSRdyTbl.L,A0
00000EBC  0250      
00000EBE  2242      2726          move.l    D2,A1
00000EC0  1029 0037 2727          move.b    55(A1),D0
00000EC4  8130 4800 2728          or.b      D0,0(A0,D4.L)
                    2729   OS_EventTaskRdy_1:
                    2730   ; }
                    2731   ; OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
00000EC8  2F03      2732          move.l    D3,-(A7)
00000ECA  2F02      2733          move.l    D2,-(A7)
00000ECC  4EB9 0000 2734          jsr       _OS_EventTaskRemove
00000ED0  101E      
00000ED2  504F      2735          addq.w    #8,A7
                    2736   ; #if (OS_EVENT_MULTI_EN > 0u)
                    2737   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
00000ED4  2042      2738          move.l    D2,A0
00000ED6  2028 0020 2739          move.l    32(A0),D0
00000EDA  6716      2740          beq.s     OS_EventTaskRdy_3
                    2741   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
00000EDC  2042      2742          move.l    D2,A0
00000EDE  2F28 0020 2743          move.l    32(A0),-(A7)
00000EE2  2F02      2744          move.l    D2,-(A7)
00000EE4  4EB9 0000 2745          jsr       _OS_EventTaskRemoveMulti
00000EE8  1070      
00000EEA  504F      2746          addq.w    #8,A7
                    2747   ; ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
00000EEC  2042      2748          move.l    D2,A0
00000EEE  2143 001C 2749          move.l    D3,28(A0)
                    2750   OS_EventTaskRdy_3:
                    2751   ; }
                    2752   ; #endif
                    2753   ; return (prio);
00000EF2  1005      2754          move.b    D5,D0
00000EF4  4CDF 003C 2755          movem.l   (A7)+,D2/D3/D4/D5
00000EF8  4E5E      2756          unlk      A6
00000EFA  4E75      2757          rts
                    2758   ; }
                    2759   ; #endif
                    2760   ; /*$PAGE*/
                    2761   ; /*
                    2762   ; *********************************************************************************************************
                    2763   ; *                                  MAKE TASK WAIT FOR EVENT TO OCCUR
                    2764   ; *
                    2765   ; * Description: This function is called by other uC/OS-II services to suspend a task because an event has
                    2766   ; *              not occurred.
                    2767   ; *
                    2768   ; * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
                    2769   ; *
                    2770   ; * Returns    : none
                    2771   ; *
                    2772   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2773   ; *********************************************************************************************************
                    2774   ; */
                    2775   ; #if (OS_EVENT_EN)
                    2776   ; void  OS_EventTaskWait (OS_EVENT *pevent)
                    2777   ; {
                    2778   _OS_EventTaskWait:
00000EFC  4E56 0000 2779          link      A6,#0
00000F00  48E7 3020 2780          movem.l   D2/D3/A2,-(A7)
00000F04  45F9 0080 2781          lea       _OSTCBCur.L,A2
00000F08  0360      
00000F0A  262E 0008 2782          move.l    8(A6),D3
                    2783   ; INT8U  y;
                    2784   ; OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
00000F0E  2052      2785          move.l    (A2),A0
00000F10  2143 001C 2786          move.l    D3,28(A0)
                    2787   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
00000F14  2043      2788          move.l    D3,A0
00000F16  2252      2789          move.l    (A2),A1
00000F18  1029 0036 2790          move.b    54(A1),D0
00000F1C  C0BC 0000 2791          and.l     #255,D0
00000F20  00FF      
00000F22  D1C0      2792          add.l     D0,A0
00000F24  2252      2793          move.l    (A2),A1
00000F26  1029 0037 2794          move.b    55(A1),D0
00000F2A  8128 000A 2795          or.b      D0,10(A0)
                    2796   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00000F2E  2043      2797          move.l    D3,A0
00000F30  2252      2798          move.l    (A2),A1
00000F32  1029 0038 2799          move.b    56(A1),D0
00000F36  8128 0008 2800          or.b      D0,8(A0)
                    2801   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00000F3A  2052      2802          move.l    (A2),A0
00000F3C  1428 0036 2803          move.b    54(A0),D2
                    2804   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00000F40  C4BC 0000 2805          and.l     #255,D2
00000F44  00FF      
00000F46  41F9 0080 2806          lea       _OSRdyTbl.L,A0
00000F4A  0250      
00000F4C  2252      2807          move.l    (A2),A1
00000F4E  1029 0037 2808          move.b    55(A1),D0
00000F52  4600      2809          not.b     D0
00000F54  C130 2800 2810          and.b     D0,0(A0,D2.L)
                    2811   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00000F58  C4BC 0000 2812          and.l     #255,D2
00000F5C  00FF      
00000F5E  41F9 0080 2813          lea       _OSRdyTbl.L,A0
00000F62  0250      
00000F64  1030 2800 2814          move.b    0(A0,D2.L),D0
00000F68  660E      2815          bne.s     OS_EventTaskWait_1
                    2816   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00000F6A  2052      2817          move.l    (A2),A0
00000F6C  1028 0038 2818          move.b    56(A0),D0
00000F70  4600      2819          not.b     D0
00000F72  C139 0080 2820          and.b     D0,_OSRdyGrp.L
00000F76  024E      
                    2821   OS_EventTaskWait_1:
00000F78  4CDF 040C 2822          movem.l   (A7)+,D2/D3/A2
00000F7C  4E5E      2823          unlk      A6
00000F7E  4E75      2824          rts
                    2825   ; }
                    2826   ; }
                    2827   ; #endif
                    2828   ; /*$PAGE*/
                    2829   ; /*
                    2830   ; *********************************************************************************************************
                    2831   ; *                         MAKE TASK WAIT FOR ANY OF MULTIPLE EVENTS TO OCCUR
                    2832   ; *
                    2833   ; * Description: This function is called by other uC/OS-II services to suspend a task because any one of
                    2834   ; *              multiple events has not occurred.
                    2835   ; *
                    2836   ; * Arguments  : pevents_wait     is a pointer to an array of event control blocks, NULL-terminated, for
                    2837   ; *                               which the task will be waiting for.
                    2838   ; *
                    2839   ; * Returns    : none.
                    2840   ; *
                    2841   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2842   ; *********************************************************************************************************
                    2843   ; */
                    2844   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    2845   ; void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
                    2846   ; {
                    2847   _OS_EventTaskWaitMulti:
00000F80  4E56 0000 2848          link      A6,#0
00000F84  48E7 3820 2849          movem.l   D2/D3/D4/A2,-(A7)
00000F88  45F9 0080 2850          lea       _OSTCBCur.L,A2
00000F8C  0360      
                    2851   ; OS_EVENT **pevents;
                    2852   ; OS_EVENT  *pevent;
                    2853   ; INT8U      y;
                    2854   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
00000F8E  2052      2855          move.l    (A2),A0
00000F90  42A8 001C 2856          clr.l     28(A0)
                    2857   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
00000F94  2052      2858          move.l    (A2),A0
00000F96  216E 0008 2859          move.l    8(A6),32(A0)
00000F9A  0020      
                    2860   ; pevents =  pevents_wait;
00000F9C  262E 0008 2861          move.l    8(A6),D3
                    2862   ; pevent  = *pevents;
00000FA0  2043      2863          move.l    D3,A0
00000FA2  2410      2864          move.l    (A0),D2
                    2865   ; while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
                    2866   OS_EventTaskWaitMulti_1:
00000FA4  4A82      2867          tst.l     D2
00000FA6  6700 0030 2868          beq       OS_EventTaskWaitMulti_3
                    2869   ; pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
00000FAA  2042      2870          move.l    D2,A0
00000FAC  2252      2871          move.l    (A2),A1
00000FAE  1029 0036 2872          move.b    54(A1),D0
00000FB2  C0BC 0000 2873          and.l     #255,D0
00000FB6  00FF      
00000FB8  D1C0      2874          add.l     D0,A0
00000FBA  2252      2875          move.l    (A2),A1
00000FBC  1029 0037 2876          move.b    55(A1),D0
00000FC0  8128 000A 2877          or.b      D0,10(A0)
                    2878   ; pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
00000FC4  2042      2879          move.l    D2,A0
00000FC6  2252      2880          move.l    (A2),A1
00000FC8  1029 0038 2881          move.b    56(A1),D0
00000FCC  8128 0008 2882          or.b      D0,8(A0)
                    2883   ; pevents++;
00000FD0  5883      2884          addq.l    #4,D3
                    2885   ; pevent = *pevents;
00000FD2  2043      2886          move.l    D3,A0
00000FD4  2410      2887          move.l    (A0),D2
00000FD6  60CC      2888          bra       OS_EventTaskWaitMulti_1
                    2889   OS_EventTaskWaitMulti_3:
                    2890   ; }
                    2891   ; y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
00000FD8  2052      2892          move.l    (A2),A0
00000FDA  1828 0036 2893          move.b    54(A0),D4
                    2894   ; OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00000FDE  C8BC 0000 2895          and.l     #255,D4
00000FE2  00FF      
00000FE4  41F9 0080 2896          lea       _OSRdyTbl.L,A0
00000FE8  0250      
00000FEA  2252      2897          move.l    (A2),A1
00000FEC  1029 0037 2898          move.b    55(A1),D0
00000FF0  4600      2899          not.b     D0
00000FF2  C130 4800 2900          and.b     D0,0(A0,D4.L)
                    2901   ; if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
00000FF6  C8BC 0000 2902          and.l     #255,D4
00000FFA  00FF      
00000FFC  41F9 0080 2903          lea       _OSRdyTbl.L,A0
00001000  0250      
00001002  1030 4800 2904          move.b    0(A0,D4.L),D0
00001006  660E      2905          bne.s     OS_EventTaskWaitMulti_4
                    2906   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00001008  2052      2907          move.l    (A2),A0
0000100A  1028 0038 2908          move.b    56(A0),D0
0000100E  4600      2909          not.b     D0
00001010  C139 0080 2910          and.b     D0,_OSRdyGrp.L
00001014  024E      
                    2911   OS_EventTaskWaitMulti_4:
00001016  4CDF 041C 2912          movem.l   (A7)+,D2/D3/D4/A2
0000101A  4E5E      2913          unlk      A6
0000101C  4E75      2914          rts
                    2915   ; }
                    2916   ; }
                    2917   ; #endif
                    2918   ; /*$PAGE*/
                    2919   ; /*
                    2920   ; *********************************************************************************************************
                    2921   ; *                                  REMOVE TASK FROM EVENT WAIT LIST
                    2922   ; *
                    2923   ; * Description: Remove a task from an event's wait list.
                    2924   ; *
                    2925   ; * Arguments  : ptcb     is a pointer to the task to remove.
                    2926   ; *
                    2927   ; *              pevent   is a pointer to the event control block.
                    2928   ; *
                    2929   ; * Returns    : none
                    2930   ; *
                    2931   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2932   ; *********************************************************************************************************
                    2933   ; */
                    2934   ; #if (OS_EVENT_EN)
                    2935   ; void  OS_EventTaskRemove (OS_TCB   *ptcb,
                    2936   ; OS_EVENT *pevent)
                    2937   ; {
                    2938   _OS_EventTaskRemove:
0000101E  4E56 0000 2939          link      A6,#0
00001022  48E7 3800 2940          movem.l   D2/D3/D4,-(A7)
00001026  242E 000C 2941          move.l    12(A6),D2
0000102A  262E 0008 2942          move.l    8(A6),D3
                    2943   ; INT8U  y;
                    2944   ; y                       =  ptcb->OSTCBY;
0000102E  2043      2945          move.l    D3,A0
00001030  1828 0036 2946          move.b    54(A0),D4
                    2947   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
00001034  2042      2948          move.l    D2,A0
00001036  C8BC 0000 2949          and.l     #255,D4
0000103A  00FF      
0000103C  D1C4      2950          add.l     D4,A0
0000103E  2243      2951          move.l    D3,A1
00001040  1029 0037 2952          move.b    55(A1),D0
00001044  4600      2953          not.b     D0
00001046  C128 000A 2954          and.b     D0,10(A0)
                    2955   ; if (pevent->OSEventTbl[y] == 0u) {
0000104A  2042      2956          move.l    D2,A0
0000104C  C8BC 0000 2957          and.l     #255,D4
00001050  00FF      
00001052  D1C4      2958          add.l     D4,A0
00001054  1028 000A 2959          move.b    10(A0),D0
00001058  660E      2960          bne.s     OS_EventTaskRemove_1
                    2961   ; pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
0000105A  2042      2962          move.l    D2,A0
0000105C  2243      2963          move.l    D3,A1
0000105E  1029 0038 2964          move.b    56(A1),D0
00001062  4600      2965          not.b     D0
00001064  C128 0008 2966          and.b     D0,8(A0)
                    2967   OS_EventTaskRemove_1:
00001068  4CDF 001C 2968          movem.l   (A7)+,D2/D3/D4
0000106C  4E5E      2969          unlk      A6
0000106E  4E75      2970          rts
                    2971   ; }
                    2972   ; }
                    2973   ; #endif
                    2974   ; /*$PAGE*/
                    2975   ; /*
                    2976   ; *********************************************************************************************************
                    2977   ; *                             REMOVE TASK FROM MULTIPLE EVENTS WAIT LISTS
                    2978   ; *
                    2979   ; * Description: Remove a task from multiple events' wait lists.
                    2980   ; *
                    2981   ; * Arguments  : ptcb             is a pointer to the task to remove.
                    2982   ; *
                    2983   ; *              pevents_multi    is a pointer to the array of event control blocks, NULL-terminated.
                    2984   ; *
                    2985   ; * Returns    : none
                    2986   ; *
                    2987   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    2988   ; *********************************************************************************************************
                    2989   ; */
                    2990   ; #if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0u))
                    2991   ; void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                    2992   ; OS_EVENT **pevents_multi)
                    2993   ; {
                    2994   _OS_EventTaskRemoveMulti:
00001070  4E56 FFFC 2995          link      A6,#-4
00001074  48E7 3C00 2996          movem.l   D2/D3/D4/D5,-(A7)
00001078  282E 0008 2997          move.l    8(A6),D4
                    2998   ; OS_EVENT **pevents;
                    2999   ; OS_EVENT  *pevent;
                    3000   ; INT8U      y;
                    3001   ; OS_PRIO    bity;
                    3002   ; OS_PRIO    bitx;
                    3003   ; y       =  ptcb->OSTCBY;
0000107C  2044      3004          move.l    D4,A0
0000107E  1A28 0036 3005          move.b    54(A0),D5
                    3006   ; bity    =  ptcb->OSTCBBitY;
00001082  2044      3007          move.l    D4,A0
00001084  1D68 0038 3008          move.b    56(A0),-2(A6)
00001088  FFFE      
                    3009   ; bitx    =  ptcb->OSTCBBitX;
0000108A  2044      3010          move.l    D4,A0
0000108C  1D68 0037 3011          move.b    55(A0),-1(A6)
00001090  FFFF      
                    3012   ; pevents =  pevents_multi;
00001092  262E 000C 3013          move.l    12(A6),D3
                    3014   ; pevent  = *pevents;
00001096  2043      3015          move.l    D3,A0
00001098  2410      3016          move.l    (A0),D2
                    3017   ; while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
                    3018   OS_EventTaskRemoveMulti_1:
0000109A  4A82      3019          tst.l     D2
0000109C  6700 003A 3020          beq       OS_EventTaskRemoveMulti_3
                    3021   ; pevent->OSEventTbl[y]  &= (OS_PRIO)~bitx;
000010A0  2042      3022          move.l    D2,A0
000010A2  CABC 0000 3023          and.l     #255,D5
000010A6  00FF      
000010A8  D1C5      3024          add.l     D5,A0
000010AA  102E FFFF 3025          move.b    -1(A6),D0
000010AE  4600      3026          not.b     D0
000010B0  C128 000A 3027          and.b     D0,10(A0)
                    3028   ; if (pevent->OSEventTbl[y] == 0u) {
000010B4  2042      3029          move.l    D2,A0
000010B6  CABC 0000 3030          and.l     #255,D5
000010BA  00FF      
000010BC  D1C5      3031          add.l     D5,A0
000010BE  1028 000A 3032          move.b    10(A0),D0
000010C2  660C      3033          bne.s     OS_EventTaskRemoveMulti_4
                    3034   ; pevent->OSEventGrp &= (OS_PRIO)~bity;
000010C4  2042      3035          move.l    D2,A0
000010C6  102E FFFE 3036          move.b    -2(A6),D0
000010CA  4600      3037          not.b     D0
000010CC  C128 0008 3038          and.b     D0,8(A0)
                    3039   OS_EventTaskRemoveMulti_4:
                    3040   ; }
                    3041   ; pevents++;
000010D0  5883      3042          addq.l    #4,D3
                    3043   ; pevent = *pevents;
000010D2  2043      3044          move.l    D3,A0
000010D4  2410      3045          move.l    (A0),D2
000010D6  60C2      3046          bra       OS_EventTaskRemoveMulti_1
                    3047   OS_EventTaskRemoveMulti_3:
000010D8  4CDF 003C 3048          movem.l   (A7)+,D2/D3/D4/D5
000010DC  4E5E      3049          unlk      A6
000010DE  4E75      3050          rts
                    3051   ; }
                    3052   ; }
                    3053   ; #endif
                    3054   ; /*$PAGE*/
                    3055   ; /*
                    3056   ; *********************************************************************************************************
                    3057   ; *                             INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
                    3058   ; *
                    3059   ; * Description: This function is called by other uC/OS-II services to initialize the event wait list.
                    3060   ; *
                    3061   ; * Arguments  : pevent    is a pointer to the event control block allocated to the event.
                    3062   ; *
                    3063   ; * Returns    : none
                    3064   ; *
                    3065   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    3066   ; *********************************************************************************************************
                    3067   ; */
                    3068   ; #if (OS_EVENT_EN)
                    3069   ; void  OS_EventWaitListInit (OS_EVENT *pevent)
                    3070   ; {
                    3071   _OS_EventWaitListInit:
000010E0  4E56 0000 3072          link      A6,#0
000010E4  2F02      3073          move.l    D2,-(A7)
                    3074   ; INT8U  i;
                    3075   ; pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
000010E6  206E 0008 3076          move.l    8(A6),A0
000010EA  4228 0008 3077          clr.b     8(A0)
                    3078   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000010EE  4202      3079          clr.b     D2
                    3080   OS_EventWaitListInit_1:
000010F0  0C02 0008 3081          cmp.b     #8,D2
000010F4  6414      3082          bhs.s     OS_EventWaitListInit_3
                    3083   ; pevent->OSEventTbl[i] = 0u;
000010F6  206E 0008 3084          move.l    8(A6),A0
000010FA  C4BC 0000 3085          and.l     #255,D2
000010FE  00FF      
00001100  D1C2      3086          add.l     D2,A0
00001102  4228 000A 3087          clr.b     10(A0)
00001106  5202      3088          addq.b    #1,D2
00001108  60E6      3089          bra       OS_EventWaitListInit_1
                    3090   OS_EventWaitListInit_3:
0000110A  241F      3091          move.l    (A7)+,D2
0000110C  4E5E      3092          unlk      A6
0000110E  4E75      3093          rts
                    3094   ; }
                    3095   ; }
                    3096   ; #endif
                    3097   ; /*$PAGE*/
                    3098   ; /*
                    3099   ; *********************************************************************************************************
                    3100   ; *                                             INITIALIZATION
                    3101   ; *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
                    3102   ; *
                    3103   ; * Description: This function is called by OSInit() to initialize the free list of event control blocks.
                    3104   ; *
                    3105   ; * Arguments  : none
                    3106   ; *
                    3107   ; * Returns    : none
                    3108   ; *********************************************************************************************************
                    3109   ; */
                    3110   ; static  void  OS_InitEventList (void)
                    3111   ; {
                    3112   @ucos_ii_OS_InitEventList:
00001110  4E56 FFF8 3113          link      A6,#-8
00001114  48E7 3020 3114          movem.l   D2/D3/A2,-(A7)
00001118  45F9 0080 3115          lea       _OSEventTbl.L,A2
0000111C  001E      
                    3116   ; #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
                    3117   ; #if (OS_MAX_EVENTS > 1u)
                    3118   ; INT16U     ix;
                    3119   ; INT16U     ix_next;
                    3120   ; OS_EVENT  *pevent1;
                    3121   ; OS_EVENT  *pevent2;
                    3122   ; OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
0000111E  4878 00DC 3123          pea       220
00001122  2F0A      3124          move.l    A2,-(A7)
00001124  4EB9 0000 3125          jsr       _OS_MemClr
00001128  13AC      
0000112A  504F      3126          addq.w    #8,A7
                    3127   ; for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
0000112C  4243      3128          clr.w     D3
                    3129   @ucos_ii_OS_InitEventList_1:
0000112E  0C43 0009 3130          cmp.w     #9,D3
00001132  6400 004E 3131          bhs       @ucos_ii_OS_InitEventList_3
                    3132   ; ix_next = ix + 1u;
00001136  3003      3133          move.w    D3,D0
00001138  5240      3134          addq.w    #1,D0
0000113A  3D40 FFFA 3135          move.w    D0,-6(A6)
                    3136   ; pevent1 = &OSEventTbl[ix];
0000113E  200A      3137          move.l    A2,D0
00001140  C6BC 0000 3138          and.l     #65535,D3
00001144  FFFF      
00001146  2203      3139          move.l    D3,D1
00001148  C3FC 0016 3140          muls      #22,D1
0000114C  D081      3141          add.l     D1,D0
0000114E  2400      3142          move.l    D0,D2
                    3143   ; pevent2 = &OSEventTbl[ix_next];
00001150  200A      3144          move.l    A2,D0
00001152  322E FFFA 3145          move.w    -6(A6),D1
00001156  C2BC 0000 3146          and.l     #65535,D1
0000115A  FFFF      
0000115C  C3FC 0016 3147          muls      #22,D1
00001160  D081      3148          add.l     D1,D0
00001162  2D40 FFFC 3149          move.l    D0,-4(A6)
                    3150   ; pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
00001166  2042      3151          move.l    D2,A0
00001168  4210      3152          clr.b     (A0)
                    3153   ; pevent1->OSEventPtr     = pevent2;
0000116A  2042      3154          move.l    D2,A0
0000116C  216E FFFC 3155          move.l    -4(A6),2(A0)
00001170  0002      
                    3156   ; #if OS_EVENT_NAME_EN > 0u
                    3157   ; pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
00001172  41F9 0000 3158          lea       @ucos_ii_1.L,A0
00001176  5A8E      
00001178  2242      3159          move.l    D2,A1
0000117A  2348 0012 3160          move.l    A0,18(A1)
0000117E  5243      3161          addq.w    #1,D3
00001180  60AC      3162          bra       @ucos_ii_OS_InitEventList_1
                    3163   @ucos_ii_OS_InitEventList_3:
                    3164   ; #endif
                    3165   ; }
                    3166   ; pevent1                         = &OSEventTbl[ix];
00001182  200A      3167          move.l    A2,D0
00001184  C6BC 0000 3168          and.l     #65535,D3
00001188  FFFF      
0000118A  2203      3169          move.l    D3,D1
0000118C  C3FC 0016 3170          muls      #22,D1
00001190  D081      3171          add.l     D1,D0
00001192  2400      3172          move.l    D0,D2
                    3173   ; pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
00001194  2042      3174          move.l    D2,A0
00001196  4210      3175          clr.b     (A0)
                    3176   ; pevent1->OSEventPtr             = (OS_EVENT *)0;
00001198  2042      3177          move.l    D2,A0
0000119A  42A8 0002 3178          clr.l     2(A0)
                    3179   ; #if OS_EVENT_NAME_EN > 0u
                    3180   ; pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
0000119E  41F9 0000 3181          lea       @ucos_ii_1.L,A0
000011A2  5A8E      
000011A4  2242      3182          move.l    D2,A1
000011A6  2348 0012 3183          move.l    A0,18(A1)
                    3184   ; #endif
                    3185   ; OSEventFreeList                 = &OSEventTbl[0];
000011AA  23CA 0080 3186          move.l    A2,_OSEventFreeList.L
000011AE  001A      
000011B0  4CDF 040C 3187          movem.l   (A7)+,D2/D3/A2
000011B4  4E5E      3188          unlk      A6
000011B6  4E75      3189          rts
                    3190   ; #else
                    3191   ; OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
                    3192   ; OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
                    3193   ; OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
                    3194   ; #if OS_EVENT_NAME_EN > 0u
                    3195   ; OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
                    3196   ; #endif
                    3197   ; #endif
                    3198   ; #endif
                    3199   ; }
                    3200   ; /*$PAGE*/
                    3201   ; /*
                    3202   ; *********************************************************************************************************
                    3203   ; *                                             INITIALIZATION
                    3204   ; *                                    INITIALIZE MISCELLANEOUS VARIABLES
                    3205   ; *
                    3206   ; * Description: This function is called by OSInit() to initialize miscellaneous variables.
                    3207   ; *
                    3208   ; * Arguments  : none
                    3209   ; *
                    3210   ; * Returns    : none
                    3211   ; *********************************************************************************************************
                    3212   ; */
                    3213   ; static  void  OS_InitMisc (void)
                    3214   ; {
                    3215   @ucos_ii_OS_InitMisc:
                    3216   ; #if OS_TIME_GET_SET_EN > 0u
                    3217   ; OSTime                    = 0uL;                       /* Clear the 32-bit system clock            */
000011B8  42B9 0080 3218          clr.l     _OSTime.L
000011BC  0CB6      
                    3219   ; #endif
                    3220   ; OSIntNesting              = 0u;                        /* Clear the interrupt nesting counter      */
000011BE  4239 0080 3221          clr.b     _OSIntNesting.L
000011C2  0246      
                    3222   ; OSLockNesting             = 0u;                        /* Clear the scheduling lock counter        */
000011C4  4239 0080 3223          clr.b     _OSLockNesting.L
000011C8  0248      
                    3224   ; OSTaskCtr                 = 0u;                        /* Clear the number of tasks                */
000011CA  4239 0080 3225          clr.b     _OSTaskCtr.L
000011CE  025A      
                    3226   ; OSRunning                 = OS_FALSE;                  /* Indicate that multitasking not started   */
000011D0  4239 0080 3227          clr.b     _OSRunning.L
000011D4  0258      
                    3228   ; OSCtxSwCtr                = 0u;                        /* Clear the context switch counter         */
000011D6  42B9 0080 3229          clr.l     _OSCtxSwCtr.L
000011DA  0016      
                    3230   ; OSIdleCtr                 = 0uL;                       /* Clear the 32-bit idle counter            */
000011DC  42B9 0080 3231          clr.l     _OSIdleCtr.L
000011E0  025C      
                    3232   ; #if OS_TASK_STAT_EN > 0u
                    3233   ; OSIdleCtrRun              = 0uL;
000011E2  42B9 0080 3234          clr.l     _OSIdleCtrRun.L
000011E6  0140      
                    3235   ; OSIdleCtrMax              = 0uL;
000011E8  42B9 0080 3236          clr.l     _OSIdleCtrMax.L
000011EC  013C      
                    3237   ; OSStatRdy                 = OS_FALSE;                  /* Statistic task is not ready              */
000011EE  4239 0080 3238          clr.b     _OSStatRdy.L
000011F2  0144      
                    3239   ; #endif
                    3240   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    3241   ; OSSafetyCriticalStartFlag = OS_FALSE;                  /* Still allow creation of objects          */
                    3242   ; #endif
                    3243   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    3244   ; OSTaskRegNextAvailID      = 0u;                        /* Initialize the task register ID          */
000011F4  4239 0080 3245          clr.b     _OSTaskRegNextAvailID.L
000011F8  0CB4      
000011FA  4E75      3246          rts
                    3247   ; #endif
                    3248   ; }
                    3249   ; /*$PAGE*/
                    3250   ; /*
                    3251   ; *********************************************************************************************************
                    3252   ; *                                             INITIALIZATION
                    3253   ; *                                       INITIALIZE THE READY LIST
                    3254   ; *
                    3255   ; * Description: This function is called by OSInit() to initialize the Ready List.
                    3256   ; *
                    3257   ; * Arguments  : none
                    3258   ; *
                    3259   ; * Returns    : none
                    3260   ; *********************************************************************************************************
                    3261   ; */
                    3262   ; static  void  OS_InitRdyList (void)
                    3263   ; {
                    3264   @ucos_ii_OS_InitRdyList:
000011FC  2F02      3265          move.l    D2,-(A7)
                    3266   ; INT8U  i;
                    3267   ; OSRdyGrp      = 0u;                                    /* Clear the ready list                     */
000011FE  4239 0080 3268          clr.b     _OSRdyGrp.L
00001202  024E      
                    3269   ; for (i = 0u; i < OS_RDY_TBL_SIZE; i++) {
00001204  4202      3270          clr.b     D2
                    3271   @ucos_ii_OS_InitRdyList_1:
00001206  0C02 0008 3272          cmp.b     #8,D2
0000120A  6414      3273          bhs.s     @ucos_ii_OS_InitRdyList_3
                    3274   ; OSRdyTbl[i] = 0u;
0000120C  C4BC 0000 3275          and.l     #255,D2
00001210  00FF      
00001212  41F9 0080 3276          lea       _OSRdyTbl.L,A0
00001216  0250      
00001218  4230 2800 3277          clr.b     0(A0,D2.L)
0000121C  5202      3278          addq.b    #1,D2
0000121E  60E6      3279          bra       @ucos_ii_OS_InitRdyList_1
                    3280   @ucos_ii_OS_InitRdyList_3:
                    3281   ; }
                    3282   ; OSPrioCur     = 0u;
00001220  4239 0080 3283          clr.b     _OSPrioCur.L
00001224  024A      
                    3284   ; OSPrioHighRdy = 0u;
00001226  4239 0080 3285          clr.b     _OSPrioHighRdy.L
0000122A  024C      
                    3286   ; OSTCBHighRdy  = (OS_TCB *)0;
0000122C  42B9 0080 3287          clr.l     _OSTCBHighRdy.L
00001230  0368      
                    3288   ; OSTCBCur      = (OS_TCB *)0;
00001232  42B9 0080 3289          clr.l     _OSTCBCur.L
00001236  0360      
00001238  241F      3290          move.l    (A7)+,D2
0000123A  4E75      3291          rts
                    3292   ; }
                    3293   ; /*$PAGE*/
                    3294   ; /*
                    3295   ; *********************************************************************************************************
                    3296   ; *                                             INITIALIZATION
                    3297   ; *                                         CREATING THE IDLE TASK
                    3298   ; *
                    3299   ; * Description: This function creates the Idle Task.
                    3300   ; *
                    3301   ; * Arguments  : none
                    3302   ; *
                    3303   ; * Returns    : none
                    3304   ; *********************************************************************************************************
                    3305   ; */
                    3306   ; static  void  OS_InitTaskIdle (void)
                    3307   ; {
                    3308   @ucos_ii_OS_InitTaskIdle:
0000123C  4E56 FFFC 3309          link      A6,#-4
                    3310   ; #if OS_TASK_NAME_EN > 0u
                    3311   ; INT8U  err;
                    3312   ; #endif
                    3313   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3314   ; #if OS_STK_GROWTH == 1u
                    3315   ; (void)OSTaskCreateExt(OS_TaskIdle,
00001240  4878 0003 3316          pea       3
00001244  42A7      3317          clr.l     -(A7)
00001246  4878 0080 3318          pea       128
0000124A  4879 0080 3319          pea       _OSTaskIdleStk.L
0000124E  0260      
00001250  4878 FFFF 3320          pea       65535
00001254  4878 003F 3321          pea       63
00001258  41F9 0080 3322          lea       _OSTaskIdleStk.L,A0
0000125C  0260      
0000125E  D0FC 00FE 3323          add.w     #254,A0
00001262  2F08      3324          move.l    A0,-(A7)
00001264  42A7      3325          clr.l     -(A7)
00001266  4879 0000 3326          pea       _OS_TaskIdle.L
0000126A  14C2      
0000126C  4EB9 0000 3327          jsr       _OSTaskCreateExt
00001270  4362      
00001272  DEFC 0024 3328          add.w     #36,A7
00001276  C0BC 0000 3329          and.l     #255,D0
0000127A  00FF      
                    3330   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3331   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Top-Of-Stack                     */
                    3332   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3333   ; OS_TASK_IDLE_ID,
                    3334   ; &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
                    3335   ; OS_TASK_IDLE_STK_SIZE,
                    3336   ; (void *)0,                                 /* No TCB extension                     */
                    3337   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3338   ; #else
                    3339   ; (void)OSTaskCreateExt(OS_TaskIdle,
                    3340   ; (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
                    3341   ; &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
                    3342   ; OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
                    3343   ; OS_TASK_IDLE_ID,
                    3344   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],/* Set Bottom-Of-Stack                  */
                    3345   ; OS_TASK_IDLE_STK_SIZE,
                    3346   ; (void *)0,                                 /* No TCB extension                     */
                    3347   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
                    3348   ; #endif
                    3349   ; #else
                    3350   ; #if OS_STK_GROWTH == 1u
                    3351   ; (void)OSTaskCreate(OS_TaskIdle,
                    3352   ; (void *)0,
                    3353   ; &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1u],
                    3354   ; OS_TASK_IDLE_PRIO);
                    3355   ; #else
                    3356   ; (void)OSTaskCreate(OS_TaskIdle,
                    3357   ; (void *)0,
                    3358   ; &OSTaskIdleStk[0],
                    3359   ; OS_TASK_IDLE_PRIO);
                    3360   ; #endif
                    3361   ; #endif
                    3362   ; #if OS_TASK_NAME_EN > 0u
                    3363   ; OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)(void *)"uC/OS-II Idle", &err);
0000127C  486E FFFF 3364          pea       -1(A6)
00001280  4879 0000 3365          pea       @ucos_ii_2.L
00001284  5A90      
00001286  4878 003F 3366          pea       63
0000128A  4EB9 0000 3367          jsr       _OSTaskNameSet
0000128E  476E      
00001290  DEFC 000C 3368          add.w     #12,A7
00001294  4E5E      3369          unlk      A6
00001296  4E75      3370          rts
                    3371   ; #endif
                    3372   ; }
                    3373   ; /*$PAGE*/
                    3374   ; /*
                    3375   ; *********************************************************************************************************
                    3376   ; *                                             INITIALIZATION
                    3377   ; *                                      CREATING THE STATISTIC TASK
                    3378   ; *
                    3379   ; * Description: This function creates the Statistic Task.
                    3380   ; *
                    3381   ; * Arguments  : none
                    3382   ; *
                    3383   ; * Returns    : none
                    3384   ; *********************************************************************************************************
                    3385   ; */
                    3386   ; #if OS_TASK_STAT_EN > 0u
                    3387   ; static  void  OS_InitTaskStat (void)
                    3388   ; {
                    3389   @ucos_ii_OS_InitTaskStat:
00001298  4E56 FFFC 3390          link      A6,#-4
                    3391   ; #if OS_TASK_NAME_EN > 0u
                    3392   ; INT8U  err;
                    3393   ; #endif
                    3394   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    3395   ; #if OS_STK_GROWTH == 1u
                    3396   ; (void)OSTaskCreateExt(OS_TaskStat,
0000129C  4878 0003 3397          pea       3
000012A0  42A7      3398          clr.l     -(A7)
000012A2  4878 0080 3399          pea       128
000012A6  4879 0080 3400          pea       _OSTaskStatStk.L
000012AA  0146      
000012AC  4878 FFFE 3401          pea       65534
000012B0  4878 003E 3402          pea       62
000012B4  41F9 0080 3403          lea       _OSTaskStatStk.L,A0
000012B8  0146      
000012BA  D0FC 00FE 3404          add.w     #254,A0
000012BE  2F08      3405          move.l    A0,-(A7)
000012C0  42A7      3406          clr.l     -(A7)
000012C2  4879 0000 3407          pea       _OS_TaskStat.L
000012C6  14DA      
000012C8  4EB9 0000 3408          jsr       _OSTaskCreateExt
000012CC  4362      
000012CE  DEFC 0024 3409          add.w     #36,A7
000012D2  C0BC 0000 3410          and.l     #255,D0
000012D6  00FF      
                    3411   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3412   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Top-Of-Stack               */
                    3413   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3414   ; OS_TASK_STAT_ID,
                    3415   ; &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
                    3416   ; OS_TASK_STAT_STK_SIZE,
                    3417   ; (void *)0,                                   /* No TCB extension               */
                    3418   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3419   ; #else
                    3420   ; (void)OSTaskCreateExt(OS_TaskStat,
                    3421   ; (void *)0,                                   /* No args passed to OS_TaskStat()*/
                    3422   ; &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
                    3423   ; OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
                    3424   ; OS_TASK_STAT_ID,
                    3425   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],  /* Set Bottom-Of-Stack            */
                    3426   ; OS_TASK_STAT_STK_SIZE,
                    3427   ; (void *)0,                                   /* No TCB extension               */
                    3428   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
                    3429   ; #endif
                    3430   ; #else
                    3431   ; #if OS_STK_GROWTH == 1u
                    3432   ; (void)OSTaskCreate(OS_TaskStat,
                    3433   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3434   ; &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1u],     /* Set Top-Of-Stack               */
                    3435   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3436   ; #else
                    3437   ; (void)OSTaskCreate(OS_TaskStat,
                    3438   ; (void *)0,                                      /* No args passed to OS_TaskStat()*/
                    3439   ; &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
                    3440   ; OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
                    3441   ; #endif
                    3442   ; #endif
                    3443   ; #if OS_TASK_NAME_EN > 0u
                    3444   ; OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)(void *)"uC/OS-II Stat", &err);
000012D8  486E FFFF 3445          pea       -1(A6)
000012DC  4879 0000 3446          pea       @ucos_ii_3.L
000012E0  5A9E      
000012E2  4878 003E 3447          pea       62
000012E6  4EB9 0000 3448          jsr       _OSTaskNameSet
000012EA  476E      
000012EC  DEFC 000C 3449          add.w     #12,A7
000012F0  4E5E      3450          unlk      A6
000012F2  4E75      3451          rts
                    3452   ; #endif
                    3453   ; }
                    3454   ; #endif
                    3455   ; /*$PAGE*/
                    3456   ; /*
                    3457   ; *********************************************************************************************************
                    3458   ; *                                             INITIALIZATION
                    3459   ; *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
                    3460   ; *
                    3461   ; * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
                    3462   ; *
                    3463   ; * Arguments  : none
                    3464   ; *
                    3465   ; * Returns    : none
                    3466   ; *********************************************************************************************************
                    3467   ; */
                    3468   ; static  void  OS_InitTCBList (void)
                    3469   ; {
                    3470   @ucos_ii_OS_InitTCBList:
000012F4  4E56 FFF8 3471          link      A6,#-8
000012F8  48E7 3020 3472          movem.l   D2/D3/A2,-(A7)
000012FC  45F9 0080 3473          lea       _OSTCBTbl.L,A2
00001300  0470      
                    3474   ; INT8U    ix;
                    3475   ; INT8U    ix_next;
                    3476   ; OS_TCB  *ptcb1;
                    3477   ; OS_TCB  *ptcb2;
                    3478   ; OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
00001302  4878 0764 3479          pea       1892
00001306  2F0A      3480          move.l    A2,-(A7)
00001308  4EB9 0000 3481          jsr       _OS_MemClr
0000130C  13AC      
0000130E  504F      3482          addq.w    #8,A7
                    3483   ; OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00001310  4878 0100 3484          pea       256
00001314  4879 0080 3485          pea       _OSTCBPrioTbl.L
00001318  0370      
0000131A  4EB9 0000 3486          jsr       _OS_MemClr
0000131E  13AC      
00001320  504F      3487          addq.w    #8,A7
                    3488   ; for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
00001322  4203      3489          clr.b     D3
                    3490   @ucos_ii_OS_InitTCBList_1:
00001324  0C03 0015 3491          cmp.b     #21,D3
00001328  6400 004A 3492          bhs       @ucos_ii_OS_InitTCBList_3
                    3493   ; ix_next =  ix + 1u;
0000132C  7001      3494          moveq     #1,D0
0000132E  D003      3495          add.b     D3,D0
00001330  1D40 FFFB 3496          move.b    D0,-5(A6)
                    3497   ; ptcb1   = &OSTCBTbl[ix];
00001334  200A      3498          move.l    A2,D0
00001336  C6BC 0000 3499          and.l     #255,D3
0000133A  00FF      
0000133C  2203      3500          move.l    D3,D1
0000133E  C3FC 0056 3501          muls      #86,D1
00001342  D081      3502          add.l     D1,D0
00001344  2400      3503          move.l    D0,D2
                    3504   ; ptcb2   = &OSTCBTbl[ix_next];
00001346  200A      3505          move.l    A2,D0
00001348  122E FFFB 3506          move.b    -5(A6),D1
0000134C  C2BC 0000 3507          and.l     #255,D1
00001350  00FF      
00001352  C3FC 0056 3508          muls      #86,D1
00001356  D081      3509          add.l     D1,D0
00001358  2D40 FFFC 3510          move.l    D0,-4(A6)
                    3511   ; ptcb1->OSTCBNext = ptcb2;
0000135C  2042      3512          move.l    D2,A0
0000135E  216E FFFC 3513          move.l    -4(A6),20(A0)
00001362  0014      
                    3514   ; #if OS_TASK_NAME_EN > 0u
                    3515   ; ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
00001364  41F9 0000 3516          lea       @ucos_ii_1.L,A0
00001368  5A8E      
0000136A  2242      3517          move.l    D2,A1
0000136C  2348 004E 3518          move.l    A0,78(A1)
00001370  5203      3519          addq.b    #1,D3
00001372  60B0      3520          bra       @ucos_ii_OS_InitTCBList_1
                    3521   @ucos_ii_OS_InitTCBList_3:
                    3522   ; #endif
                    3523   ; }
                    3524   ; ptcb1                   = &OSTCBTbl[ix];
00001374  200A      3525          move.l    A2,D0
00001376  C6BC 0000 3526          and.l     #255,D3
0000137A  00FF      
0000137C  2203      3527          move.l    D3,D1
0000137E  C3FC 0056 3528          muls      #86,D1
00001382  D081      3529          add.l     D1,D0
00001384  2400      3530          move.l    D0,D2
                    3531   ; ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
00001386  2042      3532          move.l    D2,A0
00001388  42A8 0014 3533          clr.l     20(A0)
                    3534   ; #if OS_TASK_NAME_EN > 0u
                    3535   ; ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
0000138C  41F9 0000 3536          lea       @ucos_ii_1.L,A0
00001390  5A8E      
00001392  2242      3537          move.l    D2,A1
00001394  2348 004E 3538          move.l    A0,78(A1)
                    3539   ; #endif
                    3540   ; OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
00001398  42B9 0080 3541          clr.l     _OSTCBList.L
0000139C  036C      
                    3542   ; OSTCBFreeList           = &OSTCBTbl[0];
0000139E  23CA 0080 3543          move.l    A2,_OSTCBFreeList.L
000013A2  0364      
000013A4  4CDF 040C 3544          movem.l   (A7)+,D2/D3/A2
000013A8  4E5E      3545          unlk      A6
000013AA  4E75      3546          rts
                    3547   ; }
                    3548   ; /*$PAGE*/
                    3549   ; /*
                    3550   ; *********************************************************************************************************
                    3551   ; *                                      CLEAR A SECTION OF MEMORY
                    3552   ; *
                    3553   ; * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
                    3554   ; *
                    3555   ; * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
                    3556   ; *
                    3557   ; *              size     is the number of bytes to clear.
                    3558   ; *
                    3559   ; * Returns    : none
                    3560   ; *
                    3561   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3562   ; *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
                    3563   ; *                 of the uses of this function gets close to this limit.
                    3564   ; *              3) The clear is done one byte at a time since this will work on any processor irrespective
                    3565   ; *                 of the alignment of the destination.
                    3566   ; *********************************************************************************************************
                    3567   ; */
                    3568   ; void  OS_MemClr (INT8U  *pdest,
                    3569   ; INT16U  size)
                    3570   ; {
                    3571   _OS_MemClr:
000013AC  4E56 0000 3572          link      A6,#0
                    3573   ; while (size > 0u) {
                    3574   OS_MemClr_1:
000013B0  302E 000E 3575          move.w    14(A6),D0
000013B4  0C40 0000 3576          cmp.w     #0,D0
000013B8  6310      3577          bls.s     OS_MemClr_3
                    3578   ; *pdest++ = (INT8U)0;
000013BA  206E 0008 3579          move.l    8(A6),A0
000013BE  52AE 0008 3580          addq.l    #1,8(A6)
000013C2  4210      3581          clr.b     (A0)
                    3582   ; size--;
000013C4  536E 000E 3583          subq.w    #1,14(A6)
000013C8  60E6      3584          bra       OS_MemClr_1
                    3585   OS_MemClr_3:
000013CA  4E5E      3586          unlk      A6
000013CC  4E75      3587          rts
                    3588   ; }
                    3589   ; }
                    3590   ; /*$PAGE*/
                    3591   ; /*
                    3592   ; *********************************************************************************************************
                    3593   ; *                                       COPY A BLOCK OF MEMORY
                    3594   ; *
                    3595   ; * Description: This function is called by other uC/OS-II services to copy a block of memory from one
                    3596   ; *              location to another.
                    3597   ; *
                    3598   ; * Arguments  : pdest    is a pointer to the 'destination' memory block
                    3599   ; *
                    3600   ; *              psrc     is a pointer to the 'source'      memory block
                    3601   ; *
                    3602   ; *              size     is the number of bytes to copy.
                    3603   ; *
                    3604   ; * Returns    : none
                    3605   ; *
                    3606   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
                    3607   ; *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
                    3608   ; *                 is not a situation that will happen.
                    3609   ; *              2) Note that we can only copy up to 64K bytes of RAM
                    3610   ; *              3) The copy is done one byte at a time since this will work on any processor irrespective
                    3611   ; *                 of the alignment of the source and destination.
                    3612   ; *********************************************************************************************************
                    3613   ; */
                    3614   ; void  OS_MemCopy (INT8U  *pdest,
                    3615   ; INT8U  *psrc,
                    3616   ; INT16U  size)
                    3617   ; {
                    3618   _OS_MemCopy:
000013CE  4E56 0000 3619          link      A6,#0
                    3620   ; while (size > 0u) {
                    3621   OS_MemCopy_1:
000013D2  302E 0012 3622          move.w    18(A6),D0
000013D6  0C40 0000 3623          cmp.w     #0,D0
000013DA  6318      3624          bls.s     OS_MemCopy_3
                    3625   ; *pdest++ = *psrc++;
000013DC  206E 000C 3626          move.l    12(A6),A0
000013E0  52AE 000C 3627          addq.l    #1,12(A6)
000013E4  226E 0008 3628          move.l    8(A6),A1
000013E8  52AE 0008 3629          addq.l    #1,8(A6)
000013EC  1290      3630          move.b    (A0),(A1)
                    3631   ; size--;
000013EE  536E 0012 3632          subq.w    #1,18(A6)
000013F2  60DE      3633          bra       OS_MemCopy_1
                    3634   OS_MemCopy_3:
000013F4  4E5E      3635          unlk      A6
000013F6  4E75      3636          rts
                    3637   ; }
                    3638   ; }
                    3639   ; /*$PAGE*/
                    3640   ; /*
                    3641   ; *********************************************************************************************************
                    3642   ; *                                              SCHEDULER
                    3643   ; *
                    3644   ; * Description: This function is called by other uC/OS-II services to determine whether a new, high
                    3645   ; *              priority task has been made ready to run.  This function is invoked by TASK level code
                    3646   ; *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
                    3647   ; *
                    3648   ; * Arguments  : none
                    3649   ; *
                    3650   ; * Returns    : none
                    3651   ; *
                    3652   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3653   ; *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
                    3654   ; *********************************************************************************************************
                    3655   ; */
                    3656   ; void  OS_Sched (void)
                    3657   ; {
                    3658   _OS_Sched:
                    3659   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    3660   ; OS_CPU_SR  cpu_sr = 0u;
                    3661   ; #endif
                    3662   ; OS_ENTER_CRITICAL();
000013F8  40E7      3663          dc.w      16615
000013FA  007C      3664          dc.w      124
000013FC  0700      3665          dc.w      1792
                    3666   ; if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
000013FE  1039 0080 3667          move.b    _OSIntNesting.L,D0
00001402  0246      
00001404  6600 0052 3668          bne       OS_Sched_5
                    3669   ; if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
00001408  1039 0080 3670          move.b    _OSLockNesting.L,D0
0000140C  0248      
0000140E  6648      3671          bne.s     OS_Sched_5
                    3672   ; OS_SchedNew();
00001410  4EB9 0000 3673          jsr       @ucos_ii_OS_SchedNew
00001414  145C      
                    3674   ; OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
00001416  1039 0080 3675          move.b    _OSPrioHighRdy.L,D0
0000141A  024C      
0000141C  C0BC 0000 3676          and.l     #255,D0
00001420  00FF      
00001422  E588      3677          lsl.l     #2,D0
00001424  41F9 0080 3678          lea       _OSTCBPrioTbl.L,A0
00001428  0370      
0000142A  23F0 0800 3679          move.l    0(A0,D0.L),_OSTCBHighRdy.L
0000142E  0080 0368 
                    3680   ; if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00001432  1039 0080 3681          move.b    _OSPrioHighRdy.L,D0
00001436  024C      
00001438  B039 0080 3682          cmp.b     _OSPrioCur.L,D0
0000143C  024A      
0000143E  6718      3683          beq.s     OS_Sched_5
                    3684   ; #if OS_TASK_PROFILE_EN > 0u
                    3685   ; OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
00001440  2039 0080 3686          move.l    _OSTCBHighRdy.L,D0
00001444  0368      
00001446  0680 0000 3687          add.l     #58,D0
0000144A  003A      
0000144C  2040      3688          move.l    D0,A0
0000144E  5290      3689          addq.l    #1,(A0)
                    3690   ; #endif
                    3691   ; OSCtxSwCtr++;                          /* Increment context switch counter             */
00001450  52B9 0080 3692          addq.l    #1,_OSCtxSwCtr.L
00001454  0016      
                    3693   ; OS_TASK_SW();                          /* Perform a context switch                     */
00001456  4E40      3694          trap      #0
                    3695   OS_Sched_5:
                    3696   ; }
                    3697   ; }
                    3698   ; }
                    3699   ; OS_EXIT_CRITICAL();
00001458  46DF      3700          dc.w      18143
0000145A  4E75      3701          rts
                    3702   ; }
                    3703   ; /*
                    3704   ; *********************************************************************************************************
                    3705   ; *                               FIND HIGHEST PRIORITY TASK READY TO RUN
                    3706   ; *
                    3707   ; * Description: This function is called by other uC/OS-II services to determine the highest priority task
                    3708   ; *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
                    3709   ; *
                    3710   ; * Arguments  : none
                    3711   ; *
                    3712   ; * Returns    : none
                    3713   ; *
                    3714   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3715   ; *              2) Interrupts are assumed to be disabled when this function is called.
                    3716   ; *********************************************************************************************************
                    3717   ; */
                    3718   ; static  void  OS_SchedNew (void)
                    3719   ; {
                    3720   @ucos_ii_OS_SchedNew:
0000145C  2F02      3721          move.l    D2,-(A7)
                    3722   ; #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
                    3723   ; INT8U   y;
                    3724   ; y             = OSUnMapTbl[OSRdyGrp];
0000145E  1039 0080 3725          move.b    _OSRdyGrp.L,D0
00001462  024E      
00001464  C0BC 0000 3726          and.l     #255,D0
00001468  00FF      
0000146A  41F9 0000 3727          lea       _OSUnMapTbl.L,A0
0000146E  5AE0      
00001470  1430 0800 3728          move.b    0(A0,D0.L),D2
                    3729   ; OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
00001474  1002      3730          move.b    D2,D0
00001476  E708      3731          lsl.b     #3,D0
00001478  C4BC 0000 3732          and.l     #255,D2
0000147C  00FF      
0000147E  41F9 0080 3733          lea       _OSRdyTbl.L,A0
00001482  0250      
00001484  1230 2800 3734          move.b    0(A0,D2.L),D1
00001488  C2BC 0000 3735          and.l     #255,D1
0000148C  00FF      
0000148E  41F9 0000 3736          lea       _OSUnMapTbl.L,A0
00001492  5AE0      
00001494  D030 1800 3737          add.b     0(A0,D1.L),D0
00001498  13C0 0080 3738          move.b    D0,_OSPrioHighRdy.L
0000149C  024C      
0000149E  241F      3739          move.l    (A7)+,D2
000014A0  4E75      3740          rts
                    3741   ; #else                                            /* We support up to 256 tasks                         */
                    3742   ; INT8U     y;
                    3743   ; OS_PRIO  *ptbl;
                    3744   ; if ((OSRdyGrp & 0xFFu) != 0u) {
                    3745   ; y = OSUnMapTbl[OSRdyGrp & 0xFFu];
                    3746   ; } else {
                    3747   ; y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
                    3748   ; }
                    3749   ; ptbl = &OSRdyTbl[y];
                    3750   ; if ((*ptbl & 0xFFu) != 0u) {
                    3751   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
                    3752   ; } else {
                    3753   ; OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
                    3754   ; }
                    3755   ; #endif
                    3756   ; }
                    3757   ; /*$PAGE*/
                    3758   ; /*
                    3759   ; *********************************************************************************************************
                    3760   ; *                               DETERMINE THE LENGTH OF AN ASCII STRING
                    3761   ; *
                    3762   ; * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
                    3763   ; *              (excluding the NUL character).
                    3764   ; *
                    3765   ; * Arguments  : psrc     is a pointer to the string for which we need to know the size.
                    3766   ; *
                    3767   ; * Returns    : The size of the string (excluding the NUL terminating character)
                    3768   ; *
                    3769   ; * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
                    3770   ; *              2) The string to check must be less than 255 characters long.
                    3771   ; *********************************************************************************************************
                    3772   ; */
                    3773   ; #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
                    3774   ; INT8U  OS_StrLen (INT8U *psrc)
                    3775   ; {
                    3776   _OS_StrLen:
000014A2  4E56 0000 3777          link      A6,#0
000014A6  2F02      3778          move.l    D2,-(A7)
                    3779   ; INT8U  len;
                    3780   ; #if OS_ARG_CHK_EN > 0u
                    3781   ; if (psrc == (INT8U *)0) {
                    3782   ; return (0u);
                    3783   ; }
                    3784   ; #endif
                    3785   ; len = 0u;
000014A8  4202      3786          clr.b     D2
                    3787   ; while (*psrc != OS_ASCII_NUL) {
                    3788   OS_StrLen_1:
000014AA  206E 0008 3789          move.l    8(A6),A0
000014AE  1010      3790          move.b    (A0),D0
000014B0  6708      3791          beq.s     OS_StrLen_3
                    3792   ; psrc++;
000014B2  52AE 0008 3793          addq.l    #1,8(A6)
                    3794   ; len++;
000014B6  5202      3795          addq.b    #1,D2
000014B8  60F0      3796          bra       OS_StrLen_1
                    3797   OS_StrLen_3:
                    3798   ; }
                    3799   ; return (len);
000014BA  1002      3800          move.b    D2,D0
000014BC  241F      3801          move.l    (A7)+,D2
000014BE  4E5E      3802          unlk      A6
000014C0  4E75      3803          rts
                    3804   ; }
                    3805   ; #endif
                    3806   ; /*$PAGE*/
                    3807   ; /*
                    3808   ; *********************************************************************************************************
                    3809   ; *                                              IDLE TASK
                    3810   ; *
                    3811   ; * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
                    3812   ; *              executes because they are ALL waiting for event(s) to occur.
                    3813   ; *
                    3814   ; * Arguments  : none
                    3815   ; *
                    3816   ; * Returns    : none
                    3817   ; *
                    3818   ; * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
                    3819   ; *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
                    3820   ; *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
                    3821   ; *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
                    3822   ; *                 interrupts.
                    3823   ; *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
                    3824   ; *                 power.
                    3825   ; *********************************************************************************************************
                    3826   ; */
                    3827   ; void  OS_TaskIdle (void *p_arg)
                    3828   ; {
                    3829   _OS_TaskIdle:
000014C2  4E56 0000 3830          link      A6,#0
                    3831   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    3832   ; OS_CPU_SR  cpu_sr = 0u;
                    3833   ; #endif
                    3834   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    3835   ; for (;;) {
                    3836   OS_TaskIdle_1:
                    3837   ; OS_ENTER_CRITICAL();
000014C6  40E7      3838          dc.w      16615
000014C8  007C      3839          dc.w      124
000014CA  0700      3840          dc.w      1792
                    3841   ; OSIdleCtr++;
000014CC  52B9 0080 3842          addq.l    #1,_OSIdleCtr.L
000014D0  025C      
                    3843   ; OS_EXIT_CRITICAL();
000014D2  46DF      3844          dc.w      18143
                    3845   ; OSTaskIdleHook();                        /* Call user definable HOOK                           */
000014D4  4EB8 06EE 3846          jsr       _OSTaskIdleHook
000014D8  60EC      3847          bra       OS_TaskIdle_1
                    3848   ; }
                    3849   ; }
                    3850   ; /*$PAGE*/
                    3851   ; /*
                    3852   ; *********************************************************************************************************
                    3853   ; *                                           STATISTICS TASK
                    3854   ; *
                    3855   ; * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
                    3856   ; *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
                    3857   ; *              CPU usage is determined by:
                    3858   ; *
                    3859   ; *                                          OSIdleCtr
                    3860   ; *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
                    3861   ; *                                         OSIdleCtrMax
                    3862   ; *
                    3863   ; * Arguments  : parg     this pointer is not used at this time.
                    3864   ; *
                    3865   ; * Returns    : none
                    3866   ; *
                    3867   ; * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
                    3868   ; *                 next higher priority, OS_TASK_IDLE_PRIO-1.
                    3869   ; *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
                    3870   ; *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
                    3871   ; *                 maximum value for the idle counter.
                    3872   ; *********************************************************************************************************
                    3873   ; */
                    3874   ; #if OS_TASK_STAT_EN > 0u
                    3875   ; void  OS_TaskStat (void *p_arg)
                    3876   ; {
                    3877   _OS_TaskStat:
000014DA  4E56 0000 3878          link      A6,#0
000014DE  2F0A      3879          move.l    A2,-(A7)
000014E0  45F9 0080 3880          lea       _OSIdleCtrMax.L,A2
000014E4  013C      
                    3881   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    3882   ; OS_CPU_SR  cpu_sr = 0u;
                    3883   ; #endif
                    3884   ; p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
                    3885   ; while (OSStatRdy == OS_FALSE) {
                    3886   OS_TaskStat_1:
000014E6  1039 0080 3887          move.b    _OSStatRdy.L,D0
000014EA  0144      
000014EC  660E      3888          bne.s     OS_TaskStat_3
                    3889   ; OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
000014EE  4878 0014 3890          pea       20
000014F2  4EB9 0000 3891          jsr       _OSTimeDly
000014F6  4BF4      
000014F8  584F      3892          addq.w    #4,A7
000014FA  60EA      3893          bra       OS_TaskStat_1
                    3894   OS_TaskStat_3:
                    3895   ; }
                    3896   ; OSIdleCtrMax /= 100uL;
000014FC  2F12      3897          move.l    (A2),-(A7)
000014FE  4878 0064 3898          pea       100
00001502  4EB9 0000 3899          jsr       ULDIV
00001506  59B0      
00001508  2497      3900          move.l    (A7),(A2)
0000150A  504F      3901          addq.w    #8,A7
                    3902   ; if (OSIdleCtrMax == 0uL) {
0000150C  2012      3903          move.l    (A2),D0
0000150E  6618      3904          bne.s     OS_TaskStat_4
                    3905   ; OSCPUUsage = 0u;
00001510  4239 0080 3906          clr.b     _OSCPUUsage.L
00001514  013A      
                    3907   ; #if OS_TASK_SUSPEND_EN > 0u
                    3908   ; (void)OSTaskSuspend(OS_PRIO_SELF);
00001516  4878 00FF 3909          pea       255
0000151A  4EB9 0000 3910          jsr       _OSTaskSuspend
0000151E  496C      
00001520  584F      3911          addq.w    #4,A7
00001522  C0BC 0000 3912          and.l     #255,D0
00001526  00FF      
                    3913   OS_TaskStat_4:
                    3914   ; #else
                    3915   ; for (;;) {
                    3916   ; OSTimeDly(OS_TICKS_PER_SEC);
                    3917   ; }
                    3918   ; #endif
                    3919   ; }
                    3920   ; OS_ENTER_CRITICAL();
00001528  40E7      3921          dc.w      16615
0000152A  007C      3922          dc.w      124
0000152C  0700      3923          dc.w      1792
                    3924   ; OSIdleCtr = OSIdleCtrMax * 100uL;            /* Set initial CPU usage as 0%                        */
0000152E  2F12      3925          move.l    (A2),-(A7)
00001530  4878 0064 3926          pea       100
00001534  4EB9 0000 3927          jsr       ULMUL
00001538  5910      
0000153A  2017      3928          move.l    (A7),D0
0000153C  504F      3929          addq.w    #8,A7
0000153E  23C0 0080 3930          move.l    D0,_OSIdleCtr.L
00001542  025C      
                    3931   ; OS_EXIT_CRITICAL();
00001544  46DF      3932          dc.w      18143
                    3933   ; for (;;) {
                    3934   OS_TaskStat_6:
                    3935   ; OS_ENTER_CRITICAL();
00001546  40E7      3936          dc.w      16615
00001548  007C      3937          dc.w      124
0000154A  0700      3938          dc.w      1792
                    3939   ; OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
0000154C  23F9 0080 3940          move.l    _OSIdleCtr.L,_OSIdleCtrRun.L
00001550  025C 0080 
00001554  0140      
                    3941   ; OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
00001556  42B9 0080 3942          clr.l     _OSIdleCtr.L
0000155A  025C      
                    3943   ; OS_EXIT_CRITICAL();
0000155C  46DF      3944          dc.w      18143
                    3945   ; OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
0000155E  7064      3946          moveq     #100,D0
00001560  2F39 0080 3947          move.l    _OSIdleCtrRun.L,-(A7)
00001564  0140      
00001566  2F12      3948          move.l    (A2),-(A7)
00001568  4EB9 0000 3949          jsr       ULDIV
0000156C  59B0      
0000156E  2217      3950          move.l    (A7),D1
00001570  504F      3951          addq.w    #8,A7
00001572  9081      3952          sub.l     D1,D0
00001574  13C0 0080 3953          move.b    D0,_OSCPUUsage.L
00001578  013A      
                    3954   ; OSTaskStatHook();                        /* Invoke user definable hook                         */
0000157A  4EB8 06F8 3955          jsr       _OSTaskStatHook
                    3956   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    3957   ; OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
0000157E  4EB9 0000 3958          jsr       _OS_TaskStatStkChk
00001582  1592      
                    3959   ; #endif
                    3960   ; OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
00001584  4878 000A 3961          pea       10
00001588  4EB9 0000 3962          jsr       _OSTimeDly
0000158C  4BF4      
0000158E  584F      3963          addq.w    #4,A7
00001590  60B4      3964          bra       OS_TaskStat_6
                    3965   ; }
                    3966   ; }
                    3967   ; #endif
                    3968   ; /*$PAGE*/
                    3969   ; /*
                    3970   ; *********************************************************************************************************
                    3971   ; *                                        CHECK ALL TASK STACKS
                    3972   ; *
                    3973   ; * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
                    3974   ; *
                    3975   ; * Arguments  : none
                    3976   ; *
                    3977   ; * Returns    : none
                    3978   ; *********************************************************************************************************
                    3979   ; */
                    3980   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    3981   ; void  OS_TaskStatStkChk (void)
                    3982   ; {
                    3983   _OS_TaskStatStkChk:
00001592  4E56 FFF4 3984          link      A6,#-12
00001596  48E7 3000 3985          movem.l   D2/D3,-(A7)
                    3986   ; OS_TCB      *ptcb;
                    3987   ; OS_STK_DATA  stk_data;
                    3988   ; INT8U        err;
                    3989   ; INT8U        prio;
                    3990   ; for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
0000159A  4203      3991          clr.b     D3
                    3992   OS_TaskStatStkChk_1:
0000159C  0C03 003F 3993          cmp.b     #63,D3
000015A0  6200 0068 3994          bhi       OS_TaskStatStkChk_3
                    3995   ; err = OSTaskStkChk(prio, &stk_data);
000015A4  486E FFF6 3996          pea       -10(A6)
000015A8  C6BC 0000 3997          and.l     #255,D3
000015AC  00FF      
000015AE  2F03      3998          move.l    D3,-(A7)
000015B0  4EB9 0000 3999          jsr       _OSTaskStkChk
000015B4  48B4      
000015B6  504F      4000          addq.w    #8,A7
000015B8  1D40 FFFF 4001          move.b    D0,-1(A6)
                    4002   ; if (err == OS_ERR_NONE) {
000015BC  102E FFFF 4003          move.b    -1(A6),D0
000015C0  6600 0044 4004          bne       OS_TaskStatStkChk_8
                    4005   ; ptcb = OSTCBPrioTbl[prio];
000015C4  C6BC 0000 4006          and.l     #255,D3
000015C8  00FF      
000015CA  2003      4007          move.l    D3,D0
000015CC  E588      4008          lsl.l     #2,D0
000015CE  41F9 0080 4009          lea       _OSTCBPrioTbl.L,A0
000015D2  0370      
000015D4  2430 0800 4010          move.l    0(A0,D0.L),D2
                    4011   ; if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000015D8  4A82      4012          tst.l     D2
000015DA  672A      4013          beq.s     OS_TaskStatStkChk_8
                    4014   ; if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
000015DC  0C82 0000 4015          cmp.l     #1,D2
000015E0  0001      
000015E2  6722      4016          beq.s     OS_TaskStatStkChk_8
                    4017   ; #if OS_TASK_PROFILE_EN > 0u
                    4018   ; #if OS_STK_GROWTH == 1u
                    4019   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
000015E4  2042      4020          move.l    D2,A0
000015E6  2028 0008 4021          move.l    8(A0),D0
000015EA  2042      4022          move.l    D2,A0
000015EC  2228 000C 4023          move.l    12(A0),D1
000015F0  E389      4024          lsl.l     #1,D1
000015F2  D081      4025          add.l     D1,D0
000015F4  2042      4026          move.l    D2,A0
000015F6  2140 0046 4027          move.l    D0,70(A0)
                    4028   ; #else
                    4029   ; ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    4030   ; #endif
                    4031   ; ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store number of entries used   */
000015FA  41EE FFF6 4032          lea       -10(A6),A0
000015FE  2242      4033          move.l    D2,A1
00001600  2368 0004 4034          move.l    4(A0),74(A1)
00001604  004A      
                    4035   OS_TaskStatStkChk_8:
00001606  5203      4036          addq.b    #1,D3
00001608  6092      4037          bra       OS_TaskStatStkChk_1
                    4038   OS_TaskStatStkChk_3:
0000160A  4CDF 000C 4039          movem.l   (A7)+,D2/D3
0000160E  4E5E      4040          unlk      A6
00001610  4E75      4041          rts
                    4042   ; #endif
                    4043   ; }
                    4044   ; }
                    4045   ; }
                    4046   ; }
                    4047   ; }
                    4048   ; #endif
                    4049   ; /*$PAGE*/
                    4050   ; /*
                    4051   ; *********************************************************************************************************
                    4052   ; *                                           INITIALIZE TCB
                    4053   ; *
                    4054   ; * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
                    4055   ; *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
                    4056   ; *
                    4057   ; * Arguments  : prio          is the priority of the task being created
                    4058   ; *
                    4059   ; *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
                    4060   ; *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
                    4061   ; *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
                    4062   ; *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
                    4063   ; *                            specific.
                    4064   ; *
                    4065   ; *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
                    4066   ; *                            'OSTaskCreate()'.
                    4067   ; *
                    4068   ; *              id            is the task's ID (0..65535)
                    4069   ; *
                    4070   ; *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
                    4071   ; *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
                    4072   ; *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
                    4073   ; *                            units are established by the #define constant OS_STK which is CPU
                    4074   ; *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
                    4075   ; *
                    4076   ; *              pext          is a pointer to a user supplied memory area that is used to extend the task
                    4077   ; *                            control block.  This allows you to store the contents of floating-point
                    4078   ; *                            registers, MMU registers or anything else you could find useful during a
                    4079   ; *                            context switch.  You can even assign a name to each task and store this name
                    4080   ; *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
                    4081   ; *
                    4082   ; *              opt           options as passed to 'OSTaskCreateExt()' or,
                    4083   ; *                            0 if called from 'OSTaskCreate()'.
                    4084   ; *
                    4085   ; * Returns    : OS_ERR_NONE         if the call was successful
                    4086   ; *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
                    4087   ; *                                  be created.
                    4088   ; *
                    4089   ; * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
                    4090   ; *********************************************************************************************************
                    4091   ; */
                    4092   ; INT8U  OS_TCBInit (INT8U    prio,
                    4093   ; OS_STK  *ptos,
                    4094   ; OS_STK  *pbos,
                    4095   ; INT16U   id,
                    4096   ; INT32U   stk_size,
                    4097   ; void    *pext,
                    4098   ; INT16U   opt)
                    4099   ; {
                    4100   _OS_TCBInit:
00001612  4E56 0000 4101          link      A6,#0
00001616  48E7 3820 4102          movem.l   D2/D3/D4/A2,-(A7)
0000161A  45F9 0080 4103          lea       _OSTCBList.L,A2
0000161E  036C      
00001620  182E 000B 4104          move.b    11(A6),D4
00001624  C8BC 0000 4105          and.l     #255,D4
00001628  00FF      
                    4106   ; OS_TCB    *ptcb;
                    4107   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4108   ; OS_CPU_SR  cpu_sr = 0u;
                    4109   ; #endif
                    4110   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    4111   ; INT8U      i;
                    4112   ; #endif
                    4113   ; OS_ENTER_CRITICAL();
0000162A  40E7      4114          dc.w      16615
0000162C  007C      4115          dc.w      124
0000162E  0700      4116          dc.w      1792
                    4117   ; ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
00001630  2439 0080 4118          move.l    _OSTCBFreeList.L,D2
00001634  0364      
                    4119   ; if (ptcb != (OS_TCB *)0) {
00001636  4A82      4120          tst.l     D2
00001638  6700 017A 4121          beq       OS_TCBInit_1
                    4122   ; OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
0000163C  2042      4123          move.l    D2,A0
0000163E  23E8 0014 4124          move.l    20(A0),_OSTCBFreeList.L
00001642  0080 0364 
                    4125   ; OS_EXIT_CRITICAL();
00001646  46DF      4126          dc.w      18143
                    4127   ; ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
00001648  2042      4128          move.l    D2,A0
0000164A  20AE 000C 4129          move.l    12(A6),(A0)
                    4130   ; ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
0000164E  2042      4131          move.l    D2,A0
00001650  1144 0034 4132          move.b    D4,52(A0)
                    4133   ; ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00001654  2042      4134          move.l    D2,A0
00001656  4228 0032 4135          clr.b     50(A0)
                    4136   ; ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
0000165A  2042      4137          move.l    D2,A0
0000165C  4228 0033 4138          clr.b     51(A0)
                    4139   ; ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
00001660  2042      4140          move.l    D2,A0
00001662  42A8 002E 4141          clr.l     46(A0)
                    4142   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    4143   ; ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
00001666  2042      4144          move.l    D2,A0
00001668  216E 001C 4145          move.l    28(A6),4(A0)
0000166C  0004      
                    4146   ; ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
0000166E  2042      4147          move.l    D2,A0
00001670  216E 0018 4148          move.l    24(A6),12(A0)
00001674  000C      
                    4149   ; ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
00001676  2042      4150          move.l    D2,A0
00001678  216E 0010 4151          move.l    16(A6),8(A0)
0000167C  0008      
                    4152   ; ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
0000167E  2042      4153          move.l    D2,A0
00001680  316E 0022 4154          move.w    34(A6),16(A0)
00001684  0010      
                    4155   ; ptcb->OSTCBId            = id;                     /* Store task ID                            */
00001686  2042      4156          move.l    D2,A0
00001688  316E 0016 4157          move.w    22(A6),18(A0)
0000168C  0012      
                    4158   ; #else
                    4159   ; pext                     = pext;                   /* Prevent compiler warning if not used     */
                    4160   ; stk_size                 = stk_size;
                    4161   ; pbos                     = pbos;
                    4162   ; opt                      = opt;
                    4163   ; id                       = id;
                    4164   ; #endif
                    4165   ; #if OS_TASK_DEL_EN > 0u
                    4166   ; ptcb->OSTCBDelReq        = OS_ERR_NONE;
0000168E  2042      4167          move.l    D2,A0
00001690  4228 0039 4168          clr.b     57(A0)
                    4169   ; #endif
                    4170   ; #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
                    4171   ; ptcb->OSTCBY             = (INT8U)(prio >> 3u);
00001694  1004      4172          move.b    D4,D0
00001696  E608      4173          lsr.b     #3,D0
00001698  2042      4174          move.l    D2,A0
0000169A  1140 0036 4175          move.b    D0,54(A0)
                    4176   ; ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
0000169E  1004      4177          move.b    D4,D0
000016A0  C03C 0007 4178          and.b     #7,D0
000016A4  2042      4179          move.l    D2,A0
000016A6  1140 0035 4180          move.b    D0,53(A0)
                    4181   ; #else                                                             /* Pre-compute X, Y                  */
                    4182   ; ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
                    4183   ; ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
                    4184   ; #endif
                    4185   ; /* Pre-compute BitX and BitY         */
                    4186   ; ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
000016AA  7001      4187          moveq     #1,D0
000016AC  2042      4188          move.l    D2,A0
000016AE  1228 0036 4189          move.b    54(A0),D1
000016B2  C2BC 0000 4190          and.l     #255,D1
000016B6  00FF      
000016B8  E3A8      4191          lsl.l     D1,D0
000016BA  2042      4192          move.l    D2,A0
000016BC  1140 0038 4193          move.b    D0,56(A0)
                    4194   ; ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
000016C0  7001      4195          moveq     #1,D0
000016C2  2042      4196          move.l    D2,A0
000016C4  1228 0035 4197          move.b    53(A0),D1
000016C8  C2BC 0000 4198          and.l     #255,D1
000016CC  00FF      
000016CE  E3A8      4199          lsl.l     D1,D0
000016D0  2042      4200          move.l    D2,A0
000016D2  1140 0037 4201          move.b    D0,55(A0)
                    4202   ; #if (OS_EVENT_EN)
                    4203   ; ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
000016D6  2042      4204          move.l    D2,A0
000016D8  42A8 001C 4205          clr.l     28(A0)
                    4206   ; #if (OS_EVENT_MULTI_EN > 0u)
                    4207   ; ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
000016DC  2042      4208          move.l    D2,A0
000016DE  42A8 0020 4209          clr.l     32(A0)
                    4210   ; #endif
                    4211   ; #endif
                    4212   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
                    4213   ; ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
000016E2  2042      4214          move.l    D2,A0
000016E4  42A8 0028 4215          clr.l     40(A0)
                    4216   ; #endif
                    4217   ; #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
                    4218   ; ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
000016E8  2042      4219          move.l    D2,A0
000016EA  42A8 0024 4220          clr.l     36(A0)
                    4221   ; #endif
                    4222   ; #if OS_TASK_PROFILE_EN > 0u
                    4223   ; ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
000016EE  2042      4224          move.l    D2,A0
000016F0  42A8 003A 4225          clr.l     58(A0)
                    4226   ; ptcb->OSTCBCyclesStart = 0uL;
000016F4  2042      4227          move.l    D2,A0
000016F6  42A8 0042 4228          clr.l     66(A0)
                    4229   ; ptcb->OSTCBCyclesTot   = 0uL;
000016FA  2042      4230          move.l    D2,A0
000016FC  42A8 003E 4231          clr.l     62(A0)
                    4232   ; ptcb->OSTCBStkBase     = (OS_STK *)0;
00001700  2042      4233          move.l    D2,A0
00001702  42A8 0046 4234          clr.l     70(A0)
                    4235   ; ptcb->OSTCBStkUsed     = 0uL;
00001706  2042      4236          move.l    D2,A0
00001708  42A8 004A 4237          clr.l     74(A0)
                    4238   ; #endif
                    4239   ; #if OS_TASK_NAME_EN > 0u
                    4240   ; ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
0000170C  41F9 0000 4241          lea       @ucos_ii_1.L,A0
00001710  5A8E      
00001712  2242      4242          move.l    D2,A1
00001714  2348 004E 4243          move.l    A0,78(A1)
                    4244   ; #endif
                    4245   ; #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
                    4246   ; for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
00001718  4203      4247          clr.b     D3
                    4248   OS_TCBInit_3:
0000171A  0C03 0001 4249          cmp.b     #1,D3
0000171E  6416      4250          bhs.s     OS_TCBInit_5
                    4251   ; ptcb->OSTCBRegTbl[i] = 0u;
00001720  2042      4252          move.l    D2,A0
00001722  C6BC 0000 4253          and.l     #255,D3
00001726  00FF      
00001728  2003      4254          move.l    D3,D0
0000172A  E588      4255          lsl.l     #2,D0
0000172C  D1C0      4256          add.l     D0,A0
0000172E  42A8 0052 4257          clr.l     82(A0)
00001732  5203      4258          addq.b    #1,D3
00001734  60E4      4259          bra       OS_TCBInit_3
                    4260   OS_TCBInit_5:
                    4261   ; }
                    4262   ; #endif
                    4263   ; OSTCBInitHook(ptcb);
00001736  2F02      4264          move.l    D2,-(A7)
00001738  4EB8 0726 4265          jsr       _OSTCBInitHook
0000173C  584F      4266          addq.w    #4,A7
                    4267   ; OS_ENTER_CRITICAL();
0000173E  40E7      4268          dc.w      16615
00001740  007C      4269          dc.w      124
00001742  0700      4270          dc.w      1792
                    4271   ; OSTCBPrioTbl[prio] = ptcb;
00001744  C8BC 0000 4272          and.l     #255,D4
00001748  00FF      
0000174A  2004      4273          move.l    D4,D0
0000174C  E588      4274          lsl.l     #2,D0
0000174E  41F9 0080 4275          lea       _OSTCBPrioTbl.L,A0
00001752  0370      
00001754  2182 0800 4276          move.l    D2,0(A0,D0.L)
                    4277   ; OS_EXIT_CRITICAL();
00001758  46DF      4278          dc.w      18143
                    4279   ; OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
0000175A  2F02      4280          move.l    D2,-(A7)
0000175C  4EB8 06DC 4281          jsr       _OSTaskCreateHook
00001760  584F      4282          addq.w    #4,A7
                    4283   ; OS_ENTER_CRITICAL();
00001762  40E7      4284          dc.w      16615
00001764  007C      4285          dc.w      124
00001766  0700      4286          dc.w      1792
                    4287   ; ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
00001768  2042      4288          move.l    D2,A0
0000176A  2152 0014 4289          move.l    (A2),20(A0)
                    4290   ; ptcb->OSTCBPrev    = (OS_TCB *)0;
0000176E  2042      4291          move.l    D2,A0
00001770  42A8 0018 4292          clr.l     24(A0)
                    4293   ; if (OSTCBList != (OS_TCB *)0) {
00001774  2012      4294          move.l    (A2),D0
00001776  6706      4295          beq.s     OS_TCBInit_6
                    4296   ; OSTCBList->OSTCBPrev = ptcb;
00001778  2052      4297          move.l    (A2),A0
0000177A  2142 0018 4298          move.l    D2,24(A0)
                    4299   OS_TCBInit_6:
                    4300   ; }
                    4301   ; OSTCBList               = ptcb;
0000177E  2482      4302          move.l    D2,(A2)
                    4303   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
00001780  2042      4304          move.l    D2,A0
00001782  1028 0038 4305          move.b    56(A0),D0
00001786  8139 0080 4306          or.b      D0,_OSRdyGrp.L
0000178A  024E      
                    4307   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000178C  2042      4308          move.l    D2,A0
0000178E  1028 0036 4309          move.b    54(A0),D0
00001792  C0BC 0000 4310          and.l     #255,D0
00001796  00FF      
00001798  41F9 0080 4311          lea       _OSRdyTbl.L,A0
0000179C  0250      
0000179E  2242      4312          move.l    D2,A1
000017A0  1229 0037 4313          move.b    55(A1),D1
000017A4  8330 0800 4314          or.b      D1,0(A0,D0.L)
                    4315   ; OSTaskCtr++;                                       /* Increment the #tasks counter             */
000017A8  5239 0080 4316          addq.b    #1,_OSTaskCtr.L
000017AC  025A      
                    4317   ; OS_EXIT_CRITICAL();
000017AE  46DF      4318          dc.w      18143
                    4319   ; return (OS_ERR_NONE);
000017B0  4200      4320          clr.b     D0
000017B2  6004      4321          bra.s     OS_TCBInit_8
                    4322   OS_TCBInit_1:
                    4323   ; }
                    4324   ; OS_EXIT_CRITICAL();
000017B4  46DF      4325          dc.w      18143
                    4326   ; return (OS_ERR_TASK_NO_MORE_TCB);
000017B6  7042      4327          moveq     #66,D0
                    4328   OS_TCBInit_8:
000017B8  4CDF 041C 4329          movem.l   (A7)+,D2/D3/D4/A2
000017BC  4E5E      4330          unlk      A6
000017BE  4E75      4331          rts
                    4332   ; /*
                    4333   ; *********************************************************************************************************
                    4334   ; *                                                uC/OS-II
                    4335   ; *                                          The Real-Time Kernel
                    4336   ; *                                         EVENT FLAG  MANAGEMENT
                    4337   ; *
                    4338   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    4339   ; *                                           All Rights Reserved
                    4340   ; *
                    4341   ; * File    : OS_FLAG.C
                    4342   ; * By      : Jean J. Labrosse
                    4343   ; * Version : V2.92.07
                    4344   ; *
                    4345   ; * LICENSING TERMS:
                    4346   ; * ---------------
                    4347   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    4348   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    4349   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    4350   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    4351   ; * licensing fee.
                    4352   ; *********************************************************************************************************
                    4353   ; */
                    4354   ; #define  MICRIUM_SOURCE
                    4355   ; #ifndef  OS_MASTER_FILE
                    4356   ; #include <ucos_ii.h>
                    4357   ; #endif
                    4358   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    4359   ; /*
                    4360   ; *********************************************************************************************************
                    4361   ; *                                          LOCAL PROTOTYPES
                    4362   ; *********************************************************************************************************
                    4363   ; */
                    4364   ; static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT32U timeout);
                    4365   ; static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy, INT8U pend_stat);
                    4366   ; /*$PAGE*/
                    4367   ; /*
                    4368   ; *********************************************************************************************************
                    4369   ; *                          CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
                    4370   ; *
                    4371   ; * Description: This function is called to check the status of a combination of bits to be set or cleared
                    4372   ; *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
                    4373   ; *              bits to be set/cleared.
                    4374   ; *
                    4375   ; *              This call does not block if the desired flags are not present.
                    4376   ; *
                    4377   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    4378   ; *
                    4379   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    4380   ; *                            The bits you want are specified by setting the corresponding bits in
                    4381   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    4382   ; *                            'flags' would contain 0x03.
                    4383   ; *
                    4384   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    4385   ; *                            to be set/cleared.
                    4386   ; *                            You can specify the following argument:
                    4387   ; *
                    4388   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
                    4389   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
                    4390   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
                    4391   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
                    4392   ; *
                    4393   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    4394   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    4395   ; *                                  the flags that are present, set 'wait_type' to:
                    4396   ; *
                    4397   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    4398   ; *
                    4399   ; *              perr          is a pointer to an error code and can be:
                    4400   ; *                            OS_ERR_NONE               No error
                    4401   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    4402   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    4403   ; *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
                    4404   ; *                                                      group handle.
                    4405   ; *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
                    4406   ; *                                                      available.
                    4407   ; *
                    4408   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    4409   ; *              occurred.
                    4410   ; *
                    4411   ; * Called from: Task or ISR
                    4412   ; *
                    4413   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    4414   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    4415   ; *                 event flags.
                    4416   ; *********************************************************************************************************
                    4417   ; */
                    4418   ; #if OS_FLAG_ACCEPT_EN > 0u
                    4419   ; OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
                    4420   ; OS_FLAGS      flags,
                    4421   ; INT8U         wait_type,
                    4422   ; INT8U        *perr)
                    4423   ; {
                    4424   _OSFlagAccept:
000017C0  4E56 FFFC 4425          link      A6,#-4
000017C4  48E7 3F00 4426          movem.l   D2/D3/D4/D5/D6/D7,-(A7)
000017C8  262E 0008 4427          move.l    8(A6),D3
000017CC  282E 0014 4428          move.l    20(A6),D4
000017D0  3A2E 000E 4429          move.w    14(A6),D5
000017D4  CABC 0000 4430          and.l     #65535,D5
000017D8  FFFF      
000017DA  1E2E 0013 4431          move.b    19(A6),D7
000017DE  CEBC 0000 4432          and.l     #255,D7
000017E2  00FF      
                    4433   ; OS_FLAGS      flags_rdy;
                    4434   ; INT8U         result;
                    4435   ; BOOLEAN       consume;
                    4436   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4437   ; OS_CPU_SR     cpu_sr = 0u;
                    4438   ; #endif
                    4439   ; #ifdef OS_SAFETY_CRITICAL
                    4440   ; if (perr == (INT8U *)0) {
                    4441   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4442   ; return ((OS_FLAGS)0);
                    4443   ; }
                    4444   ; #endif
                    4445   ; #if OS_ARG_CHK_EN > 0u
                    4446   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    4447   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    4448   ; return ((OS_FLAGS)0);
                    4449   ; }
                    4450   ; #endif
                    4451   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
000017E4  2043      4452          move.l    D3,A0
000017E6  1010      4453          move.b    (A0),D0
000017E8  0C00 0005 4454          cmp.b     #5,D0
000017EC  670C      4455          beq.s     OSFlagAccept_1
                    4456   ; *perr = OS_ERR_EVENT_TYPE;
000017EE  2044      4457          move.l    D4,A0
000017F0  10BC 0001 4458          move.b    #1,(A0)
                    4459   ; return ((OS_FLAGS)0);
000017F4  4240      4460          clr.w     D0
000017F6  6000 0100 4461          bra       OSFlagAccept_3
                    4462   OSFlagAccept_1:
                    4463   ; }
                    4464   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
000017FA  1007      4465          move.b    D7,D0
000017FC  C03C 0080 4466          and.b     #128,D0
00001800  1D40 FFFF 4467          move.b    D0,-1(A6)
                    4468   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
00001804  102E FFFF 4469          move.b    -1(A6),D0
00001808  6708      4470          beq.s     OSFlagAccept_4
                    4471   ; wait_type &= (INT8U)~OS_FLAG_CONSUME;
0000180A  CE3C 007F 4472          and.b     #127,D7
                    4473   ; consume    = OS_TRUE;
0000180E  7C01      4474          moveq     #1,D6
00001810  6002      4475          bra.s     OSFlagAccept_5
                    4476   OSFlagAccept_4:
                    4477   ; } else {
                    4478   ; consume    = OS_FALSE;
00001812  4206      4479          clr.b     D6
                    4480   OSFlagAccept_5:
                    4481   ; }
                    4482   ; /*$PAGE*/
                    4483   ; *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
00001814  2044      4484          move.l    D4,A0
00001816  4210      4485          clr.b     (A0)
                    4486   ; OS_ENTER_CRITICAL();
00001818  40E7      4487          dc.w      16615
0000181A  007C      4488          dc.w      124
0000181C  0700      4489          dc.w      1792
                    4490   ; switch (wait_type) {
0000181E  CEBC 0000 4491          and.l     #255,D7
00001822  00FF      
00001824  2007      4492          move.l    D7,D0
00001826  0C80 0000 4493          cmp.l     #4,D0
0000182A  0004      
0000182C  6400 00BE 4494          bhs       OSFlagAccept_6
00001830  E380      4495          asl.l     #1,D0
00001832  303B 0806 4496          move.w    OSFlagAccept_8(PC,D0.L),D0
00001836  4EFB 0002 4497          jmp       OSFlagAccept_8(PC,D0.W)
                    4498   OSFlagAccept_8:
0000183A  0060      4499          dc.w      OSFlagAccept_11-OSFlagAccept_8
0000183C  008A      4500          dc.w      OSFlagAccept_12-OSFlagAccept_8
0000183E  0008      4501          dc.w      OSFlagAccept_9-OSFlagAccept_8
00001840  0034      4502          dc.w      OSFlagAccept_10-OSFlagAccept_8
                    4503   OSFlagAccept_9:
                    4504   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    4505   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
00001842  2043      4506          move.l    D3,A0
00001844  3028 0006 4507          move.w    6(A0),D0
00001848  C045      4508          and.w     D5,D0
0000184A  3400      4509          move.w    D0,D2
                    4510   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
0000184C  B445      4511          cmp.w     D5,D2
0000184E  6612      4512          bne.s     OSFlagAccept_14
                    4513   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001850  0C06 0001 4514          cmp.b     #1,D6
00001854  660A      4515          bne.s     OSFlagAccept_16
                    4516   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
00001856  2043      4517          move.l    D3,A0
00001858  3002      4518          move.w    D2,D0
0000185A  4640      4519          not.w     D0
0000185C  C168 0006 4520          and.w     D0,6(A0)
                    4521   OSFlagAccept_16:
00001860  6006      4522          bra.s     OSFlagAccept_15
                    4523   OSFlagAccept_14:
                    4524   ; }
                    4525   ; } else {
                    4526   ; *perr = OS_ERR_FLAG_NOT_RDY;
00001862  2044      4527          move.l    D4,A0
00001864  10BC 0070 4528          move.b    #112,(A0)
                    4529   OSFlagAccept_15:
                    4530   ; }
                    4531   ; OS_EXIT_CRITICAL();
00001868  46DF      4532          dc.w      18143
                    4533   ; break;
0000186A  6000 008A 4534          bra       OSFlagAccept_7
                    4535   OSFlagAccept_10:
                    4536   ; case OS_FLAG_WAIT_SET_ANY:
                    4537   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
0000186E  2043      4538          move.l    D3,A0
00001870  3028 0006 4539          move.w    6(A0),D0
00001874  C045      4540          and.w     D5,D0
00001876  3400      4541          move.w    D0,D2
                    4542   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
00001878  4A42      4543          tst.w     D2
0000187A  6712      4544          beq.s     OSFlagAccept_18
                    4545   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
0000187C  0C06 0001 4546          cmp.b     #1,D6
00001880  660A      4547          bne.s     OSFlagAccept_20
                    4548   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
00001882  2043      4549          move.l    D3,A0
00001884  3002      4550          move.w    D2,D0
00001886  4640      4551          not.w     D0
00001888  C168 0006 4552          and.w     D0,6(A0)
                    4553   OSFlagAccept_20:
0000188C  6006      4554          bra.s     OSFlagAccept_19
                    4555   OSFlagAccept_18:
                    4556   ; }
                    4557   ; } else {
                    4558   ; *perr = OS_ERR_FLAG_NOT_RDY;
0000188E  2044      4559          move.l    D4,A0
00001890  10BC 0070 4560          move.b    #112,(A0)
                    4561   OSFlagAccept_19:
                    4562   ; }
                    4563   ; OS_EXIT_CRITICAL();
00001894  46DF      4564          dc.w      18143
                    4565   ; break;
00001896  6000 005E 4566          bra       OSFlagAccept_7
                    4567   OSFlagAccept_11:
                    4568   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    4569   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    4570   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
0000189A  2043      4571          move.l    D3,A0
0000189C  3028 0006 4572          move.w    6(A0),D0
000018A0  4640      4573          not.w     D0
000018A2  C045      4574          and.w     D5,D0
000018A4  3400      4575          move.w    D0,D2
                    4576   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
000018A6  B445      4577          cmp.w     D5,D2
000018A8  660E      4578          bne.s     OSFlagAccept_22
                    4579   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
000018AA  0C06 0001 4580          cmp.b     #1,D6
000018AE  6606      4581          bne.s     OSFlagAccept_24
                    4582   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
000018B0  2043      4583          move.l    D3,A0
000018B2  8568 0006 4584          or.w      D2,6(A0)
                    4585   OSFlagAccept_24:
000018B6  6006      4586          bra.s     OSFlagAccept_23
                    4587   OSFlagAccept_22:
                    4588   ; }
                    4589   ; } else {
                    4590   ; *perr = OS_ERR_FLAG_NOT_RDY;
000018B8  2044      4591          move.l    D4,A0
000018BA  10BC 0070 4592          move.b    #112,(A0)
                    4593   OSFlagAccept_23:
                    4594   ; }
                    4595   ; OS_EXIT_CRITICAL();
000018BE  46DF      4596          dc.w      18143
                    4597   ; break;
000018C0  6000 0034 4598          bra       OSFlagAccept_7
                    4599   OSFlagAccept_12:
                    4600   ; case OS_FLAG_WAIT_CLR_ANY:
                    4601   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
000018C4  2043      4602          move.l    D3,A0
000018C6  3028 0006 4603          move.w    6(A0),D0
000018CA  4640      4604          not.w     D0
000018CC  C045      4605          and.w     D5,D0
000018CE  3400      4606          move.w    D0,D2
                    4607   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
000018D0  4A42      4608          tst.w     D2
000018D2  670E      4609          beq.s     OSFlagAccept_26
                    4610   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
000018D4  0C06 0001 4611          cmp.b     #1,D6
000018D8  6606      4612          bne.s     OSFlagAccept_28
                    4613   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
000018DA  2043      4614          move.l    D3,A0
000018DC  8568 0006 4615          or.w      D2,6(A0)
                    4616   OSFlagAccept_28:
000018E0  6006      4617          bra.s     OSFlagAccept_27
                    4618   OSFlagAccept_26:
                    4619   ; }
                    4620   ; } else {
                    4621   ; *perr = OS_ERR_FLAG_NOT_RDY;
000018E2  2044      4622          move.l    D4,A0
000018E4  10BC 0070 4623          move.b    #112,(A0)
                    4624   OSFlagAccept_27:
                    4625   ; }
                    4626   ; OS_EXIT_CRITICAL();
000018E8  46DF      4627          dc.w      18143
                    4628   ; break;
000018EA  600A      4629          bra.s     OSFlagAccept_7
                    4630   OSFlagAccept_6:
                    4631   ; #endif
                    4632   ; default:
                    4633   ; OS_EXIT_CRITICAL();
000018EC  46DF      4634          dc.w      18143
                    4635   ; flags_rdy = (OS_FLAGS)0;
000018EE  4242      4636          clr.w     D2
                    4637   ; *perr     = OS_ERR_FLAG_WAIT_TYPE;
000018F0  2044      4638          move.l    D4,A0
000018F2  10BC 006F 4639          move.b    #111,(A0)
                    4640   ; break;
                    4641   OSFlagAccept_7:
                    4642   ; }
                    4643   ; return (flags_rdy);
000018F6  3002      4644          move.w    D2,D0
                    4645   OSFlagAccept_3:
000018F8  4CDF 00FC 4646          movem.l   (A7)+,D2/D3/D4/D5/D6/D7
000018FC  4E5E      4647          unlk      A6
000018FE  4E75      4648          rts
                    4649   ; }
                    4650   ; #endif
                    4651   ; /*$PAGE*/
                    4652   ; /*
                    4653   ; *********************************************************************************************************
                    4654   ; *                                        CREATE AN EVENT FLAG
                    4655   ; *
                    4656   ; * Description: This function is called to create an event flag group.
                    4657   ; *
                    4658   ; * Arguments  : flags         Contains the initial value to store in the event flag group.
                    4659   ; *
                    4660   ; *              perr          is a pointer to an error code which will be returned to your application:
                    4661   ; *                               OS_ERR_NONE               if the call was successful.
                    4662   ; *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
                    4663   ; *                                                         ISR.
                    4664   ; *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
                    4665   ; *
                    4666   ; * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
                    4667   ; *
                    4668   ; * Called from: Task ONLY
                    4669   ; *********************************************************************************************************
                    4670   ; */
                    4671   ; OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
                    4672   ; INT8U    *perr)
                    4673   ; {
                    4674   _OSFlagCreate:
00001900  4E56 0000 4675          link      A6,#0
00001904  48E7 3020 4676          movem.l   D2/D3/A2,-(A7)
00001908  45F9 0080 4677          lea       _OSFlagFreeList.L,A2
0000190C  0136      
0000190E  262E 000C 4678          move.l    12(A6),D3
                    4679   ; OS_FLAG_GRP *pgrp;
                    4680   ; #if OS_CRITICAL_METHOD == 3u                        /* Allocate storage for CPU status register        */
                    4681   ; OS_CPU_SR    cpu_sr = 0u;
                    4682   ; #endif
                    4683   ; #ifdef OS_SAFETY_CRITICAL
                    4684   ; if (perr == (INT8U *)0) {
                    4685   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4686   ; return ((OS_FLAG_GRP *)0);
                    4687   ; }
                    4688   ; #endif
                    4689   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    4690   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    4691   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4692   ; return ((OS_FLAG_GRP *)0);
                    4693   ; }
                    4694   ; #endif
                    4695   ; if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
00001912  1039 0080 4696          move.b    _OSIntNesting.L,D0
00001916  0246      
00001918  0C00 0000 4697          cmp.b     #0,D0
0000191C  630C      4698          bls.s     OSFlagCreate_1
                    4699   ; *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
0000191E  2043      4700          move.l    D3,A0
00001920  10BC 0010 4701          move.b    #16,(A0)
                    4702   ; return ((OS_FLAG_GRP *)0);
00001924  4280      4703          clr.l     D0
00001926  6000 0046 4704          bra       OSFlagCreate_3
                    4705   OSFlagCreate_1:
                    4706   ; }
                    4707   ; OS_ENTER_CRITICAL();
0000192A  40E7      4708          dc.w      16615
0000192C  007C      4709          dc.w      124
0000192E  0700      4710          dc.w      1792
                    4711   ; pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
00001930  2412      4712          move.l    (A2),D2
                    4713   ; if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
00001932  4A82      4714          tst.l     D2
00001934  672E      4715          beq.s     OSFlagCreate_4
                    4716   ; /* Adjust free list                                */
                    4717   ; OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
00001936  2052      4718          move.l    (A2),A0
00001938  24A8 0002 4719          move.l    2(A0),(A2)
                    4720   ; pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
0000193C  2042      4721          move.l    D2,A0
0000193E  10BC 0005 4722          move.b    #5,(A0)
                    4723   ; pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
00001942  2042      4724          move.l    D2,A0
00001944  316E 000A 4725          move.w    10(A6),6(A0)
00001948  0006      
                    4726   ; pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
0000194A  2042      4727          move.l    D2,A0
0000194C  42A8 0002 4728          clr.l     2(A0)
                    4729   ; #if OS_FLAG_NAME_EN > 0u
                    4730   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001950  41F9 0000 4731          lea       @ucos_ii_1.L,A0
00001954  5A8E      
00001956  2242      4732          move.l    D2,A1
00001958  2348 0008 4733          move.l    A0,8(A1)
                    4734   ; #endif
                    4735   ; OS_EXIT_CRITICAL();
0000195C  46DF      4736          dc.w      18143
                    4737   ; *perr                = OS_ERR_NONE;
0000195E  2043      4738          move.l    D3,A0
00001960  4210      4739          clr.b     (A0)
00001962  6008      4740          bra.s     OSFlagCreate_5
                    4741   OSFlagCreate_4:
                    4742   ; } else {
                    4743   ; OS_EXIT_CRITICAL();
00001964  46DF      4744          dc.w      18143
                    4745   ; *perr                = OS_ERR_FLAG_GRP_DEPLETED;
00001966  2043      4746          move.l    D3,A0
00001968  10BC 0072 4747          move.b    #114,(A0)
                    4748   OSFlagCreate_5:
                    4749   ; }
                    4750   ; return (pgrp);                                  /* Return pointer to event flag group              */
0000196C  2002      4751          move.l    D2,D0
                    4752   OSFlagCreate_3:
0000196E  4CDF 040C 4753          movem.l   (A7)+,D2/D3/A2
00001972  4E5E      4754          unlk      A6
00001974  4E75      4755          rts
                    4756   ; }
                    4757   ; /*$PAGE*/
                    4758   ; /*
                    4759   ; *********************************************************************************************************
                    4760   ; *                                     DELETE AN EVENT FLAG GROUP
                    4761   ; *
                    4762   ; * Description: This function deletes an event flag group and readies all tasks pending on the event flag
                    4763   ; *              group.
                    4764   ; *
                    4765   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    4766   ; *
                    4767   ; *              opt           determines delete options as follows:
                    4768   ; *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
                    4769   ; *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
                    4770   ; *                                                    waiting.  In this case, all the tasks pending will be
                    4771   ; *                                                    readied.
                    4772   ; *
                    4773   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    4774   ; *                            OS_ERR_NONE               The call was successful and the event flag group was
                    4775   ; *                                                      deleted
                    4776   ; *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
                    4777   ; *                                                      an ISR
                    4778   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    4779   ; *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
                    4780   ; *                            OS_ERR_INVALID_OPT        An invalid option was specified
                    4781   ; *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
                    4782   ; *                                                      group.
                    4783   ; *
                    4784   ; * Returns    : pgrp          upon error
                    4785   ; *              (OS_EVENT *)0 if the event flag group was successfully deleted.
                    4786   ; *
                    4787   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    4788   ; *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
                    4789   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    4790   ; *                 time is directly proportional to the number of tasks waiting on the event flag group.
                    4791   ; *              3) All tasks that were waiting for the event flag will be readied and returned an
                    4792   ; *                 OS_ERR_PEND_ABORT if OSFlagDel() was called with OS_DEL_ALWAYS
                    4793   ; *********************************************************************************************************
                    4794   ; */
                    4795   ; #if OS_FLAG_DEL_EN > 0u
                    4796   ; OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
                    4797   ; INT8U         opt,
                    4798   ; INT8U        *perr)
                    4799   ; {
                    4800   _OSFlagDel:
00001976  4E56 0000 4801          link      A6,#0
0000197A  48E7 3E20 4802          movem.l   D2/D3/D4/D5/D6/A2,-(A7)
0000197E  242E 0008 4803          move.l    8(A6),D2
00001982  262E 0010 4804          move.l    16(A6),D3
00001986  45F9 0080 4805          lea       _OSFlagFreeList.L,A2
0000198A  0136      
                    4806   ; BOOLEAN       tasks_waiting;
                    4807   ; OS_FLAG_NODE *pnode;
                    4808   ; OS_FLAG_GRP  *pgrp_return;
                    4809   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    4810   ; OS_CPU_SR     cpu_sr = 0u;
                    4811   ; #endif
                    4812   ; #ifdef OS_SAFETY_CRITICAL
                    4813   ; if (perr == (INT8U *)0) {
                    4814   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    4815   ; return ((OS_FLAG_GRP *)0);
                    4816   ; }
                    4817   ; #endif
                    4818   ; #if OS_ARG_CHK_EN > 0u
                    4819   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    4820   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    4821   ; return (pgrp);
                    4822   ; }
                    4823   ; #endif
                    4824   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
0000198C  1039 0080 4825          move.b    _OSIntNesting.L,D0
00001990  0246      
00001992  0C00 0000 4826          cmp.b     #0,D0
00001996  630C      4827          bls.s     OSFlagDel_1
                    4828   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00001998  2043      4829          move.l    D3,A0
0000199A  10BC 000F 4830          move.b    #15,(A0)
                    4831   ; return (pgrp);
0000199E  2002      4832          move.l    D2,D0
000019A0  6000 00EC 4833          bra       OSFlagDel_3
                    4834   OSFlagDel_1:
                    4835   ; }
                    4836   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
000019A4  2042      4837          move.l    D2,A0
000019A6  1010      4838          move.b    (A0),D0
000019A8  0C00 0005 4839          cmp.b     #5,D0
000019AC  670C      4840          beq.s     OSFlagDel_4
                    4841   ; *perr = OS_ERR_EVENT_TYPE;
000019AE  2043      4842          move.l    D3,A0
000019B0  10BC 0001 4843          move.b    #1,(A0)
                    4844   ; return (pgrp);
000019B4  2002      4845          move.l    D2,D0
000019B6  6000 00D6 4846          bra       OSFlagDel_3
                    4847   OSFlagDel_4:
                    4848   ; }
                    4849   ; OS_ENTER_CRITICAL();
000019BA  40E7      4850          dc.w      16615
000019BC  007C      4851          dc.w      124
000019BE  0700      4852          dc.w      1792
                    4853   ; if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
000019C0  2042      4854          move.l    D2,A0
000019C2  2028 0002 4855          move.l    2(A0),D0
000019C6  6704      4856          beq.s     OSFlagDel_6
                    4857   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
000019C8  7C01      4858          moveq     #1,D6
000019CA  6002      4859          bra.s     OSFlagDel_7
                    4860   OSFlagDel_6:
                    4861   ; } else {
                    4862   ; tasks_waiting = OS_FALSE;                          /* No                                       */
000019CC  4206      4863          clr.b     D6
                    4864   OSFlagDel_7:
                    4865   ; }
                    4866   ; switch (opt) {
000019CE  102E 000F 4867          move.b    15(A6),D0
000019D2  C0BC 0000 4868          and.l     #255,D0
000019D6  00FF      
000019D8  0C80 0000 4869          cmp.l     #1,D0
000019DC  0001      
000019DE  6700 0048 4870          beq       OSFlagDel_11
000019E2  6200 009E 4871          bhi       OSFlagDel_8
000019E6  4A80      4872          tst.l     D0
000019E8  6704      4873          beq.s     OSFlagDel_10
000019EA  6000 0096 4874          bra       OSFlagDel_8
                    4875   OSFlagDel_10:
                    4876   ; case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
                    4877   ; if (tasks_waiting == OS_FALSE) {
000019EE  4A06      4878          tst.b     D6
000019F0  6628      4879          bne.s     OSFlagDel_13
                    4880   ; #if OS_FLAG_NAME_EN > 0u
                    4881   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
000019F2  41F9 0000 4882          lea       @ucos_ii_1.L,A0
000019F6  5A8E      
000019F8  2242      4883          move.l    D2,A1
000019FA  2348 0008 4884          move.l    A0,8(A1)
                    4885   ; #endif
                    4886   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
000019FE  2042      4887          move.l    D2,A0
00001A00  4210      4888          clr.b     (A0)
                    4889   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
00001A02  2042      4890          move.l    D2,A0
00001A04  2152 0002 4891          move.l    (A2),2(A0)
                    4892   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00001A08  2042      4893          move.l    D2,A0
00001A0A  4268 0006 4894          clr.w     6(A0)
                    4895   ; OSFlagFreeList       = pgrp;
00001A0E  2482      4896          move.l    D2,(A2)
                    4897   ; OS_EXIT_CRITICAL();
00001A10  46DF      4898          dc.w      18143
                    4899   ; *perr                = OS_ERR_NONE;
00001A12  2043      4900          move.l    D3,A0
00001A14  4210      4901          clr.b     (A0)
                    4902   ; pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
00001A16  4285      4903          clr.l     D5
00001A18  600A      4904          bra.s     OSFlagDel_14
                    4905   OSFlagDel_13:
                    4906   ; } else {
                    4907   ; OS_EXIT_CRITICAL();
00001A1A  46DF      4908          dc.w      18143
                    4909   ; *perr                = OS_ERR_TASK_WAITING;
00001A1C  2043      4910          move.l    D3,A0
00001A1E  10BC 0049 4911          move.b    #73,(A0)
                    4912   ; pgrp_return          = pgrp;
00001A22  2A02      4913          move.l    D2,D5
                    4914   OSFlagDel_14:
                    4915   ; }
                    4916   ; break;
00001A24  6000 0066 4917          bra       OSFlagDel_9
                    4918   OSFlagDel_11:
                    4919   ; case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
                    4920   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00001A28  2042      4921          move.l    D2,A0
00001A2A  2828 0002 4922          move.l    2(A0),D4
                    4923   ; while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
                    4924   OSFlagDel_15:
00001A2E  4A84      4925          tst.l     D4
00001A30  671E      4926          beq.s     OSFlagDel_17
                    4927   ; (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
00001A32  4878 0002 4928          pea       2
00001A36  42A7      4929          clr.l     -(A7)
00001A38  2F04      4930          move.l    D4,-(A7)
00001A3A  4EB9 0000 4931          jsr       @ucos_ii_OS_FlagTaskRdy
00001A3E  21AC      
00001A40  DEFC 000C 4932          add.w     #12,A7
00001A44  C0BC 0000 4933          and.l     #255,D0
00001A48  00FF      
                    4934   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
00001A4A  2044      4935          move.l    D4,A0
00001A4C  2810      4936          move.l    (A0),D4
00001A4E  60DE      4937          bra       OSFlagDel_15
                    4938   OSFlagDel_17:
                    4939   ; }
                    4940   ; #if OS_FLAG_NAME_EN > 0u
                    4941   ; pgrp->OSFlagName     = (INT8U *)(void *)"?";
00001A50  41F9 0000 4942          lea       @ucos_ii_1.L,A0
00001A54  5A8E      
00001A56  2242      4943          move.l    D2,A1
00001A58  2348 0008 4944          move.l    A0,8(A1)
                    4945   ; #endif
                    4946   ; pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00001A5C  2042      4947          move.l    D2,A0
00001A5E  4210      4948          clr.b     (A0)
                    4949   ; pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
00001A60  2042      4950          move.l    D2,A0
00001A62  2152 0002 4951          move.l    (A2),2(A0)
                    4952   ; pgrp->OSFlagFlags    = (OS_FLAGS)0;
00001A66  2042      4953          move.l    D2,A0
00001A68  4268 0006 4954          clr.w     6(A0)
                    4955   ; OSFlagFreeList       = pgrp;
00001A6C  2482      4956          move.l    D2,(A2)
                    4957   ; OS_EXIT_CRITICAL();
00001A6E  46DF      4958          dc.w      18143
                    4959   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00001A70  0C06 0001 4960          cmp.b     #1,D6
00001A74  6604      4961          bne.s     OSFlagDel_18
                    4962   ; OS_Sched();                               /* Find highest priority task ready to run  */
00001A76  4EB8 13F8 4963          jsr       _OS_Sched
                    4964   OSFlagDel_18:
                    4965   ; }
                    4966   ; *perr = OS_ERR_NONE;
00001A7A  2043      4967          move.l    D3,A0
00001A7C  4210      4968          clr.b     (A0)
                    4969   ; pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
00001A7E  4285      4970          clr.l     D5
                    4971   ; break;
00001A80  600A      4972          bra.s     OSFlagDel_9
                    4973   OSFlagDel_8:
                    4974   ; default:
                    4975   ; OS_EXIT_CRITICAL();
00001A82  46DF      4976          dc.w      18143
                    4977   ; *perr                = OS_ERR_INVALID_OPT;
00001A84  2043      4978          move.l    D3,A0
00001A86  10BC 0007 4979          move.b    #7,(A0)
                    4980   ; pgrp_return          = pgrp;
00001A8A  2A02      4981          move.l    D2,D5
                    4982   ; break;
                    4983   OSFlagDel_9:
                    4984   ; }
                    4985   ; return (pgrp_return);
00001A8C  2005      4986          move.l    D5,D0
                    4987   OSFlagDel_3:
00001A8E  4CDF 047C 4988          movem.l   (A7)+,D2/D3/D4/D5/D6/A2
00001A92  4E5E      4989          unlk      A6
00001A94  4E75      4990          rts
                    4991   ; }
                    4992   ; #endif
                    4993   ; /*$PAGE*/
                    4994   ; /*
                    4995   ; *********************************************************************************************************
                    4996   ; *                                 GET THE NAME OF AN EVENT FLAG GROUP
                    4997   ; *
                    4998   ; * Description: This function is used to obtain the name assigned to an event flag group
                    4999   ; *
                    5000   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5001   ; *
                    5002   ; *              pname     is pointer to a pointer to an ASCII string that will receive the name of the event flag
                    5003   ; *                        group.
                    5004   ; *
                    5005   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5006   ; *
                    5007   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5008   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5009   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5010   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5011   ; *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
                    5012   ; *
                    5013   ; * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
                    5014   ; *********************************************************************************************************
                    5015   ; */
                    5016   ; #if OS_FLAG_NAME_EN > 0u
                    5017   ; INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
                    5018   ; INT8U        **pname,
                    5019   ; INT8U         *perr)
                    5020   ; {
                    5021   _OSFlagNameGet:
00001A96  4E56 FFFC 5022          link      A6,#-4
00001A9A  2F02      5023          move.l    D2,-(A7)
00001A9C  242E 0010 5024          move.l    16(A6),D2
                    5025   ; INT8U      len;
                    5026   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5027   ; OS_CPU_SR  cpu_sr = 0u;
                    5028   ; #endif
                    5029   ; #ifdef OS_SAFETY_CRITICAL
                    5030   ; if (perr == (INT8U *)0) {
                    5031   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5032   ; return (0u);
                    5033   ; }
                    5034   ; #endif
                    5035   ; #if OS_ARG_CHK_EN > 0u
                    5036   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5037   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5038   ; return (0u);
                    5039   ; }
                    5040   ; if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5041   ; *perr = OS_ERR_PNAME_NULL;
                    5042   ; return (0u);
                    5043   ; }
                    5044   ; #endif
                    5045   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00001AA0  1039 0080 5046          move.b    _OSIntNesting.L,D0
00001AA4  0246      
00001AA6  0C00 0000 5047          cmp.b     #0,D0
00001AAA  630C      5048          bls.s     OSFlagNameGet_1
                    5049   ; *perr = OS_ERR_NAME_GET_ISR;
00001AAC  2042      5050          move.l    D2,A0
00001AAE  10BC 0011 5051          move.b    #17,(A0)
                    5052   ; return (0u);
00001AB2  4200      5053          clr.b     D0
00001AB4  6000 0046 5054          bra       OSFlagNameGet_3
                    5055   OSFlagNameGet_1:
                    5056   ; }
                    5057   ; OS_ENTER_CRITICAL();
00001AB8  40E7      5058          dc.w      16615
00001ABA  007C      5059          dc.w      124
00001ABC  0700      5060          dc.w      1792
                    5061   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
00001ABE  206E 0008 5062          move.l    8(A6),A0
00001AC2  1010      5063          move.b    (A0),D0
00001AC4  0C00 0005 5064          cmp.b     #5,D0
00001AC8  670C      5065          beq.s     OSFlagNameGet_4
                    5066   ; OS_EXIT_CRITICAL();
00001ACA  46DF      5067          dc.w      18143
                    5068   ; *perr = OS_ERR_EVENT_TYPE;
00001ACC  2042      5069          move.l    D2,A0
00001ACE  10BC 0001 5070          move.b    #1,(A0)
                    5071   ; return (0u);
00001AD2  4200      5072          clr.b     D0
00001AD4  6026      5073          bra.s     OSFlagNameGet_3
                    5074   OSFlagNameGet_4:
                    5075   ; }
                    5076   ; *pname = pgrp->OSFlagName;
00001AD6  206E 0008 5077          move.l    8(A6),A0
00001ADA  226E 000C 5078          move.l    12(A6),A1
00001ADE  22A8 0008 5079          move.l    8(A0),(A1)
                    5080   ; len    = OS_StrLen(*pname);
00001AE2  206E 000C 5081          move.l    12(A6),A0
00001AE6  2F10      5082          move.l    (A0),-(A7)
00001AE8  4EB8 14A2 5083          jsr       _OS_StrLen
00001AEC  584F      5084          addq.w    #4,A7
00001AEE  1D40 FFFF 5085          move.b    D0,-1(A6)
                    5086   ; OS_EXIT_CRITICAL();
00001AF2  46DF      5087          dc.w      18143
                    5088   ; *perr  = OS_ERR_NONE;
00001AF4  2042      5089          move.l    D2,A0
00001AF6  4210      5090          clr.b     (A0)
                    5091   ; return (len);
00001AF8  102E FFFF 5092          move.b    -1(A6),D0
                    5093   OSFlagNameGet_3:
00001AFC  241F      5094          move.l    (A7)+,D2
00001AFE  4E5E      5095          unlk      A6
00001B00  4E75      5096          rts
                    5097   ; }
                    5098   ; #endif
                    5099   ; /*$PAGE*/
                    5100   ; /*
                    5101   ; *********************************************************************************************************
                    5102   ; *                                ASSIGN A NAME TO AN EVENT FLAG GROUP
                    5103   ; *
                    5104   ; * Description: This function assigns a name to an event flag group.
                    5105   ; *
                    5106   ; * Arguments  : pgrp      is a pointer to the event flag group.
                    5107   ; *
                    5108   ; *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
                    5109   ; *                        group.
                    5110   ; *
                    5111   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    5112   ; *
                    5113   ; *                        OS_ERR_NONE                if the requested task is resumed
                    5114   ; *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
                    5115   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    5116   ; *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
                    5117   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    5118   ; *
                    5119   ; * Returns    : None
                    5120   ; *********************************************************************************************************
                    5121   ; */
                    5122   ; #if OS_FLAG_NAME_EN > 0u
                    5123   ; void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
                    5124   ; INT8U        *pname,
                    5125   ; INT8U        *perr)
                    5126   ; {
                    5127   _OSFlagNameSet:
00001B02  4E56 0000 5128          link      A6,#0
00001B06  2F02      5129          move.l    D2,-(A7)
00001B08  242E 0010 5130          move.l    16(A6),D2
                    5131   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    5132   ; OS_CPU_SR  cpu_sr = 0u;
                    5133   ; #endif
                    5134   ; #ifdef OS_SAFETY_CRITICAL
                    5135   ; if (perr == (INT8U *)0) {
                    5136   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5137   ; return;
                    5138   ; }
                    5139   ; #endif
                    5140   ; #if OS_ARG_CHK_EN > 0u
                    5141   ; if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
                    5142   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5143   ; return;
                    5144   ; }
                    5145   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    5146   ; *perr = OS_ERR_PNAME_NULL;
                    5147   ; return;
                    5148   ; }
                    5149   ; #endif
                    5150   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00001B0C  1039 0080 5151          move.b    _OSIntNesting.L,D0
00001B10  0246      
00001B12  0C00 0000 5152          cmp.b     #0,D0
00001B16  630A      5153          bls.s     OSFlagNameSet_1
                    5154   ; *perr = OS_ERR_NAME_SET_ISR;
00001B18  2042      5155          move.l    D2,A0
00001B1A  10BC 0012 5156          move.b    #18,(A0)
                    5157   ; return;
00001B1E  6000 002E 5158          bra       OSFlagNameSet_3
                    5159   OSFlagNameSet_1:
                    5160   ; }
                    5161   ; OS_ENTER_CRITICAL();
00001B22  40E7      5162          dc.w      16615
00001B24  007C      5163          dc.w      124
00001B26  0700      5164          dc.w      1792
                    5165   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
00001B28  206E 0008 5166          move.l    8(A6),A0
00001B2C  1010      5167          move.b    (A0),D0
00001B2E  0C00 0005 5168          cmp.b     #5,D0
00001B32  670A      5169          beq.s     OSFlagNameSet_4
                    5170   ; OS_EXIT_CRITICAL();
00001B34  46DF      5171          dc.w      18143
                    5172   ; *perr = OS_ERR_EVENT_TYPE;
00001B36  2042      5173          move.l    D2,A0
00001B38  10BC 0001 5174          move.b    #1,(A0)
                    5175   ; return;
00001B3C  6010      5176          bra.s     OSFlagNameSet_3
                    5177   OSFlagNameSet_4:
                    5178   ; }
                    5179   ; pgrp->OSFlagName = pname;
00001B3E  206E 0008 5180          move.l    8(A6),A0
00001B42  216E 000C 5181          move.l    12(A6),8(A0)
00001B46  0008      
                    5182   ; OS_EXIT_CRITICAL();
00001B48  46DF      5183          dc.w      18143
                    5184   ; *perr            = OS_ERR_NONE;
00001B4A  2042      5185          move.l    D2,A0
00001B4C  4210      5186          clr.b     (A0)
                    5187   ; return;
                    5188   OSFlagNameSet_3:
00001B4E  241F      5189          move.l    (A7)+,D2
00001B50  4E5E      5190          unlk      A6
00001B52  4E75      5191          rts
                    5192   ; }
                    5193   ; #endif
                    5194   ; /*$PAGE*/
                    5195   ; /*
                    5196   ; *********************************************************************************************************
                    5197   ; *                                     WAIT ON AN EVENT FLAG GROUP
                    5198   ; *
                    5199   ; * Description: This function is called to wait for a combination of bits to be set in an event flag
                    5200   ; *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
                    5201   ; *
                    5202   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5203   ; *
                    5204   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
                    5205   ; *                            The bits you want are specified by setting the corresponding bits in
                    5206   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    5207   ; *                            'flags' would contain 0x03.
                    5208   ; *
                    5209   ; *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
                    5210   ; *                            You can specify the following argument:
                    5211   ; *
                    5212   ; *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
                    5213   ; *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
                    5214   ; *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
                    5215   ; *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
                    5216   ; *
                    5217   ; *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
                    5218   ; *                                  the call.  Example, to wait for any flag in a group AND then clear
                    5219   ; *                                  the flags that are present, set 'wait_type' to:
                    5220   ; *
                    5221   ; *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
                    5222   ; *
                    5223   ; *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
                    5224   ; *                            desired bit combination.  If you specify 0, however, your task will wait
                    5225   ; *                            forever at the specified event flag group or, until a message arrives.
                    5226   ; *
                    5227   ; *              perr          is a pointer to an error code and can be:
                    5228   ; *                            OS_ERR_NONE               The desired bits have been set within the specified
                    5229   ; *                                                      'timeout'.
                    5230   ; *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
                    5231   ; *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
                    5232   ; *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
                    5233   ; *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
                    5234   ; *                                                      'timeout'.
                    5235   ; *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
                    5236   ; *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
                    5237   ; *
                    5238   ; * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
                    5239   ; *              occurred.
                    5240   ; *
                    5241   ; * Called from: Task ONLY
                    5242   ; *
                    5243   ; * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
                    5244   ; *                 function NOW returns the flags that were ready INSTEAD of the current state of the
                    5245   ; *                 event flags.
                    5246   ; *********************************************************************************************************
                    5247   ; */
                    5248   ; OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
                    5249   ; OS_FLAGS      flags,
                    5250   ; INT8U         wait_type,
                    5251   ; INT32U        timeout,
                    5252   ; INT8U        *perr)
                    5253   ; {
                    5254   _OSFlagPend:
00001B54  4E56 FFE8 5255          link      A6,#-24
00001B58  48E7 3F3C 5256          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001B5C  262E 0008 5257          move.l    8(A6),D3
00001B60  282E 0018 5258          move.l    24(A6),D4
00001B64  3A2E 000E 5259          move.w    14(A6),D5
00001B68  CABC 0000 5260          and.l     #65535,D5
00001B6C  FFFF      
00001B6E  45F9 0080 5261          lea       _OSTCBCur.L,A2
00001B72  0360      
00001B74  1C2E 0013 5262          move.b    19(A6),D6
00001B78  CCBC 0000 5263          and.l     #255,D6
00001B7C  00FF      
00001B7E  47EE FFEA 5264          lea       -22(A6),A3
00001B82  286E 0014 5265          move.l    20(A6),A4
00001B86  4BF9 0000 5266          lea       @ucos_ii_OS_FlagBlock.L,A5
00001B8A  204E      
                    5267   ; OS_FLAG_NODE  node;
                    5268   ; OS_FLAGS      flags_rdy;
                    5269   ; INT8U         result;
                    5270   ; INT8U         pend_stat;
                    5271   ; BOOLEAN       consume;
                    5272   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5273   ; OS_CPU_SR     cpu_sr = 0u;
                    5274   ; #endif
                    5275   ; #ifdef OS_SAFETY_CRITICAL
                    5276   ; if (perr == (INT8U *)0) {
                    5277   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5278   ; return ((OS_FLAGS)0);
                    5279   ; }
                    5280   ; #endif
                    5281   ; #if OS_ARG_CHK_EN > 0u
                    5282   ; if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
                    5283   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5284   ; return ((OS_FLAGS)0);
                    5285   ; }
                    5286   ; #endif
                    5287   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00001B8C  1039 0080 5288          move.b    _OSIntNesting.L,D0
00001B90  0246      
00001B92  0C00 0000 5289          cmp.b     #0,D0
00001B96  630C      5290          bls.s     OSFlagPend_1
                    5291   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00001B98  2044      5292          move.l    D4,A0
00001B9A  10BC 0002 5293          move.b    #2,(A0)
                    5294   ; return ((OS_FLAGS)0);
00001B9E  4240      5295          clr.w     D0
00001BA0  6000 028A 5296          bra       OSFlagPend_3
                    5297   OSFlagPend_1:
                    5298   ; }
                    5299   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
00001BA4  1039 0080 5300          move.b    _OSLockNesting.L,D0
00001BA8  0248      
00001BAA  0C00 0000 5301          cmp.b     #0,D0
00001BAE  630C      5302          bls.s     OSFlagPend_4
                    5303   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
00001BB0  2044      5304          move.l    D4,A0
00001BB2  10BC 000D 5305          move.b    #13,(A0)
                    5306   ; return ((OS_FLAGS)0);
00001BB6  4240      5307          clr.w     D0
00001BB8  6000 0272 5308          bra       OSFlagPend_3
                    5309   OSFlagPend_4:
                    5310   ; }
                    5311   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
00001BBC  2043      5312          move.l    D3,A0
00001BBE  1010      5313          move.b    (A0),D0
00001BC0  0C00 0005 5314          cmp.b     #5,D0
00001BC4  670C      5315          beq.s     OSFlagPend_6
                    5316   ; *perr = OS_ERR_EVENT_TYPE;
00001BC6  2044      5317          move.l    D4,A0
00001BC8  10BC 0001 5318          move.b    #1,(A0)
                    5319   ; return ((OS_FLAGS)0);
00001BCC  4240      5320          clr.w     D0
00001BCE  6000 025C 5321          bra       OSFlagPend_3
                    5322   OSFlagPend_6:
                    5323   ; }
                    5324   ; result = (INT8U)(wait_type & OS_FLAG_CONSUME);
00001BD2  1006      5325          move.b    D6,D0
00001BD4  C03C 0080 5326          and.b     #128,D0
00001BD8  1D40 FFFE 5327          move.b    D0,-2(A6)
                    5328   ; if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
00001BDC  102E FFFE 5329          move.b    -2(A6),D0
00001BE0  670C      5330          beq.s     OSFlagPend_8
                    5331   ; wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
00001BE2  103C 0080 5332          move.b    #128,D0
00001BE6  4600      5333          not.b     D0
00001BE8  CC00      5334          and.b     D0,D6
                    5335   ; consume    = OS_TRUE;
00001BEA  7E01      5336          moveq     #1,D7
00001BEC  6002      5337          bra.s     OSFlagPend_9
                    5338   OSFlagPend_8:
                    5339   ; } else {
                    5340   ; consume    = OS_FALSE;
00001BEE  7E00      5341          moveq     #0,D7
                    5342   OSFlagPend_9:
                    5343   ; }
                    5344   ; /*$PAGE*/
                    5345   ; OS_ENTER_CRITICAL();
00001BF0  40E7      5346          dc.w      16615
00001BF2  007C      5347          dc.w      124
00001BF4  0700      5348          dc.w      1792
                    5349   ; switch (wait_type) {
00001BF6  CCBC 0000 5350          and.l     #255,D6
00001BFA  00FF      
00001BFC  2006      5351          move.l    D6,D0
00001BFE  0C80 0000 5352          cmp.l     #4,D0
00001C02  0004      
00001C04  6400 0156 5353          bhs       OSFlagPend_10
00001C08  E380      5354          asl.l     #1,D0
00001C0A  303B 0806 5355          move.w    OSFlagPend_12(PC,D0.L),D0
00001C0E  4EFB 0002 5356          jmp       OSFlagPend_12(PC,D0.W)
                    5357   OSFlagPend_12:
00001C12  00AC      5358          dc.w      OSFlagPend_15-OSFlagPend_12
00001C14  00FC      5359          dc.w      OSFlagPend_16-OSFlagPend_12
00001C16  0008      5360          dc.w      OSFlagPend_13-OSFlagPend_12
00001C18  005A      5361          dc.w      OSFlagPend_14-OSFlagPend_12
                    5362   OSFlagPend_13:
                    5363   ; case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
                    5364   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
00001C1A  2043      5365          move.l    D3,A0
00001C1C  3028 0006 5366          move.w    6(A0),D0
00001C20  C045      5367          and.w     D5,D0
00001C22  3400      5368          move.w    D0,D2
                    5369   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001C24  B445      5370          cmp.w     D5,D2
00001C26  6622      5371          bne.s     OSFlagPend_18
                    5372   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001C28  0C07 0001 5373          cmp.b     #1,D7
00001C2C  660A      5374          bne.s     OSFlagPend_20
                    5375   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
00001C2E  2043      5376          move.l    D3,A0
00001C30  3002      5377          move.w    D2,D0
00001C32  4640      5378          not.w     D0
00001C34  C168 0006 5379          and.w     D0,6(A0)
                    5380   OSFlagPend_20:
                    5381   ; }
                    5382   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001C38  2052      5383          move.l    (A2),A0
00001C3A  3142 002C 5384          move.w    D2,44(A0)
                    5385   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001C3E  46DF      5386          dc.w      18143
                    5387   ; *perr                   = OS_ERR_NONE;
00001C40  2044      5388          move.l    D4,A0
00001C42  4210      5389          clr.b     (A0)
                    5390   ; return (flags_rdy);
00001C44  3002      5391          move.w    D2,D0
00001C46  6000 01E4 5392          bra       OSFlagPend_3
                    5393   OSFlagPend_18:
                    5394   ; } else {                                      /* Block task until events occur or timeout */
                    5395   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001C4A  2F0C      5396          move.l    A4,-(A7)
00001C4C  CCBC 0000 5397          and.l     #255,D6
00001C50  00FF      
00001C52  2F06      5398          move.l    D6,-(A7)
00001C54  CABC 0000 5399          and.l     #65535,D5
00001C58  FFFF      
00001C5A  2F05      5400          move.l    D5,-(A7)
00001C5C  2F0B      5401          move.l    A3,-(A7)
00001C5E  2F03      5402          move.l    D3,-(A7)
00001C60  4E95      5403          jsr       (A5)
00001C62  DEFC 0014 5404          add.w     #20,A7
                    5405   ; OS_EXIT_CRITICAL();
00001C66  46DF      5406          dc.w      18143
                    5407   ; }
                    5408   ; break;
00001C68  6000 0102 5409          bra       OSFlagPend_11
                    5410   OSFlagPend_14:
                    5411   ; case OS_FLAG_WAIT_SET_ANY:
                    5412   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
00001C6C  2043      5413          move.l    D3,A0
00001C6E  3028 0006 5414          move.w    6(A0),D0
00001C72  C045      5415          and.w     D5,D0
00001C74  3400      5416          move.w    D0,D2
                    5417   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
00001C76  4A42      5418          tst.w     D2
00001C78  6722      5419          beq.s     OSFlagPend_22
                    5420   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001C7A  0C07 0001 5421          cmp.b     #1,D7
00001C7E  660A      5422          bne.s     OSFlagPend_24
                    5423   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
00001C80  2043      5424          move.l    D3,A0
00001C82  3002      5425          move.w    D2,D0
00001C84  4640      5426          not.w     D0
00001C86  C168 0006 5427          and.w     D0,6(A0)
                    5428   OSFlagPend_24:
                    5429   ; }
                    5430   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001C8A  2052      5431          move.l    (A2),A0
00001C8C  3142 002C 5432          move.w    D2,44(A0)
                    5433   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001C90  46DF      5434          dc.w      18143
                    5435   ; *perr                   = OS_ERR_NONE;
00001C92  2044      5436          move.l    D4,A0
00001C94  4210      5437          clr.b     (A0)
                    5438   ; return (flags_rdy);
00001C96  3002      5439          move.w    D2,D0
00001C98  6000 0192 5440          bra       OSFlagPend_3
                    5441   OSFlagPend_22:
                    5442   ; } else {                                      /* Block task until events occur or timeout */
                    5443   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001C9C  2F0C      5444          move.l    A4,-(A7)
00001C9E  CCBC 0000 5445          and.l     #255,D6
00001CA2  00FF      
00001CA4  2F06      5446          move.l    D6,-(A7)
00001CA6  CABC 0000 5447          and.l     #65535,D5
00001CAA  FFFF      
00001CAC  2F05      5448          move.l    D5,-(A7)
00001CAE  2F0B      5449          move.l    A3,-(A7)
00001CB0  2F03      5450          move.l    D3,-(A7)
00001CB2  4E95      5451          jsr       (A5)
00001CB4  DEFC 0014 5452          add.w     #20,A7
                    5453   ; OS_EXIT_CRITICAL();
00001CB8  46DF      5454          dc.w      18143
                    5455   ; }
                    5456   ; break;
00001CBA  6000 00B0 5457          bra       OSFlagPend_11
                    5458   OSFlagPend_15:
                    5459   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5460   ; case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
                    5461   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
00001CBE  2043      5462          move.l    D3,A0
00001CC0  3028 0006 5463          move.w    6(A0),D0
00001CC4  4640      5464          not.w     D0
00001CC6  C045      5465          and.w     D5,D0
00001CC8  3400      5466          move.w    D0,D2
                    5467   ; if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
00001CCA  B445      5468          cmp.w     D5,D2
00001CCC  661E      5469          bne.s     OSFlagPend_26
                    5470   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001CCE  0C07 0001 5471          cmp.b     #1,D7
00001CD2  6606      5472          bne.s     OSFlagPend_28
                    5473   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
00001CD4  2043      5474          move.l    D3,A0
00001CD6  8568 0006 5475          or.w      D2,6(A0)
                    5476   OSFlagPend_28:
                    5477   ; }
                    5478   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001CDA  2052      5479          move.l    (A2),A0
00001CDC  3142 002C 5480          move.w    D2,44(A0)
                    5481   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001CE0  46DF      5482          dc.w      18143
                    5483   ; *perr                   = OS_ERR_NONE;
00001CE2  2044      5484          move.l    D4,A0
00001CE4  4210      5485          clr.b     (A0)
                    5486   ; return (flags_rdy);
00001CE6  3002      5487          move.w    D2,D0
00001CE8  6000 0142 5488          bra       OSFlagPend_3
                    5489   OSFlagPend_26:
                    5490   ; } else {                                      /* Block task until events occur or timeout */
                    5491   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001CEC  2F0C      5492          move.l    A4,-(A7)
00001CEE  CCBC 0000 5493          and.l     #255,D6
00001CF2  00FF      
00001CF4  2F06      5494          move.l    D6,-(A7)
00001CF6  CABC 0000 5495          and.l     #65535,D5
00001CFA  FFFF      
00001CFC  2F05      5496          move.l    D5,-(A7)
00001CFE  2F0B      5497          move.l    A3,-(A7)
00001D00  2F03      5498          move.l    D3,-(A7)
00001D02  4E95      5499          jsr       (A5)
00001D04  DEFC 0014 5500          add.w     #20,A7
                    5501   ; OS_EXIT_CRITICAL();
00001D08  46DF      5502          dc.w      18143
                    5503   ; }
                    5504   ; break;
00001D0A  6000 0060 5505          bra       OSFlagPend_11
                    5506   OSFlagPend_16:
                    5507   ; case OS_FLAG_WAIT_CLR_ANY:
                    5508   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
00001D0E  2043      5509          move.l    D3,A0
00001D10  3028 0006 5510          move.w    6(A0),D0
00001D14  4640      5511          not.w     D0
00001D16  C045      5512          and.w     D5,D0
00001D18  3400      5513          move.w    D0,D2
                    5514   ; if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
00001D1A  4A42      5515          tst.w     D2
00001D1C  671E      5516          beq.s     OSFlagPend_30
                    5517   ; if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
00001D1E  0C07 0001 5518          cmp.b     #1,D7
00001D22  6606      5519          bne.s     OSFlagPend_32
                    5520   ; pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
00001D24  2043      5521          move.l    D3,A0
00001D26  8568 0006 5522          or.w      D2,6(A0)
                    5523   OSFlagPend_32:
                    5524   ; }
                    5525   ; OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
00001D2A  2052      5526          move.l    (A2),A0
00001D2C  3142 002C 5527          move.w    D2,44(A0)
                    5528   ; OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
00001D30  46DF      5529          dc.w      18143
                    5530   ; *perr                   = OS_ERR_NONE;
00001D32  2044      5531          move.l    D4,A0
00001D34  4210      5532          clr.b     (A0)
                    5533   ; return (flags_rdy);
00001D36  3002      5534          move.w    D2,D0
00001D38  6000 00F2 5535          bra       OSFlagPend_3
                    5536   OSFlagPend_30:
                    5537   ; } else {                                      /* Block task until events occur or timeout */
                    5538   ; OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
00001D3C  2F0C      5539          move.l    A4,-(A7)
00001D3E  CCBC 0000 5540          and.l     #255,D6
00001D42  00FF      
00001D44  2F06      5541          move.l    D6,-(A7)
00001D46  CABC 0000 5542          and.l     #65535,D5
00001D4A  FFFF      
00001D4C  2F05      5543          move.l    D5,-(A7)
00001D4E  2F0B      5544          move.l    A3,-(A7)
00001D50  2F03      5545          move.l    D3,-(A7)
00001D52  4E95      5546          jsr       (A5)
00001D54  DEFC 0014 5547          add.w     #20,A7
                    5548   ; OS_EXIT_CRITICAL();
00001D58  46DF      5549          dc.w      18143
                    5550   ; }
                    5551   ; break;
00001D5A  6010      5552          bra.s     OSFlagPend_11
                    5553   OSFlagPend_10:
                    5554   ; #endif
                    5555   ; default:
                    5556   ; OS_EXIT_CRITICAL();
00001D5C  46DF      5557          dc.w      18143
                    5558   ; flags_rdy = (OS_FLAGS)0;
00001D5E  4242      5559          clr.w     D2
                    5560   ; *perr      = OS_ERR_FLAG_WAIT_TYPE;
00001D60  2044      5561          move.l    D4,A0
00001D62  10BC 006F 5562          move.b    #111,(A0)
                    5563   ; return (flags_rdy);
00001D66  3002      5564          move.w    D2,D0
00001D68  6000 00C2 5565          bra       OSFlagPend_3
                    5566   OSFlagPend_11:
                    5567   ; }
                    5568   ; /*$PAGE*/
                    5569   ; OS_Sched();                                            /* Find next HPT ready to run               */
00001D6C  4EB8 13F8 5570          jsr       _OS_Sched
                    5571   ; OS_ENTER_CRITICAL();
00001D70  40E7      5572          dc.w      16615
00001D72  007C      5573          dc.w      124
00001D74  0700      5574          dc.w      1792
                    5575   ; if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
00001D76  2052      5576          move.l    (A2),A0
00001D78  1028 0033 5577          move.b    51(A0),D0
00001D7C  6700 0056 5578          beq       OSFlagPend_34
                    5579   ; pend_stat                = OSTCBCur->OSTCBStatPend;
00001D80  2052      5580          move.l    (A2),A0
00001D82  1D68 0033 5581          move.b    51(A0),-1(A6)
00001D86  FFFF      
                    5582   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00001D88  2052      5583          move.l    (A2),A0
00001D8A  4228 0033 5584          clr.b     51(A0)
                    5585   ; OS_FlagUnlink(&node);
00001D8E  2F0B      5586          move.l    A3,-(A7)
00001D90  4EB9 0000 5587          jsr       _OS_FlagUnlink
00001D94  2228      
00001D96  584F      5588          addq.w    #4,A7
                    5589   ; OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
00001D98  2052      5590          move.l    (A2),A0
00001D9A  4228 0032 5591          clr.b     50(A0)
                    5592   ; OS_EXIT_CRITICAL();
00001D9E  46DF      5593          dc.w      18143
                    5594   ; flags_rdy                = (OS_FLAGS)0;
00001DA0  4242      5595          clr.w     D2
                    5596   ; switch (pend_stat) {
00001DA2  102E FFFF 5597          move.b    -1(A6),D0
00001DA6  C0BC 0000 5598          and.l     #255,D0
00001DAA  00FF      
00001DAC  0C80 0000 5599          cmp.l     #2,D0
00001DB0  0002      
00001DB2  670C      5600          beq.s     OSFlagPend_38
00001DB4  6212      5601          bhi.s     OSFlagPend_39
00001DB6  0C80 0000 5602          cmp.l     #1,D0
00001DBA  0001      
00001DBC  670A      5603          beq.s     OSFlagPend_39
00001DBE  6008      5604          bra.s     OSFlagPend_39
                    5605   OSFlagPend_38:
                    5606   ; case OS_STAT_PEND_ABORT:
                    5607   ; *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
00001DC0  2044      5608          move.l    D4,A0
00001DC2  10BC 000E 5609          move.b    #14,(A0)
                    5610   ; break;
00001DC6  6006      5611          bra.s     OSFlagPend_37
                    5612   OSFlagPend_39:
                    5613   ; case OS_STAT_PEND_TO:
                    5614   ; default:
                    5615   ; *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
00001DC8  2044      5616          move.l    D4,A0
00001DCA  10BC 000A 5617          move.b    #10,(A0)
                    5618   ; break;
                    5619   OSFlagPend_37:
                    5620   ; }
                    5621   ; return (flags_rdy);
00001DCE  3002      5622          move.w    D2,D0
00001DD0  6000 005A 5623          bra       OSFlagPend_3
                    5624   OSFlagPend_34:
                    5625   ; }
                    5626   ; flags_rdy = OSTCBCur->OSTCBFlagsRdy;
00001DD4  2052      5627          move.l    (A2),A0
00001DD6  3428 002C 5628          move.w    44(A0),D2
                    5629   ; if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
00001DDA  0C07 0001 5630          cmp.b     #1,D7
00001DDE  6600 0044 5631          bne       OSFlagPend_44
                    5632   ; switch (wait_type) {
00001DE2  CCBC 0000 5633          and.l     #255,D6
00001DE6  00FF      
00001DE8  2006      5634          move.l    D6,D0
00001DEA  0C80 0000 5635          cmp.l     #4,D0
00001DEE  0004      
00001DF0  6426      5636          bhs.s     OSFlagPend_43
00001DF2  E380      5637          asl.l     #1,D0
00001DF4  303B 0806 5638          move.w    OSFlagPend_45(PC,D0.L),D0
00001DF8  4EFB 0002 5639          jmp       OSFlagPend_45(PC,D0.W)
                    5640   OSFlagPend_45:
00001DFC  0014      5641          dc.w      OSFlagPend_48-OSFlagPend_45
00001DFE  0014      5642          dc.w      OSFlagPend_48-OSFlagPend_45
00001E00  0008      5643          dc.w      OSFlagPend_46-OSFlagPend_45
00001E02  0008      5644          dc.w      OSFlagPend_46-OSFlagPend_45
                    5645   OSFlagPend_46:
                    5646   ; case OS_FLAG_WAIT_SET_ALL:
                    5647   ; case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                    5648   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
00001E04  2043      5649          move.l    D3,A0
00001E06  3002      5650          move.w    D2,D0
00001E08  4640      5651          not.w     D0
00001E0A  C168 0006 5652          and.w     D0,6(A0)
                    5653   ; break;
00001E0E  6014      5654          bra.s     OSFlagPend_44
                    5655   OSFlagPend_48:
                    5656   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5657   ; case OS_FLAG_WAIT_CLR_ALL:
                    5658   ; case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                    5659   ; pgrp->OSFlagFlags |=  flags_rdy;
00001E10  2043      5660          move.l    D3,A0
00001E12  8568 0006 5661          or.w      D2,6(A0)
                    5662   ; break;
00001E16  600C      5663          bra.s     OSFlagPend_44
                    5664   OSFlagPend_43:
                    5665   ; #endif
                    5666   ; default:
                    5667   ; OS_EXIT_CRITICAL();
00001E18  46DF      5668          dc.w      18143
                    5669   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
00001E1A  2044      5670          move.l    D4,A0
00001E1C  10BC 006F 5671          move.b    #111,(A0)
                    5672   ; return ((OS_FLAGS)0);
00001E20  4240      5673          clr.w     D0
00001E22  6008      5674          bra.s     OSFlagPend_3
                    5675   OSFlagPend_44:
                    5676   ; }
                    5677   ; }
                    5678   ; OS_EXIT_CRITICAL();
00001E24  46DF      5679          dc.w      18143
                    5680   ; *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
00001E26  2044      5681          move.l    D4,A0
00001E28  4210      5682          clr.b     (A0)
                    5683   ; return (flags_rdy);
00001E2A  3002      5684          move.w    D2,D0
                    5685   OSFlagPend_3:
00001E2C  4CDF 3CFC 5686          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001E30  4E5E      5687          unlk      A6
00001E32  4E75      5688          rts
                    5689   ; }
                    5690   ; /*$PAGE*/
                    5691   ; /*
                    5692   ; *********************************************************************************************************
                    5693   ; *                              GET FLAGS WHO CAUSED TASK TO BECOME READY
                    5694   ; *
                    5695   ; * Description: This function is called to obtain the flags that caused the task to become ready to run.
                    5696   ; *              In other words, this function allows you to tell "Who done it!".
                    5697   ; *
                    5698   ; * Arguments  : None
                    5699   ; *
                    5700   ; * Returns    : The flags that caused the task to be ready.
                    5701   ; *
                    5702   ; * Called from: Task ONLY
                    5703   ; *********************************************************************************************************
                    5704   ; */
                    5705   ; OS_FLAGS  OSFlagPendGetFlagsRdy (void)
                    5706   ; {
                    5707   _OSFlagPendGetFlagsRdy:
00001E34  4E56 FFFC 5708          link      A6,#-4
                    5709   ; OS_FLAGS      flags;
                    5710   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    5711   ; OS_CPU_SR     cpu_sr = 0u;
                    5712   ; #endif
                    5713   ; OS_ENTER_CRITICAL();
00001E38  40E7      5714          dc.w      16615
00001E3A  007C      5715          dc.w      124
00001E3C  0700      5716          dc.w      1792
                    5717   ; flags = OSTCBCur->OSTCBFlagsRdy;
00001E3E  2079 0080 5718          move.l    _OSTCBCur.L,A0
00001E42  0360      
00001E44  3D68 002C 5719          move.w    44(A0),-2(A6)
00001E48  FFFE      
                    5720   ; OS_EXIT_CRITICAL();
00001E4A  46DF      5721          dc.w      18143
                    5722   ; return (flags);
00001E4C  302E FFFE 5723          move.w    -2(A6),D0
00001E50  4E5E      5724          unlk      A6
00001E52  4E75      5725          rts
                    5726   ; }
                    5727   ; /*$PAGE*/
                    5728   ; /*
                    5729   ; *********************************************************************************************************
                    5730   ; *                                       POST EVENT FLAG BIT(S)
                    5731   ; *
                    5732   ; * Description: This function is called to set or clear some bits in an event flag group.  The bits to
                    5733   ; *              set or clear are specified by a 'bit mask'.
                    5734   ; *
                    5735   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    5736   ; *
                    5737   ; *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
                    5738   ; *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
                    5739   ; *                            and 5 you would set 'flags' to:
                    5740   ; *
                    5741   ; *                                0x31     (note, bit 0 is least significant bit)
                    5742   ; *
                    5743   ; *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
                    5744   ; *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
                    5745   ; *                            4 and 5 you would specify 'flags' as:
                    5746   ; *
                    5747   ; *                                0x31     (note, bit 0 is least significant bit)
                    5748   ; *
                    5749   ; *              opt           indicates whether the flags will be:
                    5750   ; *                                set     (OS_FLAG_SET) or
                    5751   ; *                                cleared (OS_FLAG_CLR)
                    5752   ; *
                    5753   ; *              perr          is a pointer to an error code and can be:
                    5754   ; *                            OS_ERR_NONE                The call was successfull
                    5755   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    5756   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    5757   ; *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
                    5758   ; *
                    5759   ; * Returns    : the new value of the event flags bits that are still set.
                    5760   ; *
                    5761   ; * Called From: Task or ISR
                    5762   ; *
                    5763   ; * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
                    5764   ; *                 flag group.
                    5765   ; *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
                    5766   ; *                 the event flag group.
                    5767   ; *********************************************************************************************************
                    5768   ; */
                    5769   ; OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
                    5770   ; OS_FLAGS      flags,
                    5771   ; INT8U         opt,
                    5772   ; INT8U        *perr)
                    5773   ; {
                    5774   _OSFlagPost:
00001E54  4E56 FFFC 5775          link      A6,#-4
00001E58  48E7 3F20 5776          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00001E5C  282E 0008 5777          move.l    8(A6),D4
00001E60  45F9 0000 5778          lea       @ucos_ii_OS_FlagTaskRdy.L,A2
00001E64  21AC      
00001E66  2E2E 0014 5779          move.l    20(A6),D7
                    5780   ; OS_FLAG_NODE *pnode;
                    5781   ; BOOLEAN       sched;
                    5782   ; OS_FLAGS      flags_cur;
                    5783   ; OS_FLAGS      flags_rdy;
                    5784   ; BOOLEAN       rdy;
                    5785   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    5786   ; OS_CPU_SR     cpu_sr = 0u;
                    5787   ; #endif
                    5788   ; #ifdef OS_SAFETY_CRITICAL
                    5789   ; if (perr == (INT8U *)0) {
                    5790   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    5791   ; return ((OS_FLAGS)0);
                    5792   ; }
                    5793   ; #endif
                    5794   ; #if OS_ARG_CHK_EN > 0u
                    5795   ; if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
                    5796   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    5797   ; return ((OS_FLAGS)0);
                    5798   ; }
                    5799   ; #endif
                    5800   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
00001E6A  2044      5801          move.l    D4,A0
00001E6C  1010      5802          move.b    (A0),D0
00001E6E  0C00 0005 5803          cmp.b     #5,D0
00001E72  670C      5804          beq.s     OSFlagPost_1
                    5805   ; *perr = OS_ERR_EVENT_TYPE;
00001E74  2047      5806          move.l    D7,A0
00001E76  10BC 0001 5807          move.b    #1,(A0)
                    5808   ; return ((OS_FLAGS)0);
00001E7A  4240      5809          clr.w     D0
00001E7C  6000 018C 5810          bra       OSFlagPost_3
                    5811   OSFlagPost_1:
                    5812   ; }
                    5813   ; /*$PAGE*/
                    5814   ; OS_ENTER_CRITICAL();
00001E80  40E7      5815          dc.w      16615
00001E82  007C      5816          dc.w      124
00001E84  0700      5817          dc.w      1792
                    5818   ; switch (opt) {
00001E86  102E 0013 5819          move.b    19(A6),D0
00001E8A  C0BC 0000 5820          and.l     #255,D0
00001E8E  00FF      
00001E90  0C80 0000 5821          cmp.l     #1,D0
00001E94  0001      
00001E96  6716      5822          beq.s     OSFlagPost_7
00001E98  6220      5823          bhi.s     OSFlagPost_4
00001E9A  4A80      5824          tst.l     D0
00001E9C  6702      5825          beq.s     OSFlagPost_6
00001E9E  601A      5826          bra.s     OSFlagPost_4
                    5827   OSFlagPost_6:
                    5828   ; case OS_FLAG_CLR:
                    5829   ; pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
00001EA0  2044      5830          move.l    D4,A0
00001EA2  302E 000E 5831          move.w    14(A6),D0
00001EA6  4640      5832          not.w     D0
00001EA8  C168 0006 5833          and.w     D0,6(A0)
                    5834   ; break;
00001EAC  601A      5835          bra.s     OSFlagPost_5
                    5836   OSFlagPost_7:
                    5837   ; case OS_FLAG_SET:
                    5838   ; pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
00001EAE  2044      5839          move.l    D4,A0
00001EB0  302E 000E 5840          move.w    14(A6),D0
00001EB4  8168 0006 5841          or.w      D0,6(A0)
                    5842   ; break;
00001EB8  600E      5843          bra.s     OSFlagPost_5
                    5844   OSFlagPost_4:
                    5845   ; default:
                    5846   ; OS_EXIT_CRITICAL();                     /* INVALID option                                 */
00001EBA  46DF      5847          dc.w      18143
                    5848   ; *perr = OS_ERR_FLAG_INVALID_OPT;
00001EBC  2047      5849          move.l    D7,A0
00001EBE  10BC 0071 5850          move.b    #113,(A0)
                    5851   ; return ((OS_FLAGS)0);
00001EC2  4240      5852          clr.w     D0
00001EC4  6000 0144 5853          bra       OSFlagPost_3
                    5854   OSFlagPost_5:
                    5855   ; }
                    5856   ; sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
00001EC8  4206      5857          clr.b     D6
                    5858   ; pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
00001ECA  2044      5859          move.l    D4,A0
00001ECC  2428 0002 5860          move.l    2(A0),D2
                    5861   ; while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
                    5862   OSFlagPost_9:
00001ED0  4A82      5863          tst.l     D2
00001ED2  6700 0112 5864          beq       OSFlagPost_11
                    5865   ; switch (pnode->OSFlagNodeWaitType) {
00001ED6  2042      5866          move.l    D2,A0
00001ED8  1028 0012 5867          move.b    18(A0),D0
00001EDC  C0BC 0000 5868          and.l     #255,D0
00001EE0  00FF      
00001EE2  0C80 0000 5869          cmp.l     #4,D0
00001EE6  0004      
00001EE8  6400 00E6 5870          bhs       OSFlagPost_12
00001EEC  E380      5871          asl.l     #1,D0
00001EEE  303B 0806 5872          move.w    OSFlagPost_14(PC,D0.L),D0
00001EF2  4EFB 0002 5873          jmp       OSFlagPost_14(PC,D0.W)
                    5874   OSFlagPost_14:
00001EF6  0070      5875          dc.w      OSFlagPost_17-OSFlagPost_14
00001EF8  00A8      5876          dc.w      OSFlagPost_18-OSFlagPost_14
00001EFA  0008      5877          dc.w      OSFlagPost_15-OSFlagPost_14
00001EFC  003E      5878          dc.w      OSFlagPost_16-OSFlagPost_14
                    5879   OSFlagPost_15:
                    5880   ; case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                    5881   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
00001EFE  2044      5882          move.l    D4,A0
00001F00  3028 0006 5883          move.w    6(A0),D0
00001F04  2042      5884          move.l    D2,A0
00001F06  C068 0010 5885          and.w     16(A0),D0
00001F0A  3600      5886          move.w    D0,D3
                    5887   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
00001F0C  2042      5888          move.l    D2,A0
00001F0E  B668 0010 5889          cmp.w     16(A0),D3
00001F12  661C      5890          bne.s     OSFlagPost_22
                    5891   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00001F14  42A7      5892          clr.l     -(A7)
00001F16  C6BC 0000 5893          and.l     #65535,D3
00001F1A  FFFF      
00001F1C  2F03      5894          move.l    D3,-(A7)
00001F1E  2F02      5895          move.l    D2,-(A7)
00001F20  4E92      5896          jsr       (A2)
00001F22  DEFC 000C 5897          add.w     #12,A7
00001F26  1A00      5898          move.b    D0,D5
                    5899   ; if (rdy == OS_TRUE) {
00001F28  0C05 0001 5900          cmp.b     #1,D5
00001F2C  6602      5901          bne.s     OSFlagPost_22
                    5902   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00001F2E  7C01      5903          moveq     #1,D6
                    5904   OSFlagPost_22:
                    5905   ; }
                    5906   ; }
                    5907   ; break;
00001F30  6000 00AC 5908          bra       OSFlagPost_13
                    5909   OSFlagPost_16:
                    5910   ; case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                    5911   ; flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
00001F34  2044      5912          move.l    D4,A0
00001F36  3028 0006 5913          move.w    6(A0),D0
00001F3A  2042      5914          move.l    D2,A0
00001F3C  C068 0010 5915          and.w     16(A0),D0
00001F40  3600      5916          move.w    D0,D3
                    5917   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
00001F42  4A43      5918          tst.w     D3
00001F44  671C      5919          beq.s     OSFlagPost_26
                    5920   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00001F46  42A7      5921          clr.l     -(A7)
00001F48  C6BC 0000 5922          and.l     #65535,D3
00001F4C  FFFF      
00001F4E  2F03      5923          move.l    D3,-(A7)
00001F50  2F02      5924          move.l    D2,-(A7)
00001F52  4E92      5925          jsr       (A2)
00001F54  DEFC 000C 5926          add.w     #12,A7
00001F58  1A00      5927          move.b    D0,D5
                    5928   ; if (rdy == OS_TRUE) {
00001F5A  0C05 0001 5929          cmp.b     #1,D5
00001F5E  6602      5930          bne.s     OSFlagPost_26
                    5931   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00001F60  7C01      5932          moveq     #1,D6
                    5933   OSFlagPost_26:
                    5934   ; }
                    5935   ; }
                    5936   ; break;
00001F62  6000 007A 5937          bra       OSFlagPost_13
                    5938   OSFlagPost_17:
                    5939   ; #if OS_FLAG_WAIT_CLR_EN > 0u
                    5940   ; case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                    5941   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
00001F66  2044      5942          move.l    D4,A0
00001F68  3028 0006 5943          move.w    6(A0),D0
00001F6C  4640      5944          not.w     D0
00001F6E  2042      5945          move.l    D2,A0
00001F70  C068 0010 5946          and.w     16(A0),D0
00001F74  3600      5947          move.w    D0,D3
                    5948   ; if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
00001F76  2042      5949          move.l    D2,A0
00001F78  B668 0010 5950          cmp.w     16(A0),D3
00001F7C  661C      5951          bne.s     OSFlagPost_30
                    5952   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00001F7E  42A7      5953          clr.l     -(A7)
00001F80  C6BC 0000 5954          and.l     #65535,D3
00001F84  FFFF      
00001F86  2F03      5955          move.l    D3,-(A7)
00001F88  2F02      5956          move.l    D2,-(A7)
00001F8A  4E92      5957          jsr       (A2)
00001F8C  DEFC 000C 5958          add.w     #12,A7
00001F90  1A00      5959          move.b    D0,D5
                    5960   ; if (rdy == OS_TRUE) {
00001F92  0C05 0001 5961          cmp.b     #1,D5
00001F96  6602      5962          bne.s     OSFlagPost_30
                    5963   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00001F98  7C01      5964          moveq     #1,D6
                    5965   OSFlagPost_30:
                    5966   ; }
                    5967   ; }
                    5968   ; break;
00001F9A  6000 0042 5969          bra       OSFlagPost_13
                    5970   OSFlagPost_18:
                    5971   ; case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                    5972   ; flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
00001F9E  2044      5973          move.l    D4,A0
00001FA0  3028 0006 5974          move.w    6(A0),D0
00001FA4  4640      5975          not.w     D0
00001FA6  2042      5976          move.l    D2,A0
00001FA8  C068 0010 5977          and.w     16(A0),D0
00001FAC  3600      5978          move.w    D0,D3
                    5979   ; if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
00001FAE  4A43      5980          tst.w     D3
00001FB0  671C      5981          beq.s     OSFlagPost_34
                    5982   ; rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
00001FB2  42A7      5983          clr.l     -(A7)
00001FB4  C6BC 0000 5984          and.l     #65535,D3
00001FB8  FFFF      
00001FBA  2F03      5985          move.l    D3,-(A7)
00001FBC  2F02      5986          move.l    D2,-(A7)
00001FBE  4E92      5987          jsr       (A2)
00001FC0  DEFC 000C 5988          add.w     #12,A7
00001FC4  1A00      5989          move.b    D0,D5
                    5990   ; if (rdy == OS_TRUE) {
00001FC6  0C05 0001 5991          cmp.b     #1,D5
00001FCA  6602      5992          bne.s     OSFlagPost_34
                    5993   ; sched = OS_TRUE;                     /* When done we will reschedule          */
00001FCC  7C01      5994          moveq     #1,D6
                    5995   OSFlagPost_34:
                    5996   ; }
                    5997   ; }
                    5998   ; break;
00001FCE  600E      5999          bra.s     OSFlagPost_13
                    6000   OSFlagPost_12:
                    6001   ; #endif
                    6002   ; default:
                    6003   ; OS_EXIT_CRITICAL();
00001FD0  46DF      6004          dc.w      18143
                    6005   ; *perr = OS_ERR_FLAG_WAIT_TYPE;
00001FD2  2047      6006          move.l    D7,A0
00001FD4  10BC 006F 6007          move.b    #111,(A0)
                    6008   ; return ((OS_FLAGS)0);
00001FD8  4240      6009          clr.w     D0
00001FDA  6000 002E 6010          bra       OSFlagPost_3
                    6011   OSFlagPost_13:
                    6012   ; }
                    6013   ; pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
00001FDE  2042      6014          move.l    D2,A0
00001FE0  2410      6015          move.l    (A0),D2
00001FE2  6000 FEEC 6016          bra       OSFlagPost_9
                    6017   OSFlagPost_11:
                    6018   ; }
                    6019   ; OS_EXIT_CRITICAL();
00001FE6  46DF      6020          dc.w      18143
                    6021   ; if (sched == OS_TRUE) {
00001FE8  0C06 0001 6022          cmp.b     #1,D6
00001FEC  6604      6023          bne.s     OSFlagPost_36
                    6024   ; OS_Sched();
00001FEE  4EB8 13F8 6025          jsr       _OS_Sched
                    6026   OSFlagPost_36:
                    6027   ; }
                    6028   ; OS_ENTER_CRITICAL();
00001FF2  40E7      6029          dc.w      16615
00001FF4  007C      6030          dc.w      124
00001FF6  0700      6031          dc.w      1792
                    6032   ; flags_cur = pgrp->OSFlagFlags;
00001FF8  2044      6033          move.l    D4,A0
00001FFA  3D68 0006 6034          move.w    6(A0),-2(A6)
00001FFE  FFFE      
                    6035   ; OS_EXIT_CRITICAL();
00002000  46DF      6036          dc.w      18143
                    6037   ; *perr     = OS_ERR_NONE;
00002002  2047      6038          move.l    D7,A0
00002004  4210      6039          clr.b     (A0)
                    6040   ; return (flags_cur);
00002006  302E FFFE 6041          move.w    -2(A6),D0
                    6042   OSFlagPost_3:
0000200A  4CDF 04FC 6043          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
0000200E  4E5E      6044          unlk      A6
00002010  4E75      6045          rts
                    6046   ; }
                    6047   ; /*$PAGE*/
                    6048   ; /*
                    6049   ; *********************************************************************************************************
                    6050   ; *                                          QUERY EVENT FLAG
                    6051   ; *
                    6052   ; * Description: This function is used to check the value of the event flag group.
                    6053   ; *
                    6054   ; * Arguments  : pgrp         is a pointer to the desired event flag group.
                    6055   ; *
                    6056   ; *              perr          is a pointer to an error code returned to the called:
                    6057   ; *                            OS_ERR_NONE                The call was successfull
                    6058   ; *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
                    6059   ; *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
                    6060   ; *
                    6061   ; * Returns    : The current value of the event flag group.
                    6062   ; *
                    6063   ; * Called From: Task or ISR
                    6064   ; *********************************************************************************************************
                    6065   ; */
                    6066   ; #if OS_FLAG_QUERY_EN > 0u
                    6067   ; OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
                    6068   ; INT8U        *perr)
                    6069   ; {
                    6070   _OSFlagQuery:
00002012  4E56 FFFC 6071          link      A6,#-4
                    6072   ; OS_FLAGS   flags;
                    6073   ; #if OS_CRITICAL_METHOD == 3u                      /* Allocate storage for CPU status register          */
                    6074   ; OS_CPU_SR  cpu_sr = 0u;
                    6075   ; #endif
                    6076   ; #ifdef OS_SAFETY_CRITICAL
                    6077   ; if (perr == (INT8U *)0) {
                    6078   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6079   ; return ((OS_FLAGS)0);
                    6080   ; }
                    6081   ; #endif
                    6082   ; #if OS_ARG_CHK_EN > 0u
                    6083   ; if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
                    6084   ; *perr = OS_ERR_FLAG_INVALID_PGRP;
                    6085   ; return ((OS_FLAGS)0);
                    6086   ; }
                    6087   ; #endif
                    6088   ; if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
00002016  206E 0008 6089          move.l    8(A6),A0
0000201A  1010      6090          move.b    (A0),D0
0000201C  0C00 0005 6091          cmp.b     #5,D0
00002020  670C      6092          beq.s     OSFlagQuery_1
                    6093   ; *perr = OS_ERR_EVENT_TYPE;
00002022  206E 000C 6094          move.l    12(A6),A0
00002026  10BC 0001 6095          move.b    #1,(A0)
                    6096   ; return ((OS_FLAGS)0);
0000202A  4240      6097          clr.w     D0
0000202C  601C      6098          bra.s     OSFlagQuery_3
                    6099   OSFlagQuery_1:
                    6100   ; }
                    6101   ; OS_ENTER_CRITICAL();
0000202E  40E7      6102          dc.w      16615
00002030  007C      6103          dc.w      124
00002032  0700      6104          dc.w      1792
                    6105   ; flags = pgrp->OSFlagFlags;
00002034  206E 0008 6106          move.l    8(A6),A0
00002038  3D68 0006 6107          move.w    6(A0),-2(A6)
0000203C  FFFE      
                    6108   ; OS_EXIT_CRITICAL();
0000203E  46DF      6109          dc.w      18143
                    6110   ; *perr = OS_ERR_NONE;
00002040  206E 000C 6111          move.l    12(A6),A0
00002044  4210      6112          clr.b     (A0)
                    6113   ; return (flags);                               /* Return the current value of the event flags       */
00002046  302E FFFE 6114          move.w    -2(A6),D0
                    6115   OSFlagQuery_3:
0000204A  4E5E      6116          unlk      A6
0000204C  4E75      6117          rts
                    6118   ; }
                    6119   ; #endif
                    6120   ; /*$PAGE*/
                    6121   ; /*
                    6122   ; *********************************************************************************************************
                    6123   ; *                     SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
                    6124   ; *
                    6125   ; * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
                    6126   ; *              event flag bit(s) are set.
                    6127   ; *
                    6128   ; * Arguments  : pgrp          is a pointer to the desired event flag group.
                    6129   ; *
                    6130   ; *              pnode         is a pointer to a structure which contains data about the task waiting for
                    6131   ; *                            event flag bit(s) to be set.
                    6132   ; *
                    6133   ; *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
                    6134   ; *                            The bits you want are specified by setting the corresponding bits in
                    6135   ; *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
                    6136   ; *                            'flags' would contain 0x03.
                    6137   ; *
                    6138   ; *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
                    6139   ; *                            to be set/cleared.
                    6140   ; *                            You can specify the following argument:
                    6141   ; *
                    6142   ; *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
                    6143   ; *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
                    6144   ; *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
                    6145   ; *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
                    6146   ; *
                    6147   ; *              timeout       is the desired amount of time that the task will wait for the event flag
                    6148   ; *                            bit(s) to be set.
                    6149   ; *
                    6150   ; * Returns    : none
                    6151   ; *
                    6152   ; * Called by  : OSFlagPend()  OS_FLAG.C
                    6153   ; *
                    6154   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    6155   ; *********************************************************************************************************
                    6156   ; */
                    6157   ; static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
                    6158   ; OS_FLAG_NODE *pnode,
                    6159   ; OS_FLAGS      flags,
                    6160   ; INT8U         wait_type,
                    6161   ; INT32U        timeout)
                    6162   ; {
                    6163   @ucos_ii_OS_FlagBlock:
0000204E  4E56 0000 6164          link      A6,#0
00002052  48E7 3C20 6165          movem.l   D2/D3/D4/D5/A2,-(A7)
00002056  242E 000C 6166          move.l    12(A6),D2
0000205A  45F9 0080 6167          lea       _OSTCBCur.L,A2
0000205E  0360      
00002060  262E 0008 6168          move.l    8(A6),D3
                    6169   ; OS_FLAG_NODE  *pnode_next;
                    6170   ; INT8U          y;
                    6171   ; OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
00002064  2052      6172          move.l    (A2),A0
00002066  0028 0020 6173          or.b      #32,50(A0)
0000206A  0032      
                    6174   ; OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
0000206C  2052      6175          move.l    (A2),A0
0000206E  4228 0033 6176          clr.b     51(A0)
                    6177   ; OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
00002072  2052      6178          move.l    (A2),A0
00002074  216E 0018 6179          move.l    24(A6),46(A0)
00002078  002E      
                    6180   ; #if OS_TASK_DEL_EN > 0u
                    6181   ; OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
0000207A  2052      6182          move.l    (A2),A0
0000207C  2142 0028 6183          move.l    D2,40(A0)
                    6184   ; #endif
                    6185   ; pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
00002080  2042      6186          move.l    D2,A0
00002082  316E 0012 6187          move.w    18(A6),16(A0)
00002086  0010      
                    6188   ; pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
00002088  2042      6189          move.l    D2,A0
0000208A  116E 0017 6190          move.b    23(A6),18(A0)
0000208E  0012      
                    6191   ; pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
00002090  2042      6192          move.l    D2,A0
00002092  2152 0008 6193          move.l    (A2),8(A0)
                    6194   ; pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
00002096  2043      6195          move.l    D3,A0
00002098  2242      6196          move.l    D2,A1
0000209A  22A8 0002 6197          move.l    2(A0),(A1)
                    6198   ; pnode->OSFlagNodePrev     = (void *)0;
0000209E  2042      6199          move.l    D2,A0
000020A0  42A8 0004 6200          clr.l     4(A0)
                    6201   ; pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
000020A4  2042      6202          move.l    D2,A0
000020A6  2143 000C 6203          move.l    D3,12(A0)
                    6204   ; pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
000020AA  2043      6205          move.l    D3,A0
000020AC  2A28 0002 6206          move.l    2(A0),D5
                    6207   ; if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
000020B0  4A85      6208          tst.l     D5
000020B2  6706      6209          beq.s     @ucos_ii_OS_FlagBlock_1
                    6210   ; pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
000020B4  2045      6211          move.l    D5,A0
000020B6  2142 0004 6212          move.l    D2,4(A0)
                    6213   @ucos_ii_OS_FlagBlock_1:
                    6214   ; }
                    6215   ; pgrp->OSFlagWaitList = (void *)pnode;
000020BA  2043      6216          move.l    D3,A0
000020BC  2142 0002 6217          move.l    D2,2(A0)
                    6218   ; y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
000020C0  2052      6219          move.l    (A2),A0
000020C2  1828 0036 6220          move.b    54(A0),D4
                    6221   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
000020C6  C8BC 0000 6222          and.l     #255,D4
000020CA  00FF      
000020CC  41F9 0080 6223          lea       _OSRdyTbl.L,A0
000020D0  0250      
000020D2  2252      6224          move.l    (A2),A1
000020D4  1029 0037 6225          move.b    55(A1),D0
000020D8  4600      6226          not.b     D0
000020DA  C130 4800 6227          and.b     D0,0(A0,D4.L)
                    6228   ; if (OSRdyTbl[y] == 0x00u) {
000020DE  C8BC 0000 6229          and.l     #255,D4
000020E2  00FF      
000020E4  41F9 0080 6230          lea       _OSRdyTbl.L,A0
000020E8  0250      
000020EA  1030 4800 6231          move.b    0(A0,D4.L),D0
000020EE  660E      6232          bne.s     @ucos_ii_OS_FlagBlock_3
                    6233   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000020F0  2052      6234          move.l    (A2),A0
000020F2  1028 0038 6235          move.b    56(A0),D0
000020F6  4600      6236          not.b     D0
000020F8  C139 0080 6237          and.b     D0,_OSRdyGrp.L
000020FC  024E      
                    6238   @ucos_ii_OS_FlagBlock_3:
000020FE  4CDF 043C 6239          movem.l   (A7)+,D2/D3/D4/D5/A2
00002102  4E5E      6240          unlk      A6
00002104  4E75      6241          rts
                    6242   ; }
                    6243   ; }
                    6244   ; /*$PAGE*/
                    6245   ; /*
                    6246   ; *********************************************************************************************************
                    6247   ; *                                  INITIALIZE THE EVENT FLAG MODULE
                    6248   ; *
                    6249   ; * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
                    6250   ; *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
                    6251   ; *
                    6252   ; * Arguments  : none
                    6253   ; *
                    6254   ; * Returns    : none
                    6255   ; *
                    6256   ; * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
                    6257   ; *********************************************************************************************************
                    6258   ; */
                    6259   ; void  OS_FlagInit (void)
                    6260   ; {
                    6261   _OS_FlagInit:
00002106  4E56 FFF8 6262          link      A6,#-8
0000210A  48E7 3020 6263          movem.l   D2/D3/A2,-(A7)
0000210E  45F9 0080 6264          lea       _OSFlagTbl.L,A2
00002112  00FA      
                    6265   ; #if OS_MAX_FLAGS == 1u
                    6266   ; OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
                    6267   ; OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
                    6268   ; OSFlagFreeList->OSFlagWaitList = (void *)0;
                    6269   ; OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
                    6270   ; #if OS_FLAG_NAME_EN > 0u
                    6271   ; OSFlagFreeList->OSFlagName     = (INT8U *)"?";
                    6272   ; #endif
                    6273   ; #endif
                    6274   ; #if OS_MAX_FLAGS >= 2u
                    6275   ; INT16U        ix;
                    6276   ; INT16U        ix_next;
                    6277   ; OS_FLAG_GRP  *pgrp1;
                    6278   ; OS_FLAG_GRP  *pgrp2;
                    6279   ; OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
00002114  4878 003C 6280          pea       60
00002118  2F0A      6281          move.l    A2,-(A7)
0000211A  4EB8 13AC 6282          jsr       _OS_MemClr
0000211E  504F      6283          addq.w    #8,A7
                    6284   ; for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
00002120  4243      6285          clr.w     D3
                    6286   OS_FlagInit_1:
00002122  0C43 0004 6287          cmp.w     #4,D3
00002126  6400 004E 6288          bhs       OS_FlagInit_3
                    6289   ; ix_next = ix + 1u;
0000212A  3003      6290          move.w    D3,D0
0000212C  5240      6291          addq.w    #1,D0
0000212E  3D40 FFFA 6292          move.w    D0,-6(A6)
                    6293   ; pgrp1 = &OSFlagTbl[ix];
00002132  200A      6294          move.l    A2,D0
00002134  C6BC 0000 6295          and.l     #65535,D3
00002138  FFFF      
0000213A  2203      6296          move.l    D3,D1
0000213C  C3FC 000C 6297          muls      #12,D1
00002140  D081      6298          add.l     D1,D0
00002142  2400      6299          move.l    D0,D2
                    6300   ; pgrp2 = &OSFlagTbl[ix_next];
00002144  200A      6301          move.l    A2,D0
00002146  322E FFFA 6302          move.w    -6(A6),D1
0000214A  C2BC 0000 6303          and.l     #65535,D1
0000214E  FFFF      
00002150  C3FC 000C 6304          muls      #12,D1
00002154  D081      6305          add.l     D1,D0
00002156  2D40 FFFC 6306          move.l    D0,-4(A6)
                    6307   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
0000215A  2042      6308          move.l    D2,A0
0000215C  4210      6309          clr.b     (A0)
                    6310   ; pgrp1->OSFlagWaitList = (void *)pgrp2;
0000215E  2042      6311          move.l    D2,A0
00002160  216E FFFC 6312          move.l    -4(A6),2(A0)
00002164  0002      
                    6313   ; #if OS_FLAG_NAME_EN > 0u
                    6314   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
00002166  41F9 0000 6315          lea       @ucos_ii_1.L,A0
0000216A  5A8E      
0000216C  2242      6316          move.l    D2,A1
0000216E  2348 0008 6317          move.l    A0,8(A1)
00002172  5243      6318          addq.w    #1,D3
00002174  60AC      6319          bra       OS_FlagInit_1
                    6320   OS_FlagInit_3:
                    6321   ; #endif
                    6322   ; }
                    6323   ; pgrp1                 = &OSFlagTbl[ix];
00002176  200A      6324          move.l    A2,D0
00002178  C6BC 0000 6325          and.l     #65535,D3
0000217C  FFFF      
0000217E  2203      6326          move.l    D3,D1
00002180  C3FC 000C 6327          muls      #12,D1
00002184  D081      6328          add.l     D1,D0
00002186  2400      6329          move.l    D0,D2
                    6330   ; pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
00002188  2042      6331          move.l    D2,A0
0000218A  4210      6332          clr.b     (A0)
                    6333   ; pgrp1->OSFlagWaitList = (void *)0;
0000218C  2042      6334          move.l    D2,A0
0000218E  42A8 0002 6335          clr.l     2(A0)
                    6336   ; #if OS_FLAG_NAME_EN > 0u
                    6337   ; pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
00002192  41F9 0000 6338          lea       @ucos_ii_1.L,A0
00002196  5A8E      
00002198  2242      6339          move.l    D2,A1
0000219A  2348 0008 6340          move.l    A0,8(A1)
                    6341   ; #endif
                    6342   ; OSFlagFreeList        = &OSFlagTbl[0];
0000219E  23CA 0080 6343          move.l    A2,_OSFlagFreeList.L
000021A2  0136      
000021A4  4CDF 040C 6344          movem.l   (A7)+,D2/D3/A2
000021A8  4E5E      6345          unlk      A6
000021AA  4E75      6346          rts
                    6347   ; #endif
                    6348   ; }
                    6349   ; /*$PAGE*/
                    6350   ; /*
                    6351   ; *********************************************************************************************************
                    6352   ; *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
                    6353   ; *
                    6354   ; * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
                    6355   ; *              desired event flag bits have been set.
                    6356   ; *
                    6357   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6358   ; *                            event flag bit(s) to be set.
                    6359   ; *
                    6360   ; *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
                    6361   ; *                            ready-to-run.
                    6362   ; *
                    6363   ; *              pend_stat   is used to indicate the readied task's pending status:
                    6364   ; *
                    6365   ; *
                    6366   ; * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
                    6367   ; *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
                    6368   ; *
                    6369   ; * Called by  : OSFlagsPost() OS_FLAG.C
                    6370   ; *
                    6371   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6372   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6373   ; *********************************************************************************************************
                    6374   ; */
                    6375   ; static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
                    6376   ; OS_FLAGS      flags_rdy,
                    6377   ; INT8U         pend_stat)
                    6378   ; {
                    6379   @ucos_ii_OS_FlagTaskRdy:
000021AC  4E56 0000 6380          link      A6,#0
000021B0  48E7 3000 6381          movem.l   D2/D3,-(A7)
                    6382   ; OS_TCB   *ptcb;
                    6383   ; BOOLEAN   sched;
                    6384   ; ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
000021B4  206E 0008 6385          move.l    8(A6),A0
000021B8  2428 0008 6386          move.l    8(A0),D2
                    6387   ; ptcb->OSTCBDly       = 0u;
000021BC  2042      6388          move.l    D2,A0
000021BE  42A8 002E 6389          clr.l     46(A0)
                    6390   ; ptcb->OSTCBFlagsRdy  = flags_rdy;
000021C2  2042      6391          move.l    D2,A0
000021C4  316E 000E 6392          move.w    14(A6),44(A0)
000021C8  002C      
                    6393   ; ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
000021CA  2042      6394          move.l    D2,A0
000021CC  7020      6395          moveq     #32,D0
000021CE  4600      6396          not.b     D0
000021D0  C128 0032 6397          and.b     D0,50(A0)
                    6398   ; ptcb->OSTCBStatPend  = pend_stat;
000021D4  2042      6399          move.l    D2,A0
000021D6  116E 0013 6400          move.b    19(A6),51(A0)
000021DA  0033      
                    6401   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
000021DC  2042      6402          move.l    D2,A0
000021DE  1028 0032 6403          move.b    50(A0),D0
000021E2  662C      6404          bne.s     @ucos_ii_OS_FlagTaskRdy_1
                    6405   ; OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
000021E4  2042      6406          move.l    D2,A0
000021E6  1028 0038 6407          move.b    56(A0),D0
000021EA  8139 0080 6408          or.b      D0,_OSRdyGrp.L
000021EE  024E      
                    6409   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000021F0  2042      6410          move.l    D2,A0
000021F2  1028 0036 6411          move.b    54(A0),D0
000021F6  C0BC 0000 6412          and.l     #255,D0
000021FA  00FF      
000021FC  41F9 0080 6413          lea       _OSRdyTbl.L,A0
00002200  0250      
00002202  2242      6414          move.l    D2,A1
00002204  1229 0037 6415          move.b    55(A1),D1
00002208  8330 0800 6416          or.b      D1,0(A0,D0.L)
                    6417   ; sched                   = OS_TRUE;
0000220C  7601      6418          moveq     #1,D3
0000220E  6002      6419          bra.s     @ucos_ii_OS_FlagTaskRdy_2
                    6420   @ucos_ii_OS_FlagTaskRdy_1:
                    6421   ; } else {
                    6422   ; sched                   = OS_FALSE;
00002210  4203      6423          clr.b     D3
                    6424   @ucos_ii_OS_FlagTaskRdy_2:
                    6425   ; }
                    6426   ; OS_FlagUnlink(pnode);
00002212  2F2E 0008 6427          move.l    8(A6),-(A7)
00002216  4EB9 0000 6428          jsr       _OS_FlagUnlink
0000221A  2228      
0000221C  584F      6429          addq.w    #4,A7
                    6430   ; return (sched);
0000221E  1003      6431          move.b    D3,D0
00002220  4CDF 000C 6432          movem.l   (A7)+,D2/D3
00002224  4E5E      6433          unlk      A6
00002226  4E75      6434          rts
                    6435   ; }
                    6436   ; /*$PAGE*/
                    6437   ; /*
                    6438   ; *********************************************************************************************************
                    6439   ; *                              UNLINK EVENT FLAG NODE FROM WAITING LIST
                    6440   ; *
                    6441   ; * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
                    6442   ; *              list of tasks waiting for the event flag.
                    6443   ; *
                    6444   ; * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
                    6445   ; *                            event flag bit(s) to be set.
                    6446   ; *
                    6447   ; * Returns    : none
                    6448   ; *
                    6449   ; * Called by  : OS_FlagTaskRdy() OS_FLAG.C
                    6450   ; *              OSFlagPend()     OS_FLAG.C
                    6451   ; *              OSTaskDel()      OS_TASK.C
                    6452   ; *
                    6453   ; * Note(s)    : 1) This function assumes that interrupts are disabled.
                    6454   ; *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
                    6455   ; *********************************************************************************************************
                    6456   ; */
                    6457   ; void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
                    6458   ; {
                    6459   _OS_FlagUnlink:
00002228  4E56 FFF8 6460          link      A6,#-8
0000222C  48E7 3800 6461          movem.l   D2/D3/D4,-(A7)
00002230  262E 0008 6462          move.l    8(A6),D3
                    6463   ; #if OS_TASK_DEL_EN > 0u
                    6464   ; OS_TCB       *ptcb;
                    6465   ; #endif
                    6466   ; OS_FLAG_GRP  *pgrp;
                    6467   ; OS_FLAG_NODE *pnode_prev;
                    6468   ; OS_FLAG_NODE *pnode_next;
                    6469   ; pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
00002234  2043      6470          move.l    D3,A0
00002236  2828 0004 6471          move.l    4(A0),D4
                    6472   ; pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
0000223A  2043      6473          move.l    D3,A0
0000223C  2410      6474          move.l    (A0),D2
                    6475   ; if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
0000223E  4A84      6476          tst.l     D4
00002240  661C      6477          bne.s     OS_FlagUnlink_1
                    6478   ; pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
00002242  2043      6479          move.l    D3,A0
00002244  2D68 000C 6480          move.l    12(A0),-4(A6)
00002248  FFFC      
                    6481   ; pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
0000224A  206E FFFC 6482          move.l    -4(A6),A0
0000224E  2142 0002 6483          move.l    D2,2(A0)
                    6484   ; if (pnode_next != (OS_FLAG_NODE *)0) {
00002252  4A82      6485          tst.l     D2
00002254  6706      6486          beq.s     OS_FlagUnlink_3
                    6487   ; pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
00002256  2042      6488          move.l    D2,A0
00002258  42A8 0004 6489          clr.l     4(A0)
                    6490   OS_FlagUnlink_3:
0000225C  600E      6491          bra.s     OS_FlagUnlink_5
                    6492   OS_FlagUnlink_1:
                    6493   ; }
                    6494   ; } else {                                                    /* No,  A node somewhere in the list   */
                    6495   ; pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
0000225E  2044      6496          move.l    D4,A0
00002260  2082      6497          move.l    D2,(A0)
                    6498   ; if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
00002262  4A82      6499          tst.l     D2
00002264  6706      6500          beq.s     OS_FlagUnlink_5
                    6501   ; pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
00002266  2042      6502          move.l    D2,A0
00002268  2144 0004 6503          move.l    D4,4(A0)
                    6504   OS_FlagUnlink_5:
                    6505   ; }
                    6506   ; }
                    6507   ; #if OS_TASK_DEL_EN > 0u
                    6508   ; ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
0000226C  2043      6509          move.l    D3,A0
0000226E  2D68 0008 6510          move.l    8(A0),-8(A6)
00002272  FFF8      
                    6511   ; ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
00002274  206E FFF8 6512          move.l    -8(A6),A0
00002278  42A8 0028 6513          clr.l     40(A0)
0000227C  4CDF 001C 6514          movem.l   (A7)+,D2/D3/D4
00002280  4E5E      6515          unlk      A6
00002282  4E75      6516          rts
                    6517   ; /*
                    6518   ; *********************************************************************************************************
                    6519   ; *                                                uC/OS-II
                    6520   ; *                                          The Real-Time Kernel
                    6521   ; *                                       MESSAGE MAILBOX MANAGEMENT
                    6522   ; *
                    6523   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    6524   ; *                                           All Rights Reserved
                    6525   ; *
                    6526   ; * File    : OS_MBOX.C
                    6527   ; * By      : Jean J. Labrosse
                    6528   ; * Version : V2.92.07
                    6529   ; *
                    6530   ; * LICENSING TERMS:
                    6531   ; * ---------------
                    6532   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    6533   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    6534   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    6535   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    6536   ; * licensing fee.
                    6537   ; *********************************************************************************************************
                    6538   ; */
                    6539   ; #define  MICRIUM_SOURCE
                    6540   ; #ifndef  OS_MASTER_FILE
                    6541   ; #include <ucos_ii.h>
                    6542   ; #endif
                    6543   ; #if OS_MBOX_EN > 0u
                    6544   ; /*
                    6545   ; *********************************************************************************************************
                    6546   ; *                                        ACCEPT MESSAGE FROM MAILBOX
                    6547   ; *
                    6548   ; * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
                    6549   ; *              OSMboxAccept() does not suspend the calling task if a message is not available.
                    6550   ; *
                    6551   ; * Arguments  : pevent        is a pointer to the event control block
                    6552   ; *
                    6553   ; * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
                    6554   ; *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
                    6555   ; *              == (void *)0  if the mailbox is empty or,
                    6556   ; *                            if 'pevent' is a NULL pointer or,
                    6557   ; *                            if you didn't pass the proper event pointer.
                    6558   ; *********************************************************************************************************
                    6559   ; */
                    6560   ; #if OS_MBOX_ACCEPT_EN > 0u
                    6561   ; void  *OSMboxAccept (OS_EVENT *pevent)
                    6562   ; {
                    6563   _OSMboxAccept:
00002284  4E56 FFFC 6564          link      A6,#-4
00002288  2F02      6565          move.l    D2,-(A7)
0000228A  242E 0008 6566          move.l    8(A6),D2
                    6567   ; void      *pmsg;
                    6568   ; #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
                    6569   ; OS_CPU_SR  cpu_sr = 0u;
                    6570   ; #endif
                    6571   ; #if OS_ARG_CHK_EN > 0u
                    6572   ; if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
                    6573   ; return ((void *)0);
                    6574   ; }
                    6575   ; #endif
                    6576   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
0000228E  2042      6577          move.l    D2,A0
00002290  1010      6578          move.b    (A0),D0
00002292  0C00 0001 6579          cmp.b     #1,D0
00002296  6704      6580          beq.s     OSMboxAccept_1
                    6581   ; return ((void *)0);
00002298  4280      6582          clr.l     D0
0000229A  601A      6583          bra.s     OSMboxAccept_3
                    6584   OSMboxAccept_1:
                    6585   ; }
                    6586   ; OS_ENTER_CRITICAL();
0000229C  40E7      6587          dc.w      16615
0000229E  007C      6588          dc.w      124
000022A0  0700      6589          dc.w      1792
                    6590   ; pmsg               = pevent->OSEventPtr;
000022A2  2042      6591          move.l    D2,A0
000022A4  2D68 0002 6592          move.l    2(A0),-4(A6)
000022A8  FFFC      
                    6593   ; pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
000022AA  2042      6594          move.l    D2,A0
000022AC  42A8 0002 6595          clr.l     2(A0)
                    6596   ; OS_EXIT_CRITICAL();
000022B0  46DF      6597          dc.w      18143
                    6598   ; return (pmsg);                                        /* Return the message received (or NULL)     */
000022B2  202E FFFC 6599          move.l    -4(A6),D0
                    6600   OSMboxAccept_3:
000022B6  241F      6601          move.l    (A7)+,D2
000022B8  4E5E      6602          unlk      A6
000022BA  4E75      6603          rts
                    6604   ; }
                    6605   ; #endif
                    6606   ; /*$PAGE*/
                    6607   ; /*
                    6608   ; *********************************************************************************************************
                    6609   ; *                                          CREATE A MESSAGE MAILBOX
                    6610   ; *
                    6611   ; * Description: This function creates a message mailbox if free event control blocks are available.
                    6612   ; *
                    6613   ; * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
                    6614   ; *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
                    6615   ; *                            will be considered empty.
                    6616   ; *
                    6617   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    6618   ; *                                created mailbox
                    6619   ; *              == (OS_EVENT *)0  if no event control blocks were available
                    6620   ; *********************************************************************************************************
                    6621   ; */
                    6622   ; OS_EVENT  *OSMboxCreate (void *pmsg)
                    6623   ; {
                    6624   _OSMboxCreate:
000022BC  4E56 0000 6625          link      A6,#0
000022C0  48E7 2020 6626          movem.l   D2/A2,-(A7)
000022C4  45F9 0080 6627          lea       _OSEventFreeList.L,A2
000022C8  001A      
                    6628   ; OS_EVENT  *pevent;
                    6629   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    6630   ; OS_CPU_SR  cpu_sr = 0u;
                    6631   ; #endif
                    6632   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    6633   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    6634   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6635   ; return ((OS_EVENT *)0);
                    6636   ; }
                    6637   ; #endif
                    6638   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000022CA  1039 0080 6639          move.b    _OSIntNesting.L,D0
000022CE  0246      
000022D0  0C00 0000 6640          cmp.b     #0,D0
000022D4  6306      6641          bls.s     OSMboxCreate_1
                    6642   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000022D6  4280      6643          clr.l     D0
000022D8  6000 0044 6644          bra       OSMboxCreate_3
                    6645   OSMboxCreate_1:
                    6646   ; }
                    6647   ; OS_ENTER_CRITICAL();
000022DC  40E7      6648          dc.w      16615
000022DE  007C      6649          dc.w      124
000022E0  0700      6650          dc.w      1792
                    6651   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
000022E2  2412      6652          move.l    (A2),D2
                    6653   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
000022E4  2012      6654          move.l    (A2),D0
000022E6  6706      6655          beq.s     OSMboxCreate_4
                    6656   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
000022E8  2052      6657          move.l    (A2),A0
000022EA  24A8 0002 6658          move.l    2(A0),(A2)
                    6659   OSMboxCreate_4:
                    6660   ; }
                    6661   ; OS_EXIT_CRITICAL();
000022EE  46DF      6662          dc.w      18143
                    6663   ; if (pevent != (OS_EVENT *)0) {
000022F0  4A82      6664          tst.l     D2
000022F2  6728      6665          beq.s     OSMboxCreate_6
                    6666   ; pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
000022F4  2042      6667          move.l    D2,A0
000022F6  10BC 0001 6668          move.b    #1,(A0)
                    6669   ; pevent->OSEventCnt     = 0u;
000022FA  2042      6670          move.l    D2,A0
000022FC  4268 0006 6671          clr.w     6(A0)
                    6672   ; pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
00002300  2042      6673          move.l    D2,A0
00002302  216E 0008 6674          move.l    8(A6),2(A0)
00002306  0002      
                    6675   ; #if OS_EVENT_NAME_EN > 0u
                    6676   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00002308  41F9 0000 6677          lea       @ucos_ii_1.L,A0
0000230C  5A8E      
0000230E  2242      6678          move.l    D2,A1
00002310  2348 0012 6679          move.l    A0,18(A1)
                    6680   ; #endif
                    6681   ; OS_EventWaitListInit(pevent);
00002314  2F02      6682          move.l    D2,-(A7)
00002316  4EB8 10E0 6683          jsr       _OS_EventWaitListInit
0000231A  584F      6684          addq.w    #4,A7
                    6685   OSMboxCreate_6:
                    6686   ; }
                    6687   ; return (pevent);                             /* Return pointer to event control block              */
0000231C  2002      6688          move.l    D2,D0
                    6689   OSMboxCreate_3:
0000231E  4CDF 0404 6690          movem.l   (A7)+,D2/A2
00002322  4E5E      6691          unlk      A6
00002324  4E75      6692          rts
                    6693   ; }
                    6694   ; /*$PAGE*/
                    6695   ; /*
                    6696   ; *********************************************************************************************************
                    6697   ; *                                           DELETE A MAIBOX
                    6698   ; *
                    6699   ; * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
                    6700   ; *
                    6701   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    6702   ; *                            mailbox.
                    6703   ; *
                    6704   ; *              opt           determines delete options as follows:
                    6705   ; *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
                    6706   ; *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
                    6707   ; *                                                    In this case, all the tasks pending will be readied.
                    6708   ; *
                    6709   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    6710   ; *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
                    6711   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
                    6712   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    6713   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
                    6714   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
                    6715   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    6716   ; *
                    6717   ; * Returns    : pevent        upon error
                    6718   ; *              (OS_EVENT *)0 if the mailbox was successfully deleted.
                    6719   ; *
                    6720   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    6721   ; *                 the mailbox MUST check the return code of OSMboxPend().
                    6722   ; *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
                    6723   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    6724   ; *                 time is directly proportional to the number of tasks waiting on the mailbox.
                    6725   ; *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
                    6726   ; *                 applications where the mailbox is used for mutual exclusion because the resource(s)
                    6727   ; *                 will no longer be guarded by the mailbox.
                    6728   ; *              5) All tasks that were waiting for the mailbox will be readied and returned an 
                    6729   ; *                 OS_ERR_PEND_ABORT if OSMboxDel() was called with OS_DEL_ALWAYS
                    6730   ; *********************************************************************************************************
                    6731   ; */
                    6732   ; #if OS_MBOX_DEL_EN > 0u
                    6733   ; OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
                    6734   ; INT8U      opt,
                    6735   ; INT8U     *perr)
                    6736   ; {
                    6737   _OSMboxDel:
00002326  4E56 0000 6738          link      A6,#0
0000232A  48E7 3C20 6739          movem.l   D2/D3/D4/D5/A2,-(A7)
0000232E  242E 0008 6740          move.l    8(A6),D2
00002332  262E 0010 6741          move.l    16(A6),D3
00002336  45F9 0080 6742          lea       _OSEventFreeList.L,A2
0000233A  001A      
                    6743   ; BOOLEAN    tasks_waiting;
                    6744   ; OS_EVENT  *pevent_return;
                    6745   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    6746   ; OS_CPU_SR  cpu_sr = 0u;
                    6747   ; #endif
                    6748   ; #ifdef OS_SAFETY_CRITICAL
                    6749   ; if (perr == (INT8U *)0) {
                    6750   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6751   ; return ((OS_EVENT *)0);
                    6752   ; }
                    6753   ; #endif
                    6754   ; #if OS_ARG_CHK_EN > 0u
                    6755   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    6756   ; *perr = OS_ERR_PEVENT_NULL;
                    6757   ; return (pevent);
                    6758   ; }
                    6759   ; #endif
                    6760   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
0000233C  2042      6761          move.l    D2,A0
0000233E  1010      6762          move.b    (A0),D0
00002340  0C00 0001 6763          cmp.b     #1,D0
00002344  670C      6764          beq.s     OSMboxDel_1
                    6765   ; *perr = OS_ERR_EVENT_TYPE;
00002346  2043      6766          move.l    D3,A0
00002348  10BC 0001 6767          move.b    #1,(A0)
                    6768   ; return (pevent);
0000234C  2002      6769          move.l    D2,D0
0000234E  6000 00EA 6770          bra       OSMboxDel_3
                    6771   OSMboxDel_1:
                    6772   ; }
                    6773   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002352  1039 0080 6774          move.b    _OSIntNesting.L,D0
00002356  0246      
00002358  0C00 0000 6775          cmp.b     #0,D0
0000235C  630C      6776          bls.s     OSMboxDel_4
                    6777   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
0000235E  2043      6778          move.l    D3,A0
00002360  10BC 000F 6779          move.b    #15,(A0)
                    6780   ; return (pevent);
00002364  2002      6781          move.l    D2,D0
00002366  6000 00D2 6782          bra       OSMboxDel_3
                    6783   OSMboxDel_4:
                    6784   ; }
                    6785   ; OS_ENTER_CRITICAL();
0000236A  40E7      6786          dc.w      16615
0000236C  007C      6787          dc.w      124
0000236E  0700      6788          dc.w      1792
                    6789   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
00002370  2042      6790          move.l    D2,A0
00002372  1028 0008 6791          move.b    8(A0),D0
00002376  6704      6792          beq.s     OSMboxDel_6
                    6793   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00002378  7A01      6794          moveq     #1,D5
0000237A  6002      6795          bra.s     OSMboxDel_7
                    6796   OSMboxDel_6:
                    6797   ; } else {
                    6798   ; tasks_waiting = OS_FALSE;                          /* No                                       */
0000237C  4205      6799          clr.b     D5
                    6800   OSMboxDel_7:
                    6801   ; }
                    6802   ; switch (opt) {
0000237E  102E 000F 6803          move.b    15(A6),D0
00002382  C0BC 0000 6804          and.l     #255,D0
00002386  00FF      
00002388  0C80 0000 6805          cmp.l     #1,D0
0000238C  0001      
0000238E  6700 0048 6806          beq       OSMboxDel_11
00002392  6200 009A 6807          bhi       OSMboxDel_8
00002396  4A80      6808          tst.l     D0
00002398  6704      6809          beq.s     OSMboxDel_10
0000239A  6000 0092 6810          bra       OSMboxDel_8
                    6811   OSMboxDel_10:
                    6812   ; case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
                    6813   ; if (tasks_waiting == OS_FALSE) {
0000239E  4A05      6814          tst.b     D5
000023A0  6628      6815          bne.s     OSMboxDel_13
                    6816   ; #if OS_EVENT_NAME_EN > 0u
                    6817   ; pevent->OSEventName = (INT8U *)(void *)"?";
000023A2  41F9 0000 6818          lea       @ucos_ii_1.L,A0
000023A6  5A8E      
000023A8  2242      6819          move.l    D2,A1
000023AA  2348 0012 6820          move.l    A0,18(A1)
                    6821   ; #endif
                    6822   ; pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
000023AE  2042      6823          move.l    D2,A0
000023B0  4210      6824          clr.b     (A0)
                    6825   ; pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
000023B2  2042      6826          move.l    D2,A0
000023B4  2152 0002 6827          move.l    (A2),2(A0)
                    6828   ; pevent->OSEventCnt  = 0u;
000023B8  2042      6829          move.l    D2,A0
000023BA  4268 0006 6830          clr.w     6(A0)
                    6831   ; OSEventFreeList     = pevent;             /* Get next free event control block        */
000023BE  2482      6832          move.l    D2,(A2)
                    6833   ; OS_EXIT_CRITICAL();
000023C0  46DF      6834          dc.w      18143
                    6835   ; *perr               = OS_ERR_NONE;
000023C2  2043      6836          move.l    D3,A0
000023C4  4210      6837          clr.b     (A0)
                    6838   ; pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
000023C6  4284      6839          clr.l     D4
000023C8  600A      6840          bra.s     OSMboxDel_14
                    6841   OSMboxDel_13:
                    6842   ; } else {
                    6843   ; OS_EXIT_CRITICAL();
000023CA  46DF      6844          dc.w      18143
                    6845   ; *perr               = OS_ERR_TASK_WAITING;
000023CC  2043      6846          move.l    D3,A0
000023CE  10BC 0049 6847          move.b    #73,(A0)
                    6848   ; pevent_return       = pevent;
000023D2  2802      6849          move.l    D2,D4
                    6850   OSMboxDel_14:
                    6851   ; }
                    6852   ; break;
000023D4  6000 0062 6853          bra       OSMboxDel_9
                    6854   OSMboxDel_11:
                    6855   ; case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
                    6856   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
                    6857   OSMboxDel_15:
000023D8  2042      6858          move.l    D2,A0
000023DA  1028 0008 6859          move.b    8(A0),D0
000023DE  671C      6860          beq.s     OSMboxDel_17
                    6861   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000023E0  4878 0002 6862          pea       2
000023E4  4878 0002 6863          pea       2
000023E8  42A7      6864          clr.l     -(A7)
000023EA  2F02      6865          move.l    D2,-(A7)
000023EC  4EB8 0E18 6866          jsr       _OS_EventTaskRdy
000023F0  DEFC 0010 6867          add.w     #16,A7
000023F4  C0BC 0000 6868          and.l     #255,D0
000023F8  00FF      
000023FA  60DC      6869          bra       OSMboxDel_15
                    6870   OSMboxDel_17:
                    6871   ; }
                    6872   ; #if OS_EVENT_NAME_EN > 0u
                    6873   ; pevent->OSEventName    = (INT8U *)(void *)"?";
000023FC  41F9 0000 6874          lea       @ucos_ii_1.L,A0
00002400  5A8E      
00002402  2242      6875          move.l    D2,A1
00002404  2348 0012 6876          move.l    A0,18(A1)
                    6877   ; #endif
                    6878   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00002408  2042      6879          move.l    D2,A0
0000240A  4210      6880          clr.b     (A0)
                    6881   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
0000240C  2042      6882          move.l    D2,A0
0000240E  2152 0002 6883          move.l    (A2),2(A0)
                    6884   ; pevent->OSEventCnt     = 0u;
00002412  2042      6885          move.l    D2,A0
00002414  4268 0006 6886          clr.w     6(A0)
                    6887   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00002418  2482      6888          move.l    D2,(A2)
                    6889   ; OS_EXIT_CRITICAL();
0000241A  46DF      6890          dc.w      18143
                    6891   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
0000241C  0C05 0001 6892          cmp.b     #1,D5
00002420  6604      6893          bne.s     OSMboxDel_18
                    6894   ; OS_Sched();                               /* Find highest priority task ready to run  */
00002422  4EB8 13F8 6895          jsr       _OS_Sched
                    6896   OSMboxDel_18:
                    6897   ; }
                    6898   ; *perr         = OS_ERR_NONE;
00002426  2043      6899          move.l    D3,A0
00002428  4210      6900          clr.b     (A0)
                    6901   ; pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
0000242A  4284      6902          clr.l     D4
                    6903   ; break;
0000242C  600A      6904          bra.s     OSMboxDel_9
                    6905   OSMboxDel_8:
                    6906   ; default:
                    6907   ; OS_EXIT_CRITICAL();
0000242E  46DF      6908          dc.w      18143
                    6909   ; *perr         = OS_ERR_INVALID_OPT;
00002430  2043      6910          move.l    D3,A0
00002432  10BC 0007 6911          move.b    #7,(A0)
                    6912   ; pevent_return = pevent;
00002436  2802      6913          move.l    D2,D4
                    6914   ; break;
                    6915   OSMboxDel_9:
                    6916   ; }
                    6917   ; return (pevent_return);
00002438  2004      6918          move.l    D4,D0
                    6919   OSMboxDel_3:
0000243A  4CDF 043C 6920          movem.l   (A7)+,D2/D3/D4/D5/A2
0000243E  4E5E      6921          unlk      A6
00002440  4E75      6922          rts
                    6923   ; }
                    6924   ; #endif
                    6925   ; /*$PAGE*/
                    6926   ; /*
                    6927   ; *********************************************************************************************************
                    6928   ; *                                    PEND ON MAILBOX FOR A MESSAGE
                    6929   ; *
                    6930   ; * Description: This function waits for a message to be sent to a mailbox
                    6931   ; *
                    6932   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    6933   ; *
                    6934   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    6935   ; *                            wait for a message to arrive at the mailbox up to the amount of time
                    6936   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    6937   ; *                            forever at the specified mailbox or, until a message arrives.
                    6938   ; *
                    6939   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    6940   ; *                            messages are:
                    6941   ; *
                    6942   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    6943   ; *                                                message.
                    6944   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    6945   ; *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
                    6946   ; *                            OS_ERR_EVENT_TYPE   Invalid event type
                    6947   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    6948   ; *                                                would lead to a suspension.
                    6949   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    6950   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    6951   ; *
                    6952   ; * Returns    : != (void *)0  is a pointer to the message received
                    6953   ; *              == (void *)0  if no message was received or,
                    6954   ; *                            if 'pevent' is a NULL pointer or,
                    6955   ; *                            if you didn't pass the proper pointer to the event control block.
                    6956   ; *********************************************************************************************************
                    6957   ; */
                    6958   ; /*$PAGE*/
                    6959   ; void  *OSMboxPend (OS_EVENT  *pevent,
                    6960   ; INT32U     timeout,
                    6961   ; INT8U     *perr)
                    6962   ; {
                    6963   _OSMboxPend:
00002442  4E56 0000 6964          link      A6,#0
00002446  48E7 3820 6965          movem.l   D2/D3/D4/A2,-(A7)
0000244A  45F9 0080 6966          lea       _OSTCBCur.L,A2
0000244E  0360      
00002450  262E 0010 6967          move.l    16(A6),D3
00002454  282E 0008 6968          move.l    8(A6),D4
                    6969   ; void      *pmsg;
                    6970   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    6971   ; OS_CPU_SR  cpu_sr = 0u;
                    6972   ; #endif
                    6973   ; #ifdef OS_SAFETY_CRITICAL
                    6974   ; if (perr == (INT8U *)0) {
                    6975   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    6976   ; return ((void *)0);
                    6977   ; }
                    6978   ; #endif
                    6979   ; #if OS_ARG_CHK_EN > 0u
                    6980   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    6981   ; *perr = OS_ERR_PEVENT_NULL;
                    6982   ; return ((void *)0);
                    6983   ; }
                    6984   ; #endif
                    6985   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002458  2044      6986          move.l    D4,A0
0000245A  1010      6987          move.b    (A0),D0
0000245C  0C00 0001 6988          cmp.b     #1,D0
00002460  670C      6989          beq.s     OSMboxPend_1
                    6990   ; *perr = OS_ERR_EVENT_TYPE;
00002462  2043      6991          move.l    D3,A0
00002464  10BC 0001 6992          move.b    #1,(A0)
                    6993   ; return ((void *)0);
00002468  4280      6994          clr.l     D0
0000246A  6000 00F0 6995          bra       OSMboxPend_3
                    6996   OSMboxPend_1:
                    6997   ; }
                    6998   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
0000246E  1039 0080 6999          move.b    _OSIntNesting.L,D0
00002472  0246      
00002474  0C00 0000 7000          cmp.b     #0,D0
00002478  630C      7001          bls.s     OSMboxPend_4
                    7002   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
0000247A  2043      7003          move.l    D3,A0
0000247C  10BC 0002 7004          move.b    #2,(A0)
                    7005   ; return ((void *)0);
00002480  4280      7006          clr.l     D0
00002482  6000 00D8 7007          bra       OSMboxPend_3
                    7008   OSMboxPend_4:
                    7009   ; }
                    7010   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
00002486  1039 0080 7011          move.b    _OSLockNesting.L,D0
0000248A  0248      
0000248C  0C00 0000 7012          cmp.b     #0,D0
00002490  630C      7013          bls.s     OSMboxPend_6
                    7014   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
00002492  2043      7015          move.l    D3,A0
00002494  10BC 000D 7016          move.b    #13,(A0)
                    7017   ; return ((void *)0);
00002498  4280      7018          clr.l     D0
0000249A  6000 00C0 7019          bra       OSMboxPend_3
                    7020   OSMboxPend_6:
                    7021   ; }
                    7022   ; OS_ENTER_CRITICAL();
0000249E  40E7      7023          dc.w      16615
000024A0  007C      7024          dc.w      124
000024A2  0700      7025          dc.w      1792
                    7026   ; pmsg = pevent->OSEventPtr;
000024A4  2044      7027          move.l    D4,A0
000024A6  2428 0002 7028          move.l    2(A0),D2
                    7029   ; if (pmsg != (void *)0) {                          /* See if there is already a message             */
000024AA  4A82      7030          tst.l     D2
000024AC  6712      7031          beq.s     OSMboxPend_8
                    7032   ; pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
000024AE  2044      7033          move.l    D4,A0
000024B0  42A8 0002 7034          clr.l     2(A0)
                    7035   ; OS_EXIT_CRITICAL();
000024B4  46DF      7036          dc.w      18143
                    7037   ; *perr = OS_ERR_NONE;
000024B6  2043      7038          move.l    D3,A0
000024B8  4210      7039          clr.b     (A0)
                    7040   ; return (pmsg);                                /* Return the message received (or NULL)         */
000024BA  2002      7041          move.l    D2,D0
000024BC  6000 009E 7042          bra       OSMboxPend_3
                    7043   OSMboxPend_8:
                    7044   ; }
                    7045   ; OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
000024C0  2052      7046          move.l    (A2),A0
000024C2  0028 0002 7047          or.b      #2,50(A0)
000024C6  0032      
                    7048   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000024C8  2052      7049          move.l    (A2),A0
000024CA  4228 0033 7050          clr.b     51(A0)
                    7051   ; OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
000024CE  2052      7052          move.l    (A2),A0
000024D0  216E 000C 7053          move.l    12(A6),46(A0)
000024D4  002E      
                    7054   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
000024D6  2F04      7055          move.l    D4,-(A7)
000024D8  4EB8 0EFC 7056          jsr       _OS_EventTaskWait
000024DC  584F      7057          addq.w    #4,A7
                    7058   ; OS_EXIT_CRITICAL();
000024DE  46DF      7059          dc.w      18143
                    7060   ; OS_Sched();                                       /* Find next highest priority task ready to run  */
000024E0  4EB8 13F8 7061          jsr       _OS_Sched
                    7062   ; OS_ENTER_CRITICAL();
000024E4  40E7      7063          dc.w      16615
000024E6  007C      7064          dc.w      124
000024E8  0700      7065          dc.w      1792
                    7066   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
000024EA  2052      7067          move.l    (A2),A0
000024EC  1028 0033 7068          move.b    51(A0),D0
000024F0  C0BC 0000 7069          and.l     #255,D0
000024F4  00FF      
000024F6  0C80 0000 7070          cmp.l     #1,D0
000024FA  0001      
000024FC  6700 002A 7071          beq       OSMboxPend_14
00002500  6206      7072          bhi.s     OSMboxPend_16
00002502  4A80      7073          tst.l     D0
00002504  670C      7074          beq.s     OSMboxPend_12
00002506  6020      7075          bra.s     OSMboxPend_14
                    7076   OSMboxPend_16:
00002508  0C80 0000 7077          cmp.l     #2,D0
0000250C  0002      
0000250E  670E      7078          beq.s     OSMboxPend_13
00002510  6016      7079          bra.s     OSMboxPend_14
                    7080   OSMboxPend_12:
                    7081   ; case OS_STAT_PEND_OK:
                    7082   ; pmsg =  OSTCBCur->OSTCBMsg;
00002512  2052      7083          move.l    (A2),A0
00002514  2428 0024 7084          move.l    36(A0),D2
                    7085   ; *perr =  OS_ERR_NONE;
00002518  2043      7086          move.l    D3,A0
0000251A  4210      7087          clr.b     (A0)
                    7088   ; break;
0000251C  601C      7089          bra.s     OSMboxPend_11
                    7090   OSMboxPend_13:
                    7091   ; case OS_STAT_PEND_ABORT:
                    7092   ; pmsg = (void *)0;
0000251E  4282      7093          clr.l     D2
                    7094   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00002520  2043      7095          move.l    D3,A0
00002522  10BC 000E 7096          move.b    #14,(A0)
                    7097   ; break;
00002526  6012      7098          bra.s     OSMboxPend_11
                    7099   OSMboxPend_14:
                    7100   ; case OS_STAT_PEND_TO:
                    7101   ; default:
                    7102   ; OS_EventTaskRemove(OSTCBCur, pevent);
00002528  2F04      7103          move.l    D4,-(A7)
0000252A  2F12      7104          move.l    (A2),-(A7)
0000252C  4EB8 101E 7105          jsr       _OS_EventTaskRemove
00002530  504F      7106          addq.w    #8,A7
                    7107   ; pmsg = (void *)0;
00002532  4282      7108          clr.l     D2
                    7109   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00002534  2043      7110          move.l    D3,A0
00002536  10BC 000A 7111          move.b    #10,(A0)
                    7112   ; break;
                    7113   OSMboxPend_11:
                    7114   ; }
                    7115   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
0000253A  2052      7116          move.l    (A2),A0
0000253C  4228 0032 7117          clr.b     50(A0)
                    7118   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00002540  2052      7119          move.l    (A2),A0
00002542  4228 0033 7120          clr.b     51(A0)
                    7121   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00002546  2052      7122          move.l    (A2),A0
00002548  42A8 001C 7123          clr.l     28(A0)
                    7124   ; #if (OS_EVENT_MULTI_EN > 0u)
                    7125   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000254C  2052      7126          move.l    (A2),A0
0000254E  42A8 0020 7127          clr.l     32(A0)
                    7128   ; #endif
                    7129   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
00002552  2052      7130          move.l    (A2),A0
00002554  42A8 0024 7131          clr.l     36(A0)
                    7132   ; OS_EXIT_CRITICAL();
00002558  46DF      7133          dc.w      18143
                    7134   ; return (pmsg);                                    /* Return received message                       */
0000255A  2002      7135          move.l    D2,D0
                    7136   OSMboxPend_3:
0000255C  4CDF 041C 7137          movem.l   (A7)+,D2/D3/D4/A2
00002560  4E5E      7138          unlk      A6
00002562  4E75      7139          rts
                    7140   ; }
                    7141   ; /*$PAGE*/
                    7142   ; /*
                    7143   ; *********************************************************************************************************
                    7144   ; *                                     ABORT WAITING ON A MESSAGE MAILBOX
                    7145   ; *
                    7146   ; * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function
                    7147   ; *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
                    7148   ; *              the mailbox via OSMboxPost() or OSMboxPostOpt().
                    7149   ; *
                    7150   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
                    7151   ; *
                    7152   ; *              opt           determines the type of ABORT performed:
                    7153   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    7154   ; *                                                     mailbox
                    7155   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    7156   ; *                                                     mailbox
                    7157   ; *
                    7158   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    7159   ; *                            messages are:
                    7160   ; *
                    7161   ; *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
                    7162   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
                    7163   ; *                                                and informed of the aborted wait; check return value
                    7164   ; *                                                for the number of tasks whose wait on the mailbox
                    7165   ; *                                                was aborted.
                    7166   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
                    7167   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    7168   ; *
                    7169   ; * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
                    7170   ; *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
                    7171   ; *********************************************************************************************************
                    7172   ; */
                    7173   ; #if OS_MBOX_PEND_ABORT_EN > 0u
                    7174   ; INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
                    7175   ; INT8U      opt,
                    7176   ; INT8U     *perr)
                    7177   ; {
                    7178   _OSMboxPendAbort:
00002564  4E56 0000 7179          link      A6,#0
00002568  48E7 3800 7180          movem.l   D2/D3/D4,-(A7)
0000256C  242E 0008 7181          move.l    8(A6),D2
00002570  282E 0010 7182          move.l    16(A6),D4
                    7183   ; INT8U      nbr_tasks;
                    7184   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7185   ; OS_CPU_SR  cpu_sr = 0u;
                    7186   ; #endif
                    7187   ; #ifdef OS_SAFETY_CRITICAL
                    7188   ; if (perr == (INT8U *)0) {
                    7189   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7190   ; return (0u);
                    7191   ; }
                    7192   ; #endif
                    7193   ; #if OS_ARG_CHK_EN > 0u
                    7194   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7195   ; *perr = OS_ERR_PEVENT_NULL;
                    7196   ; return (0u);
                    7197   ; }
                    7198   ; #endif
                    7199   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002574  2042      7200          move.l    D2,A0
00002576  1010      7201          move.b    (A0),D0
00002578  0C00 0001 7202          cmp.b     #1,D0
0000257C  670C      7203          beq.s     OSMboxPendAbort_1
                    7204   ; *perr = OS_ERR_EVENT_TYPE;
0000257E  2044      7205          move.l    D4,A0
00002580  10BC 0001 7206          move.b    #1,(A0)
                    7207   ; return (0u);
00002584  4200      7208          clr.b     D0
00002586  6000 008C 7209          bra       OSMboxPendAbort_3
                    7210   OSMboxPendAbort_1:
                    7211   ; }
                    7212   ; OS_ENTER_CRITICAL();
0000258A  40E7      7213          dc.w      16615
0000258C  007C      7214          dc.w      124
0000258E  0700      7215          dc.w      1792
                    7216   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
00002590  2042      7217          move.l    D2,A0
00002592  1028 0008 7218          move.b    8(A0),D0
00002596  6700 0074 7219          beq       OSMboxPendAbort_4
                    7220   ; nbr_tasks = 0u;
0000259A  4203      7221          clr.b     D3
                    7222   ; switch (opt) {
0000259C  102E 000F 7223          move.b    15(A6),D0
000025A0  C0BC 0000 7224          and.l     #255,D0
000025A4  00FF      
000025A6  0C80 0000 7225          cmp.l     #1,D0
000025AA  0001      
000025AC  670A      7226          beq.s     OSMboxPendAbort_8
000025AE  6200 0030 7227          bhi       OSMboxPendAbort_9
000025B2  4A80      7228          tst.l     D0
000025B4  672A      7229          beq.s     OSMboxPendAbort_9
000025B6  6028      7230          bra.s     OSMboxPendAbort_9
                    7231   OSMboxPendAbort_8:
                    7232   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    7233   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
                    7234   OSMboxPendAbort_11:
000025B8  2042      7235          move.l    D2,A0
000025BA  1028 0008 7236          move.b    8(A0),D0
000025BE  671E      7237          beq.s     OSMboxPendAbort_13
                    7238   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000025C0  4878 0002 7239          pea       2
000025C4  4878 0002 7240          pea       2
000025C8  42A7      7241          clr.l     -(A7)
000025CA  2F02      7242          move.l    D2,-(A7)
000025CC  4EB8 0E18 7243          jsr       _OS_EventTaskRdy
000025D0  DEFC 0010 7244          add.w     #16,A7
000025D4  C0BC 0000 7245          and.l     #255,D0
000025D8  00FF      
                    7246   ; nbr_tasks++;
000025DA  5203      7247          addq.b    #1,D3
000025DC  60DA      7248          bra       OSMboxPendAbort_11
                    7249   OSMboxPendAbort_13:
                    7250   ; }
                    7251   ; break;
000025DE  601C      7252          bra.s     OSMboxPendAbort_7
                    7253   OSMboxPendAbort_9:
                    7254   ; case OS_PEND_OPT_NONE:
                    7255   ; default:                                       /* No,  ready HPT       waiting on mailbox  */
                    7256   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
000025E0  4878 0002 7257          pea       2
000025E4  4878 0002 7258          pea       2
000025E8  42A7      7259          clr.l     -(A7)
000025EA  2F02      7260          move.l    D2,-(A7)
000025EC  4EB8 0E18 7261          jsr       _OS_EventTaskRdy
000025F0  DEFC 0010 7262          add.w     #16,A7
000025F4  C0BC 0000 7263          and.l     #255,D0
000025F8  00FF      
                    7264   ; nbr_tasks++;
000025FA  5203      7265          addq.b    #1,D3
                    7266   ; break;
                    7267   OSMboxPendAbort_7:
                    7268   ; }
                    7269   ; OS_EXIT_CRITICAL();
000025FC  46DF      7270          dc.w      18143
                    7271   ; OS_Sched();                                        /* Find HPT ready to run                    */
000025FE  4EB8 13F8 7272          jsr       _OS_Sched
                    7273   ; *perr = OS_ERR_PEND_ABORT;
00002602  2044      7274          move.l    D4,A0
00002604  10BC 000E 7275          move.b    #14,(A0)
                    7276   ; return (nbr_tasks);
00002608  1003      7277          move.b    D3,D0
0000260A  6008      7278          bra.s     OSMboxPendAbort_3
                    7279   OSMboxPendAbort_4:
                    7280   ; }
                    7281   ; OS_EXIT_CRITICAL();
0000260C  46DF      7282          dc.w      18143
                    7283   ; *perr = OS_ERR_NONE;
0000260E  2044      7284          move.l    D4,A0
00002610  4210      7285          clr.b     (A0)
                    7286   ; return (0u);                                           /* No tasks waiting on mailbox              */
00002612  4200      7287          clr.b     D0
                    7288   OSMboxPendAbort_3:
00002614  4CDF 001C 7289          movem.l   (A7)+,D2/D3/D4
00002618  4E5E      7290          unlk      A6
0000261A  4E75      7291          rts
                    7292   ; }
                    7293   ; #endif
                    7294   ; /*$PAGE*/
                    7295   ; /*
                    7296   ; *********************************************************************************************************
                    7297   ; *                                      POST MESSAGE TO A MAILBOX
                    7298   ; *
                    7299   ; * Description: This function sends a message to a mailbox
                    7300   ; *
                    7301   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7302   ; *
                    7303   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7304   ; *
                    7305   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7306   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7307   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7308   ; *                                   are allowed to send another one.
                    7309   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7310   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7311   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7312   ; *
                    7313   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7314   ; *********************************************************************************************************
                    7315   ; */
                    7316   ; #if OS_MBOX_POST_EN > 0u
                    7317   ; INT8U  OSMboxPost (OS_EVENT  *pevent,
                    7318   ; void      *pmsg)
                    7319   ; {
                    7320   _OSMboxPost:
0000261C  4E56 0000 7321          link      A6,#0
00002620  2F02      7322          move.l    D2,-(A7)
00002622  242E 0008 7323          move.l    8(A6),D2
                    7324   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7325   ; OS_CPU_SR  cpu_sr = 0u;
                    7326   ; #endif
                    7327   ; #if OS_ARG_CHK_EN > 0u
                    7328   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7329   ; return (OS_ERR_PEVENT_NULL);
                    7330   ; }
                    7331   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7332   ; return (OS_ERR_POST_NULL_PTR);
                    7333   ; }
                    7334   ; #endif
                    7335   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002626  2042      7336          move.l    D2,A0
00002628  1010      7337          move.b    (A0),D0
0000262A  0C00 0001 7338          cmp.b     #1,D0
0000262E  6706      7339          beq.s     OSMboxPost_1
                    7340   ; return (OS_ERR_EVENT_TYPE);
00002630  7001      7341          moveq     #1,D0
00002632  6000 004E 7342          bra       OSMboxPost_3
                    7343   OSMboxPost_1:
                    7344   ; }
                    7345   ; OS_ENTER_CRITICAL();
00002636  40E7      7346          dc.w      16615
00002638  007C      7347          dc.w      124
0000263A  0700      7348          dc.w      1792
                    7349   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
0000263C  2042      7350          move.l    D2,A0
0000263E  1028 0008 7351          move.b    8(A0),D0
00002642  6724      7352          beq.s     OSMboxPost_4
                    7353   ; /* Ready HPT waiting on event                    */
                    7354   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
00002644  42A7      7355          clr.l     -(A7)
00002646  4878 0002 7356          pea       2
0000264A  2F2E 000C 7357          move.l    12(A6),-(A7)
0000264E  2F02      7358          move.l    D2,-(A7)
00002650  4EB8 0E18 7359          jsr       _OS_EventTaskRdy
00002654  DEFC 0010 7360          add.w     #16,A7
00002658  C0BC 0000 7361          and.l     #255,D0
0000265C  00FF      
                    7362   ; OS_EXIT_CRITICAL();
0000265E  46DF      7363          dc.w      18143
                    7364   ; OS_Sched();                                   /* Find highest priority task ready to run       */
00002660  4EB8 13F8 7365          jsr       _OS_Sched
                    7366   ; return (OS_ERR_NONE);
00002664  4200      7367          clr.b     D0
00002666  601A      7368          bra.s     OSMboxPost_3
                    7369   OSMboxPost_4:
                    7370   ; }
                    7371   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00002668  2042      7372          move.l    D2,A0
0000266A  2028 0002 7373          move.l    2(A0),D0
0000266E  6706      7374          beq.s     OSMboxPost_6
                    7375   ; OS_EXIT_CRITICAL();
00002670  46DF      7376          dc.w      18143
                    7377   ; return (OS_ERR_MBOX_FULL);
00002672  7014      7378          moveq     #20,D0
00002674  600C      7379          bra.s     OSMboxPost_3
                    7380   OSMboxPost_6:
                    7381   ; }
                    7382   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002676  2042      7383          move.l    D2,A0
00002678  216E 000C 7384          move.l    12(A6),2(A0)
0000267C  0002      
                    7385   ; OS_EXIT_CRITICAL();
0000267E  46DF      7386          dc.w      18143
                    7387   ; return (OS_ERR_NONE);
00002680  4200      7388          clr.b     D0
                    7389   OSMboxPost_3:
00002682  241F      7390          move.l    (A7)+,D2
00002684  4E5E      7391          unlk      A6
00002686  4E75      7392          rts
                    7393   ; }
                    7394   ; #endif
                    7395   ; /*$PAGE*/
                    7396   ; /*
                    7397   ; *********************************************************************************************************
                    7398   ; *                                      POST MESSAGE TO A MAILBOX
                    7399   ; *
                    7400   ; * Description: This function sends a message to a mailbox
                    7401   ; *
                    7402   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7403   ; *
                    7404   ; *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
                    7405   ; *
                    7406   ; *              opt           determines the type of POST performed:
                    7407   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    7408   ; *                                                     (Identical to OSMboxPost())
                    7409   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
                    7410   ; *
                    7411   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    7412   ; *
                    7413   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    7414   ; *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
                    7415   ; *                                   message at a time and thus, the message MUST be consumed before you
                    7416   ; *                                   are allowed to send another one.
                    7417   ; *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
                    7418   ; *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
                    7419   ; *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
                    7420   ; *
                    7421   ; * Note(s)    : 1) HPT means Highest Priority Task
                    7422   ; *
                    7423   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    7424   ; *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
                    7425   ; *********************************************************************************************************
                    7426   ; */
                    7427   ; #if OS_MBOX_POST_OPT_EN > 0u
                    7428   ; INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
                    7429   ; void      *pmsg,
                    7430   ; INT8U      opt)
                    7431   ; {
                    7432   _OSMboxPostOpt:
00002688  4E56 0000 7433          link      A6,#0
0000268C  48E7 3000 7434          movem.l   D2/D3,-(A7)
00002690  242E 0008 7435          move.l    8(A6),D2
00002694  262E 000C 7436          move.l    12(A6),D3
                    7437   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7438   ; OS_CPU_SR  cpu_sr = 0u;
                    7439   ; #endif
                    7440   ; #if OS_ARG_CHK_EN > 0u
                    7441   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    7442   ; return (OS_ERR_PEVENT_NULL);
                    7443   ; }
                    7444   ; if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
                    7445   ; return (OS_ERR_POST_NULL_PTR);
                    7446   ; }
                    7447   ; #endif
                    7448   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00002698  2042      7449          move.l    D2,A0
0000269A  1010      7450          move.b    (A0),D0
0000269C  0C00 0001 7451          cmp.b     #1,D0
000026A0  6706      7452          beq.s     OSMboxPostOpt_1
                    7453   ; return (OS_ERR_EVENT_TYPE);
000026A2  7001      7454          moveq     #1,D0
000026A4  6000 0084 7455          bra       OSMboxPostOpt_3
                    7456   OSMboxPostOpt_1:
                    7457   ; }
                    7458   ; OS_ENTER_CRITICAL();
000026A8  40E7      7459          dc.w      16615
000026AA  007C      7460          dc.w      124
000026AC  0700      7461          dc.w      1792
                    7462   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
000026AE  2042      7463          move.l    D2,A0
000026B0  1028 0008 7464          move.b    8(A0),D0
000026B4  6700 005C 7465          beq       OSMboxPostOpt_4
                    7466   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
000026B8  102E 0013 7467          move.b    19(A6),D0
000026BC  C03C 0001 7468          and.b     #1,D0
000026C0  6724      7469          beq.s     OSMboxPostOpt_6
                    7470   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
                    7471   OSMboxPostOpt_8:
000026C2  2042      7472          move.l    D2,A0
000026C4  1028 0008 7473          move.b    8(A0),D0
000026C8  671A      7474          beq.s     OSMboxPostOpt_10
                    7475   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
000026CA  42A7      7476          clr.l     -(A7)
000026CC  4878 0002 7477          pea       2
000026D0  2F03      7478          move.l    D3,-(A7)
000026D2  2F02      7479          move.l    D2,-(A7)
000026D4  4EB8 0E18 7480          jsr       _OS_EventTaskRdy
000026D8  DEFC 0010 7481          add.w     #16,A7
000026DC  C0BC 0000 7482          and.l     #255,D0
000026E0  00FF      
000026E2  60DE      7483          bra       OSMboxPostOpt_8
                    7484   OSMboxPostOpt_10:
000026E4  6018      7485          bra.s     OSMboxPostOpt_7
                    7486   OSMboxPostOpt_6:
                    7487   ; }
                    7488   ; } else {                                      /* No,  Post to HPT waiting on mbox              */
                    7489   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
000026E6  42A7      7490          clr.l     -(A7)
000026E8  4878 0002 7491          pea       2
000026EC  2F03      7492          move.l    D3,-(A7)
000026EE  2F02      7493          move.l    D2,-(A7)
000026F0  4EB8 0E18 7494          jsr       _OS_EventTaskRdy
000026F4  DEFC 0010 7495          add.w     #16,A7
000026F8  C0BC 0000 7496          and.l     #255,D0
000026FC  00FF      
                    7497   OSMboxPostOpt_7:
                    7498   ; }
                    7499   ; OS_EXIT_CRITICAL();
000026FE  46DF      7500          dc.w      18143
                    7501   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
00002700  102E 0013 7502          move.b    19(A6),D0
00002704  C03C 0004 7503          and.b     #4,D0
00002708  6604      7504          bne.s     OSMboxPostOpt_11
                    7505   ; OS_Sched();                               /* Find HPT ready to run                         */
0000270A  4EB8 13F8 7506          jsr       _OS_Sched
                    7507   OSMboxPostOpt_11:
                    7508   ; }
                    7509   ; return (OS_ERR_NONE);
0000270E  4200      7510          clr.b     D0
00002710  6018      7511          bra.s     OSMboxPostOpt_3
                    7512   OSMboxPostOpt_4:
                    7513   ; }
                    7514   ; if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
00002712  2042      7515          move.l    D2,A0
00002714  2028 0002 7516          move.l    2(A0),D0
00002718  6706      7517          beq.s     OSMboxPostOpt_13
                    7518   ; OS_EXIT_CRITICAL();
0000271A  46DF      7519          dc.w      18143
                    7520   ; return (OS_ERR_MBOX_FULL);
0000271C  7014      7521          moveq     #20,D0
0000271E  600A      7522          bra.s     OSMboxPostOpt_3
                    7523   OSMboxPostOpt_13:
                    7524   ; }
                    7525   ; pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
00002720  2042      7526          move.l    D2,A0
00002722  2143 0002 7527          move.l    D3,2(A0)
                    7528   ; OS_EXIT_CRITICAL();
00002726  46DF      7529          dc.w      18143
                    7530   ; return (OS_ERR_NONE);
00002728  4200      7531          clr.b     D0
                    7532   OSMboxPostOpt_3:
0000272A  4CDF 000C 7533          movem.l   (A7)+,D2/D3
0000272E  4E5E      7534          unlk      A6
00002730  4E75      7535          rts
                    7536   ; }
                    7537   ; #endif
                    7538   ; /*$PAGE*/
                    7539   ; /*
                    7540   ; *********************************************************************************************************
                    7541   ; *                                       QUERY A MESSAGE MAILBOX
                    7542   ; *
                    7543   ; * Description: This function obtains information about a message mailbox.
                    7544   ; *
                    7545   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
                    7546   ; *
                    7547   ; *              p_mbox_data   is a pointer to a structure that will contain information about the message
                    7548   ; *                            mailbox.
                    7549   ; *
                    7550   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    7551   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
                    7552   ; *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
                    7553   ; *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
                    7554   ; *********************************************************************************************************
                    7555   ; */
                    7556   ; #if OS_MBOX_QUERY_EN > 0u
                    7557   ; INT8U  OSMboxQuery (OS_EVENT      *pevent,
                    7558   ; OS_MBOX_DATA  *p_mbox_data)
                    7559   ; {
                    7560   _OSMboxQuery:
00002732  4E56 FFF8 7561          link      A6,#-8
00002736  48E7 3800 7562          movem.l   D2/D3/D4,-(A7)
0000273A  242E 0008 7563          move.l    8(A6),D2
0000273E  282E 000C 7564          move.l    12(A6),D4
                    7565   ; INT8U       i;
                    7566   ; OS_PRIO    *psrc;
                    7567   ; OS_PRIO    *pdest;
                    7568   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    7569   ; OS_CPU_SR   cpu_sr = 0u;
                    7570   ; #endif
                    7571   ; #if OS_ARG_CHK_EN > 0u
                    7572   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    7573   ; return (OS_ERR_PEVENT_NULL);
                    7574   ; }
                    7575   ; if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
                    7576   ; return (OS_ERR_PDATA_NULL);
                    7577   ; }
                    7578   ; #endif
                    7579   ; if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00002742  2042      7580          move.l    D2,A0
00002744  1010      7581          move.b    (A0),D0
00002746  0C00 0001 7582          cmp.b     #1,D0
0000274A  6706      7583          beq.s     OSMboxQuery_1
                    7584   ; return (OS_ERR_EVENT_TYPE);
0000274C  7001      7585          moveq     #1,D0
0000274E  6000 004C 7586          bra       OSMboxQuery_3
                    7587   OSMboxQuery_1:
                    7588   ; }
                    7589   ; OS_ENTER_CRITICAL();
00002752  40E7      7590          dc.w      16615
00002754  007C      7591          dc.w      124
00002756  0700      7592          dc.w      1792
                    7593   ; p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
00002758  2042      7594          move.l    D2,A0
0000275A  2244      7595          move.l    D4,A1
0000275C  1368 0008 7596          move.b    8(A0),12(A1)
00002760  000C      
                    7597   ; psrc                    = &pevent->OSEventTbl[0];
00002762  700A      7598          moveq     #10,D0
00002764  D082      7599          add.l     D2,D0
00002766  2D40 FFF8 7600          move.l    D0,-8(A6)
                    7601   ; pdest                   = &p_mbox_data->OSEventTbl[0];
0000276A  7004      7602          moveq     #4,D0
0000276C  D084      7603          add.l     D4,D0
0000276E  2D40 FFFC 7604          move.l    D0,-4(A6)
                    7605   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00002772  4203      7606          clr.b     D3
                    7607   OSMboxQuery_4:
00002774  0C03 0008 7608          cmp.b     #8,D3
00002778  6416      7609          bhs.s     OSMboxQuery_6
                    7610   ; *pdest++ = *psrc++;
0000277A  206E FFF8 7611          move.l    -8(A6),A0
0000277E  52AE FFF8 7612          addq.l    #1,-8(A6)
00002782  226E FFFC 7613          move.l    -4(A6),A1
00002786  52AE FFFC 7614          addq.l    #1,-4(A6)
0000278A  1290      7615          move.b    (A0),(A1)
0000278C  5203      7616          addq.b    #1,D3
0000278E  60E4      7617          bra       OSMboxQuery_4
                    7618   OSMboxQuery_6:
                    7619   ; }
                    7620   ; p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
00002790  2042      7621          move.l    D2,A0
00002792  2244      7622          move.l    D4,A1
00002794  22A8 0002 7623          move.l    2(A0),(A1)
                    7624   ; OS_EXIT_CRITICAL();
00002798  46DF      7625          dc.w      18143
                    7626   ; return (OS_ERR_NONE);
0000279A  4200      7627          clr.b     D0
                    7628   OSMboxQuery_3:
0000279C  4CDF 001C 7629          movem.l   (A7)+,D2/D3/D4
000027A0  4E5E      7630          unlk      A6
000027A2  4E75      7631          rts
                    7632   ; /*
                    7633   ; *********************************************************************************************************
                    7634   ; *                                                uC/OS-II
                    7635   ; *                                          The Real-Time Kernel
                    7636   ; *                                            MEMORY MANAGEMENT
                    7637   ; *
                    7638   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    7639   ; *                                           All Rights Reserved
                    7640   ; *
                    7641   ; * File    : OS_MEM.C
                    7642   ; * By      : Jean J. Labrosse
                    7643   ; * Version : V2.92.07
                    7644   ; *
                    7645   ; * LICENSING TERMS:
                    7646   ; * ---------------
                    7647   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    7648   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    7649   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    7650   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    7651   ; * licensing fee.
                    7652   ; *********************************************************************************************************
                    7653   ; */
                    7654   ; #define  MICRIUM_SOURCE
                    7655   ; #ifndef  OS_MASTER_FILE
                    7656   ; #include <ucos_ii.h>
                    7657   ; #endif
                    7658   ; #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
                    7659   ; /*
                    7660   ; *********************************************************************************************************
                    7661   ; *                                      CREATE A MEMORY PARTITION
                    7662   ; *
                    7663   ; * Description : Create a fixed-sized memory partition that will be managed by uC/OS-II.
                    7664   ; *
                    7665   ; * Arguments   : addr     is the starting address of the memory partition
                    7666   ; *
                    7667   ; *               nblks    is the number of memory blocks to create from the partition.
                    7668   ; *
                    7669   ; *               blksize  is the size (in bytes) of each block in the memory partition.
                    7670   ; *
                    7671   ; *               perr     is a pointer to a variable containing an error message which will be set by
                    7672   ; *                        this function to either:
                    7673   ; *
                    7674   ; *                        OS_ERR_NONE              if the memory partition has been created correctly.
                    7675   ; *                        OS_ERR_MEM_INVALID_ADDR  if you are specifying an invalid address for the memory
                    7676   ; *                                                 storage of the partition or, the block does not align
                    7677   ; *                                                 on a pointer boundary
                    7678   ; *                        OS_ERR_MEM_INVALID_PART  no free partitions available
                    7679   ; *                        OS_ERR_MEM_INVALID_BLKS  user specified an invalid number of blocks (must be >= 2)
                    7680   ; *                        OS_ERR_MEM_INVALID_SIZE  user specified an invalid block size
                    7681   ; *                                                   - must be greater than the size of a pointer
                    7682   ; *                                                   - must be able to hold an integral number of pointers
                    7683   ; * Returns    : != (OS_MEM *)0  is the partition was created
                    7684   ; *              == (OS_MEM *)0  if the partition was not created because of invalid arguments or, no
                    7685   ; *                              free partition is available.
                    7686   ; *********************************************************************************************************
                    7687   ; */
                    7688   ; OS_MEM  *OSMemCreate (void   *addr,
                    7689   ; INT32U  nblks,
                    7690   ; INT32U  blksize,
                    7691   ; INT8U  *perr)
                    7692   ; {
                    7693   _OSMemCreate:
000027A4  4E56 FFFC 7694          link      A6,#-4
000027A8  48E7 3F20 7695          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
000027AC  282E 0008 7696          move.l    8(A6),D4
000027B0  45F9 0080 7697          lea       _OSMemFreeList.L,A2
000027B4  0BD4      
000027B6  2E2E 000C 7698          move.l    12(A6),D7
                    7699   ; OS_MEM    *pmem;
                    7700   ; INT8U     *pblk;
                    7701   ; void     **plink;
                    7702   ; INT32U     loops;
                    7703   ; INT32U     i;
                    7704   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7705   ; OS_CPU_SR  cpu_sr = 0u;
                    7706   ; #endif
                    7707   ; #ifdef OS_SAFETY_CRITICAL
                    7708   ; if (perr == (INT8U *)0) {
                    7709   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7710   ; return ((OS_MEM *)0);
                    7711   ; }
                    7712   ; #endif
                    7713   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    7714   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    7715   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7716   ; return ((OS_MEM *)0);
                    7717   ; }
                    7718   ; #endif
                    7719   ; #if OS_ARG_CHK_EN > 0u
                    7720   ; if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
                    7721   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    7722   ; return ((OS_MEM *)0);
                    7723   ; }
                    7724   ; if (((INT32U)addr & (sizeof(void *) - 1u)) != 0u){  /* Must be pointer size aligned                */
                    7725   ; *perr = OS_ERR_MEM_INVALID_ADDR;
                    7726   ; return ((OS_MEM *)0);
                    7727   ; }
                    7728   ; if (nblks < 2u) {                                 /* Must have at least 2 blocks per partition     */
                    7729   ; *perr = OS_ERR_MEM_INVALID_BLKS;
                    7730   ; return ((OS_MEM *)0);
                    7731   ; }
                    7732   ; if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
                    7733   ; *perr = OS_ERR_MEM_INVALID_SIZE;
                    7734   ; return ((OS_MEM *)0);
                    7735   ; }
                    7736   ; #endif
                    7737   ; OS_ENTER_CRITICAL();
000027BA  40E7      7738          dc.w      16615
000027BC  007C      7739          dc.w      124
000027BE  0700      7740          dc.w      1792
                    7741   ; pmem = OSMemFreeList;                             /* Get next free memory partition                */
000027C0  2412      7742          move.l    (A2),D2
                    7743   ; if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
000027C2  2012      7744          move.l    (A2),D0
000027C4  6706      7745          beq.s     OSMemCreate_1
                    7746   ; OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
000027C6  2052      7747          move.l    (A2),A0
000027C8  24A8 0004 7748          move.l    4(A0),(A2)
                    7749   OSMemCreate_1:
                    7750   ; }
                    7751   ; OS_EXIT_CRITICAL();
000027CC  46DF      7752          dc.w      18143
                    7753   ; if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
000027CE  4A82      7754          tst.l     D2
000027D0  660E      7755          bne.s     OSMemCreate_3
                    7756   ; *perr = OS_ERR_MEM_INVALID_PART;
000027D2  206E 0014 7757          move.l    20(A6),A0
000027D6  10BC 005A 7758          move.b    #90,(A0)
                    7759   ; return ((OS_MEM *)0);
000027DA  4280      7760          clr.l     D0
000027DC  6000 0050 7761          bra       OSMemCreate_5
                    7762   OSMemCreate_3:
                    7763   ; }
                    7764   ; plink = (void **)addr;                            /* Create linked list of free memory blocks      */
000027E0  2A04      7765          move.l    D4,D5
                    7766   ; pblk  = (INT8U *)addr;
000027E2  2604      7767          move.l    D4,D3
                    7768   ; loops  = nblks - 1u;
000027E4  2007      7769          move.l    D7,D0
000027E6  5380      7770          subq.l    #1,D0
000027E8  2D40 FFFC 7771          move.l    D0,-4(A6)
                    7772   ; for (i = 0u; i < loops; i++) {
000027EC  4286      7773          clr.l     D6
                    7774   OSMemCreate_6:
000027EE  BCAE FFFC 7775          cmp.l     -4(A6),D6
000027F2  6410      7776          bhs.s     OSMemCreate_8
                    7777   ; pblk +=  blksize;                             /* Point to the FOLLOWING block                  */
000027F4  202E 0010 7778          move.l    16(A6),D0
000027F8  D680      7779          add.l     D0,D3
                    7780   ; *plink = (void  *)pblk;                        /* Save pointer to NEXT block in CURRENT block   */
000027FA  2045      7781          move.l    D5,A0
000027FC  2083      7782          move.l    D3,(A0)
                    7783   ; plink = (void **)pblk;                        /* Position to  NEXT      block                  */
000027FE  2A03      7784          move.l    D3,D5
00002800  5286      7785          addq.l    #1,D6
00002802  60EA      7786          bra       OSMemCreate_6
                    7787   OSMemCreate_8:
                    7788   ; }
                    7789   ; *plink              = (void *)0;                  /* Last memory block points to NULL              */
00002804  2045      7790          move.l    D5,A0
00002806  4290      7791          clr.l     (A0)
                    7792   ; pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
00002808  2042      7793          move.l    D2,A0
0000280A  2084      7794          move.l    D4,(A0)
                    7795   ; pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
0000280C  2042      7796          move.l    D2,A0
0000280E  2144 0004 7797          move.l    D4,4(A0)
                    7798   ; pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
00002812  2042      7799          move.l    D2,A0
00002814  2147 0010 7800          move.l    D7,16(A0)
                    7801   ; pmem->OSMemNBlks    = nblks;
00002818  2042      7802          move.l    D2,A0
0000281A  2147 000C 7803          move.l    D7,12(A0)
                    7804   ; pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
0000281E  2042      7805          move.l    D2,A0
00002820  216E 0010 7806          move.l    16(A6),8(A0)
00002824  0008      
                    7807   ; *perr               = OS_ERR_NONE;
00002826  206E 0014 7808          move.l    20(A6),A0
0000282A  4210      7809          clr.b     (A0)
                    7810   ; return (pmem);
0000282C  2002      7811          move.l    D2,D0
                    7812   OSMemCreate_5:
0000282E  4CDF 04FC 7813          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00002832  4E5E      7814          unlk      A6
00002834  4E75      7815          rts
                    7816   ; }
                    7817   ; /*$PAGE*/
                    7818   ; /*
                    7819   ; *********************************************************************************************************
                    7820   ; *                                         GET A MEMORY BLOCK
                    7821   ; *
                    7822   ; * Description : Get a memory block from a partition
                    7823   ; *
                    7824   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    7825   ; *
                    7826   ; *               perr    is a pointer to a variable containing an error message which will be set by this
                    7827   ; *                       function to either:
                    7828   ; *
                    7829   ; *                       OS_ERR_NONE             if the memory partition has been created correctly.
                    7830   ; *                       OS_ERR_MEM_NO_FREE_BLKS if there are no more free memory blocks to allocate to caller
                    7831   ; *                       OS_ERR_MEM_INVALID_PMEM if you passed a NULL pointer for 'pmem'
                    7832   ; *
                    7833   ; * Returns     : A pointer to a memory block if no error is detected
                    7834   ; *               A pointer to NULL if an error is detected
                    7835   ; *********************************************************************************************************
                    7836   ; */
                    7837   ; void  *OSMemGet (OS_MEM  *pmem,
                    7838   ; INT8U   *perr)
                    7839   ; {
                    7840   _OSMemGet:
00002836  4E56 0000 7841          link      A6,#0
0000283A  48E7 3000 7842          movem.l   D2/D3,-(A7)
0000283E  242E 0008 7843          move.l    8(A6),D2
                    7844   ; void      *pblk;
                    7845   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    7846   ; OS_CPU_SR  cpu_sr = 0u;
                    7847   ; #endif
                    7848   ; #ifdef OS_SAFETY_CRITICAL
                    7849   ; if (perr == (INT8U *)0) {
                    7850   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7851   ; return ((void *)0);
                    7852   ; }
                    7853   ; #endif
                    7854   ; #if OS_ARG_CHK_EN > 0u
                    7855   ; if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
                    7856   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    7857   ; return ((void *)0);
                    7858   ; }
                    7859   ; #endif
                    7860   ; OS_ENTER_CRITICAL();
00002842  40E7      7861          dc.w      16615
00002844  007C      7862          dc.w      124
00002846  0700      7863          dc.w      1792
                    7864   ; if (pmem->OSMemNFree > 0u) {                      /* See if there are any free memory blocks       */
00002848  2042      7865          move.l    D2,A0
0000284A  2028 0010 7866          move.l    16(A0),D0
0000284E  0C80 0000 7867          cmp.l     #0,D0
00002852  0000      
00002854  6326      7868          bls.s     OSMemGet_1
                    7869   ; pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
00002856  2042      7870          move.l    D2,A0
00002858  2628 0004 7871          move.l    4(A0),D3
                    7872   ; pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
0000285C  2043      7873          move.l    D3,A0
0000285E  2242      7874          move.l    D2,A1
00002860  2350 0004 7875          move.l    (A0),4(A1)
                    7876   ; pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
00002864  2002      7877          move.l    D2,D0
00002866  0680 0000 7878          add.l     #16,D0
0000286A  0010      
0000286C  2040      7879          move.l    D0,A0
0000286E  5390      7880          subq.l    #1,(A0)
                    7881   ; OS_EXIT_CRITICAL();
00002870  46DF      7882          dc.w      18143
                    7883   ; *perr = OS_ERR_NONE;                          /*      No error                                 */
00002872  206E 000C 7884          move.l    12(A6),A0
00002876  4210      7885          clr.b     (A0)
                    7886   ; return (pblk);                                /*      Return memory block to caller            */
00002878  2003      7887          move.l    D3,D0
0000287A  600C      7888          bra.s     OSMemGet_3
                    7889   OSMemGet_1:
                    7890   ; }
                    7891   ; OS_EXIT_CRITICAL();
0000287C  46DF      7892          dc.w      18143
                    7893   ; *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
0000287E  206E 000C 7894          move.l    12(A6),A0
00002882  10BC 005D 7895          move.b    #93,(A0)
                    7896   ; return ((void *)0);                               /*      Return NULL pointer to caller            */
00002886  4280      7897          clr.l     D0
                    7898   OSMemGet_3:
00002888  4CDF 000C 7899          movem.l   (A7)+,D2/D3
0000288C  4E5E      7900          unlk      A6
0000288E  4E75      7901          rts
                    7902   ; }
                    7903   ; /*$PAGE*/
                    7904   ; /*
                    7905   ; *********************************************************************************************************
                    7906   ; *                                 GET THE NAME OF A MEMORY PARTITION
                    7907   ; *
                    7908   ; * Description: This function is used to obtain the name assigned to a memory partition.
                    7909   ; *
                    7910   ; * Arguments  : pmem      is a pointer to the memory partition
                    7911   ; *
                    7912   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the memory partition.
                    7913   ; *
                    7914   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    7915   ; *
                    7916   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    7917   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    7918   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    7919   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    7920   ; *
                    7921   ; * Returns    : The length of the string or 0 if 'pmem' is a NULL pointer.
                    7922   ; *********************************************************************************************************
                    7923   ; */
                    7924   ; #if OS_MEM_NAME_EN > 0u
                    7925   ; INT8U  OSMemNameGet (OS_MEM   *pmem,
                    7926   ; INT8U   **pname,
                    7927   ; INT8U    *perr)
                    7928   ; {
                    7929   _OSMemNameGet:
00002890  4E56 FFFC 7930          link      A6,#-4
                    7931   ; INT8U      len;
                    7932   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    7933   ; OS_CPU_SR  cpu_sr = 0u;
                    7934   ; #endif
                    7935   ; #ifdef OS_SAFETY_CRITICAL
                    7936   ; if (perr == (INT8U *)0) {
                    7937   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    7938   ; return (0u);
                    7939   ; }
                    7940   ; #endif
                    7941   ; #if OS_ARG_CHK_EN > 0u
                    7942   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    7943   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    7944   ; return (0u);
                    7945   ; }
                    7946   ; if (pname == (INT8U **)0) {                  /* Is 'pname' a NULL pointer?                         */
                    7947   ; *perr = OS_ERR_PNAME_NULL;
                    7948   ; return (0u);
                    7949   ; }
                    7950   ; #endif
                    7951   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00002894  1039 0080 7952          move.b    _OSIntNesting.L,D0
00002898  0246      
0000289A  0C00 0000 7953          cmp.b     #0,D0
0000289E  630C      7954          bls.s     OSMemNameGet_1
                    7955   ; *perr = OS_ERR_NAME_GET_ISR;
000028A0  206E 0010 7956          move.l    16(A6),A0
000028A4  10BC 0011 7957          move.b    #17,(A0)
                    7958   ; return (0u);
000028A8  4200      7959          clr.b     D0
000028AA  602E      7960          bra.s     OSMemNameGet_3
                    7961   OSMemNameGet_1:
                    7962   ; }
                    7963   ; OS_ENTER_CRITICAL();
000028AC  40E7      7964          dc.w      16615
000028AE  007C      7965          dc.w      124
000028B0  0700      7966          dc.w      1792
                    7967   ; *pname = pmem->OSMemName;
000028B2  206E 0008 7968          move.l    8(A6),A0
000028B6  226E 000C 7969          move.l    12(A6),A1
000028BA  22A8 0014 7970          move.l    20(A0),(A1)
                    7971   ; len    = OS_StrLen(*pname);
000028BE  206E 000C 7972          move.l    12(A6),A0
000028C2  2F10      7973          move.l    (A0),-(A7)
000028C4  4EB8 14A2 7974          jsr       _OS_StrLen
000028C8  584F      7975          addq.w    #4,A7
000028CA  1D40 FFFF 7976          move.b    D0,-1(A6)
                    7977   ; OS_EXIT_CRITICAL();
000028CE  46DF      7978          dc.w      18143
                    7979   ; *perr  = OS_ERR_NONE;
000028D0  206E 0010 7980          move.l    16(A6),A0
000028D4  4210      7981          clr.b     (A0)
                    7982   ; return (len);
000028D6  102E FFFF 7983          move.b    -1(A6),D0
                    7984   OSMemNameGet_3:
000028DA  4E5E      7985          unlk      A6
000028DC  4E75      7986          rts
                    7987   ; }
                    7988   ; #endif
                    7989   ; /*$PAGE*/
                    7990   ; /*
                    7991   ; *********************************************************************************************************
                    7992   ; *                                 ASSIGN A NAME TO A MEMORY PARTITION
                    7993   ; *
                    7994   ; * Description: This function assigns a name to a memory partition.
                    7995   ; *
                    7996   ; * Arguments  : pmem      is a pointer to the memory partition
                    7997   ; *
                    7998   ; *              pname     is a pointer to an ASCII string that contains the name of the memory partition.
                    7999   ; *
                    8000   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    8001   ; *
                    8002   ; *                        OS_ERR_NONE                if the name was copied to 'pname'
                    8003   ; *                        OS_ERR_MEM_INVALID_PMEM    if you passed a NULL pointer for 'pmem'
                    8004   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    8005   ; *                        OS_ERR_MEM_NAME_TOO_LONG   if the name doesn't fit in the storage area
                    8006   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    8007   ; *
                    8008   ; * Returns    : None
                    8009   ; *********************************************************************************************************
                    8010   ; */
                    8011   ; #if OS_MEM_NAME_EN > 0u
                    8012   ; void  OSMemNameSet (OS_MEM  *pmem,
                    8013   ; INT8U   *pname,
                    8014   ; INT8U   *perr)
                    8015   ; {
                    8016   _OSMemNameSet:
000028DE  4E56 0000 8017          link      A6,#0
                    8018   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8019   ; OS_CPU_SR  cpu_sr = 0u;
                    8020   ; #endif
                    8021   ; #ifdef OS_SAFETY_CRITICAL
                    8022   ; if (perr == (INT8U *)0) {
                    8023   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8024   ; return;
                    8025   ; }
                    8026   ; #endif
                    8027   ; #if OS_ARG_CHK_EN > 0u
                    8028   ; if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
                    8029   ; *perr = OS_ERR_MEM_INVALID_PMEM;
                    8030   ; return;
                    8031   ; }
                    8032   ; if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
                    8033   ; *perr = OS_ERR_PNAME_NULL;
                    8034   ; return;
                    8035   ; }
                    8036   ; #endif
                    8037   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
000028E2  1039 0080 8038          move.b    _OSIntNesting.L,D0
000028E6  0246      
000028E8  0C00 0000 8039          cmp.b     #0,D0
000028EC  630A      8040          bls.s     OSMemNameSet_1
                    8041   ; *perr = OS_ERR_NAME_SET_ISR;
000028EE  206E 0010 8042          move.l    16(A6),A0
000028F2  10BC 0012 8043          move.b    #18,(A0)
                    8044   ; return;
000028F6  6018      8045          bra.s     OSMemNameSet_3
                    8046   OSMemNameSet_1:
                    8047   ; }
                    8048   ; OS_ENTER_CRITICAL();
000028F8  40E7      8049          dc.w      16615
000028FA  007C      8050          dc.w      124
000028FC  0700      8051          dc.w      1792
                    8052   ; pmem->OSMemName = pname;
000028FE  206E 0008 8053          move.l    8(A6),A0
00002902  216E 000C 8054          move.l    12(A6),20(A0)
00002906  0014      
                    8055   ; OS_EXIT_CRITICAL();
00002908  46DF      8056          dc.w      18143
                    8057   ; *perr           = OS_ERR_NONE;
0000290A  206E 0010 8058          move.l    16(A6),A0
0000290E  4210      8059          clr.b     (A0)
                    8060   OSMemNameSet_3:
00002910  4E5E      8061          unlk      A6
00002912  4E75      8062          rts
                    8063   ; }
                    8064   ; #endif
                    8065   ; /*$PAGE*/
                    8066   ; /*
                    8067   ; *********************************************************************************************************
                    8068   ; *                                       RELEASE A MEMORY BLOCK
                    8069   ; *
                    8070   ; * Description : Returns a memory block to a partition
                    8071   ; *
                    8072   ; * Arguments   : pmem    is a pointer to the memory partition control block
                    8073   ; *
                    8074   ; *               pblk    is a pointer to the memory block being released.
                    8075   ; *
                    8076   ; * Returns     : OS_ERR_NONE              if the memory block was inserted into the partition
                    8077   ; *               OS_ERR_MEM_FULL          if you are returning a memory block to an already FULL memory
                    8078   ; *                                        partition (You freed more blocks than you allocated!)
                    8079   ; *               OS_ERR_MEM_INVALID_PMEM  if you passed a NULL pointer for 'pmem'
                    8080   ; *               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
                    8081   ; *********************************************************************************************************
                    8082   ; */
                    8083   ; INT8U  OSMemPut (OS_MEM  *pmem,
                    8084   ; void    *pblk)
                    8085   ; {
                    8086   _OSMemPut:
00002914  4E56 0000 8087          link      A6,#0
00002918  2F02      8088          move.l    D2,-(A7)
0000291A  242E 0008 8089          move.l    8(A6),D2
                    8090   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8091   ; OS_CPU_SR  cpu_sr = 0u;
                    8092   ; #endif
                    8093   ; #if OS_ARG_CHK_EN > 0u
                    8094   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8095   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8096   ; }
                    8097   ; if (pblk == (void *)0) {                     /* Must release a valid block                         */
                    8098   ; return (OS_ERR_MEM_INVALID_PBLK);
                    8099   ; }
                    8100   ; #endif
                    8101   ; OS_ENTER_CRITICAL();
0000291E  40E7      8102          dc.w      16615
00002920  007C      8103          dc.w      124
00002922  0700      8104          dc.w      1792
                    8105   ; if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
00002924  2042      8106          move.l    D2,A0
00002926  2242      8107          move.l    D2,A1
00002928  2028 0010 8108          move.l    16(A0),D0
0000292C  B0A9 000C 8109          cmp.l     12(A1),D0
00002930  6506      8110          blo.s     OSMemPut_1
                    8111   ; OS_EXIT_CRITICAL();
00002932  46DF      8112          dc.w      18143
                    8113   ; return (OS_ERR_MEM_FULL);
00002934  705E      8114          moveq     #94,D0
00002936  6024      8115          bra.s     OSMemPut_3
                    8116   OSMemPut_1:
                    8117   ; }
                    8118   ; *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
00002938  2042      8119          move.l    D2,A0
0000293A  202E 000C 8120          move.l    12(A6),D0
0000293E  2240      8121          move.l    D0,A1
00002940  22A8 0004 8122          move.l    4(A0),(A1)
                    8123   ; pmem->OSMemFreeList = pblk;
00002944  2042      8124          move.l    D2,A0
00002946  216E 000C 8125          move.l    12(A6),4(A0)
0000294A  0004      
                    8126   ; pmem->OSMemNFree++;                          /* One more memory block in this partition            */
0000294C  2002      8127          move.l    D2,D0
0000294E  0680 0000 8128          add.l     #16,D0
00002952  0010      
00002954  2040      8129          move.l    D0,A0
00002956  5290      8130          addq.l    #1,(A0)
                    8131   ; OS_EXIT_CRITICAL();
00002958  46DF      8132          dc.w      18143
                    8133   ; return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
0000295A  4200      8134          clr.b     D0
                    8135   OSMemPut_3:
0000295C  241F      8136          move.l    (A7)+,D2
0000295E  4E5E      8137          unlk      A6
00002960  4E75      8138          rts
                    8139   ; }
                    8140   ; /*$PAGE*/
                    8141   ; /*
                    8142   ; *********************************************************************************************************
                    8143   ; *                                       QUERY MEMORY PARTITION
                    8144   ; *
                    8145   ; * Description : This function is used to determine the number of free memory blocks and the number of
                    8146   ; *               used memory blocks from a memory partition.
                    8147   ; *
                    8148   ; * Arguments   : pmem        is a pointer to the memory partition control block
                    8149   ; *
                    8150   ; *               p_mem_data  is a pointer to a structure that will contain information about the memory
                    8151   ; *                           partition.
                    8152   ; *
                    8153   ; * Returns     : OS_ERR_NONE               if no errors were found.
                    8154   ; *               OS_ERR_MEM_INVALID_PMEM   if you passed a NULL pointer for 'pmem'
                    8155   ; *               OS_ERR_MEM_INVALID_PDATA  if you passed a NULL pointer to the data recipient.
                    8156   ; *********************************************************************************************************
                    8157   ; */
                    8158   ; #if OS_MEM_QUERY_EN > 0u
                    8159   ; INT8U  OSMemQuery (OS_MEM       *pmem,
                    8160   ; OS_MEM_DATA  *p_mem_data)
                    8161   ; {
                    8162   _OSMemQuery:
00002962  4E56 0000 8163          link      A6,#0
00002966  48E7 3000 8164          movem.l   D2/D3,-(A7)
0000296A  242E 000C 8165          move.l    12(A6),D2
0000296E  262E 0008 8166          move.l    8(A6),D3
                    8167   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    8168   ; OS_CPU_SR  cpu_sr = 0u;
                    8169   ; #endif
                    8170   ; #if OS_ARG_CHK_EN > 0u
                    8171   ; if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
                    8172   ; return (OS_ERR_MEM_INVALID_PMEM);
                    8173   ; }
                    8174   ; if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
                    8175   ; return (OS_ERR_MEM_INVALID_PDATA);
                    8176   ; }
                    8177   ; #endif
                    8178   ; OS_ENTER_CRITICAL();
00002972  40E7      8179          dc.w      16615
00002974  007C      8180          dc.w      124
00002976  0700      8181          dc.w      1792
                    8182   ; p_mem_data->OSAddr     = pmem->OSMemAddr;
00002978  2043      8183          move.l    D3,A0
0000297A  2242      8184          move.l    D2,A1
0000297C  2290      8185          move.l    (A0),(A1)
                    8186   ; p_mem_data->OSFreeList = pmem->OSMemFreeList;
0000297E  2043      8187          move.l    D3,A0
00002980  2242      8188          move.l    D2,A1
00002982  2368 0004 8189          move.l    4(A0),4(A1)
00002986  0004      
                    8190   ; p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
00002988  2043      8191          move.l    D3,A0
0000298A  2242      8192          move.l    D2,A1
0000298C  2368 0008 8193          move.l    8(A0),8(A1)
00002990  0008      
                    8194   ; p_mem_data->OSNBlks    = pmem->OSMemNBlks;
00002992  2043      8195          move.l    D3,A0
00002994  2242      8196          move.l    D2,A1
00002996  2368 000C 8197          move.l    12(A0),12(A1)
0000299A  000C      
                    8198   ; p_mem_data->OSNFree    = pmem->OSMemNFree;
0000299C  2043      8199          move.l    D3,A0
0000299E  2242      8200          move.l    D2,A1
000029A0  2368 0010 8201          move.l    16(A0),16(A1)
000029A4  0010      
                    8202   ; OS_EXIT_CRITICAL();
000029A6  46DF      8203          dc.w      18143
                    8204   ; p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
000029A8  2042      8205          move.l    D2,A0
000029AA  2028 000C 8206          move.l    12(A0),D0
000029AE  2042      8207          move.l    D2,A0
000029B0  90A8 0010 8208          sub.l     16(A0),D0
000029B4  2042      8209          move.l    D2,A0
000029B6  2140 0014 8210          move.l    D0,20(A0)
                    8211   ; return (OS_ERR_NONE);
000029BA  4200      8212          clr.b     D0
000029BC  4CDF 000C 8213          movem.l   (A7)+,D2/D3
000029C0  4E5E      8214          unlk      A6
000029C2  4E75      8215          rts
                    8216   ; }
                    8217   ; #endif                                           /* OS_MEM_QUERY_EN                                    */
                    8218   ; /*$PAGE*/
                    8219   ; /*
                    8220   ; *********************************************************************************************************
                    8221   ; *                                 INITIALIZE MEMORY PARTITION MANAGER
                    8222   ; *
                    8223   ; * Description : This function is called by uC/OS-II to initialize the memory partition manager.  Your
                    8224   ; *               application MUST NOT call this function.
                    8225   ; *
                    8226   ; * Arguments   : none
                    8227   ; *
                    8228   ; * Returns     : none
                    8229   ; *
                    8230   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    8231   ; *********************************************************************************************************
                    8232   ; */
                    8233   ; void  OS_MemInit (void)
                    8234   ; {
                    8235   _OS_MemInit:
000029C4  48E7 3020 8236          movem.l   D2/D3/A2,-(A7)
000029C8  45F9 0080 8237          lea       _OSMemTbl.L,A2
000029CC  0BD8      
                    8238   ; #if OS_MAX_MEM_PART == 1u
                    8239   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
                    8240   ; OSMemFreeList               = (OS_MEM *)&OSMemTbl[0]; /* Point to beginning of free list           */
                    8241   ; #if OS_MEM_NAME_EN > 0u
                    8242   ; OSMemFreeList->OSMemName    = (INT8U *)"?";           /* Unknown name                              */
                    8243   ; #endif
                    8244   ; #endif
                    8245   ; #if OS_MAX_MEM_PART >= 2u
                    8246   ; OS_MEM  *pmem;
                    8247   ; INT16U   i;
                    8248   ; OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
000029CE  4878 0078 8249          pea       120
000029D2  2F0A      8250          move.l    A2,-(A7)
000029D4  4EB8 13AC 8251          jsr       _OS_MemClr
000029D8  504F      8252          addq.w    #8,A7
                    8253   ; for (i = 0u; i < (OS_MAX_MEM_PART - 1u); i++) {       /* Init. list of free memory partitions      */
000029DA  4243      8254          clr.w     D3
                    8255   OS_MemInit_1:
000029DC  0C43 0004 8256          cmp.w     #4,D3
000029E0  6400 003C 8257          bhs       OS_MemInit_3
                    8258   ; pmem                = &OSMemTbl[i];               /* Point to memory control block (MCB)       */
000029E4  200A      8259          move.l    A2,D0
000029E6  C6BC 0000 8260          and.l     #65535,D3
000029EA  FFFF      
000029EC  2203      8261          move.l    D3,D1
000029EE  C3FC 0018 8262          muls      #24,D1
000029F2  D081      8263          add.l     D1,D0
000029F4  2400      8264          move.l    D0,D2
                    8265   ; pmem->OSMemFreeList = (void *)&OSMemTbl[i + 1u];  /* Chain list of free partitions             */
000029F6  200A      8266          move.l    A2,D0
000029F8  C6BC 0000 8267          and.l     #65535,D3
000029FC  FFFF      
000029FE  2203      8268          move.l    D3,D1
00002A00  5281      8269          addq.l    #1,D1
00002A02  C3FC 0018 8270          muls      #24,D1
00002A06  D081      8271          add.l     D1,D0
00002A08  2042      8272          move.l    D2,A0
00002A0A  2140 0004 8273          move.l    D0,4(A0)
                    8274   ; #if OS_MEM_NAME_EN > 0u
                    8275   ; pmem->OSMemName  = (INT8U *)(void *)"?";
00002A0E  41F9 0000 8276          lea       @ucos_ii_1.L,A0
00002A12  5A8E      
00002A14  2242      8277          move.l    D2,A1
00002A16  2348 0014 8278          move.l    A0,20(A1)
00002A1A  5243      8279          addq.w    #1,D3
00002A1C  60BE      8280          bra       OS_MemInit_1
                    8281   OS_MemInit_3:
                    8282   ; #endif
                    8283   ; }
                    8284   ; pmem                = &OSMemTbl[i];
00002A1E  200A      8285          move.l    A2,D0
00002A20  C6BC 0000 8286          and.l     #65535,D3
00002A24  FFFF      
00002A26  2203      8287          move.l    D3,D1
00002A28  C3FC 0018 8288          muls      #24,D1
00002A2C  D081      8289          add.l     D1,D0
00002A2E  2400      8290          move.l    D0,D2
                    8291   ; pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
00002A30  2042      8292          move.l    D2,A0
00002A32  42A8 0004 8293          clr.l     4(A0)
                    8294   ; #if OS_MEM_NAME_EN > 0u
                    8295   ; pmem->OSMemName = (INT8U *)(void *)"?";
00002A36  41F9 0000 8296          lea       @ucos_ii_1.L,A0
00002A3A  5A8E      
00002A3C  2242      8297          move.l    D2,A1
00002A3E  2348 0014 8298          move.l    A0,20(A1)
                    8299   ; #endif
                    8300   ; OSMemFreeList   = &OSMemTbl[0];                       /* Point to beginning of free list           */
00002A42  23CA 0080 8301          move.l    A2,_OSMemFreeList.L
00002A46  0BD4      
00002A48  4CDF 040C 8302          movem.l   (A7)+,D2/D3/A2
00002A4C  4E75      8303          rts
                    8304   ; /*
                    8305   ; *********************************************************************************************************
                    8306   ; *                                                uC/OS-II
                    8307   ; *                                          The Real-Time Kernel
                    8308   ; *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
                    8309   ; *
                    8310   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    8311   ; *                                           All Rights Reserved
                    8312   ; *
                    8313   ; * File    : OS_MUTEX.C
                    8314   ; * By      : Jean J. Labrosse
                    8315   ; * Version : V2.92.07
                    8316   ; *
                    8317   ; * LICENSING TERMS:
                    8318   ; * ---------------
                    8319   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    8320   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    8321   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    8322   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    8323   ; * licensing fee.
                    8324   ; *********************************************************************************************************
                    8325   ; */
                    8326   ; #define  MICRIUM_SOURCE
                    8327   ; #ifndef  OS_MASTER_FILE
                    8328   ; #include <ucos_ii.h>
                    8329   ; #endif
                    8330   ; #if OS_MUTEX_EN > 0u
                    8331   ; /*
                    8332   ; *********************************************************************************************************
                    8333   ; *                                           LOCAL CONSTANTS
                    8334   ; *********************************************************************************************************
                    8335   ; */
                    8336   ; #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
                    8337   ; #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
                    8338   ; #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
                    8339   ; /*
                    8340   ; *********************************************************************************************************
                    8341   ; *                                           LOCAL CONSTANTS
                    8342   ; *********************************************************************************************************
                    8343   ; */
                    8344   ; static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
                    8345   ; /*$PAGE*/
                    8346   ; /*
                    8347   ; *********************************************************************************************************
                    8348   ; *                                  ACCEPT MUTUAL EXCLUSION SEMAPHORE
                    8349   ; *
                    8350   ; * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
                    8351   ; *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
                    8352   ; *              not available or the event did not occur.
                    8353   ; *
                    8354   ; * Arguments  : pevent     is a pointer to the event control block
                    8355   ; *
                    8356   ; *              perr       is a pointer to an error code which will be returned to your application:
                    8357   ; *                            OS_ERR_NONE         if the call was successful.
                    8358   ; *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
                    8359   ; *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
                    8360   ; *                            OS_ERR_PEND_ISR     if you called this function from an ISR
                    8361   ; *                            OS_ERR_PCP_LOWER    If the priority of the task that owns the Mutex is
                    8362   ; *                                                HIGHER (i.e. a lower number) than the PCP.  This error
                    8363   ; *                                                indicates that you did not set the PCP higher (lower
                    8364   ; *                                                number) than ALL the tasks that compete for the Mutex.
                    8365   ; *                                                Unfortunately, this is something that could not be
                    8366   ; *                                                detected when the Mutex is created because we don't know
                    8367   ; *                                                what tasks will be using the Mutex.
                    8368   ; *
                    8369   ; * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
                    8370   ; *              == OS_FALSE   a) if the resource is not available
                    8371   ; *                            b) you didn't pass a pointer to a mutual exclusion semaphore
                    8372   ; *                            c) you called this function from an ISR
                    8373   ; *
                    8374   ; * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
                    8375   ; *              intended to be used by tasks only.
                    8376   ; *********************************************************************************************************
                    8377   ; */
                    8378   ; #if OS_MUTEX_ACCEPT_EN > 0u
                    8379   ; BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
                    8380   ; INT8U     *perr)
                    8381   ; {
                    8382   _OSMutexAccept:
00002A4E  4E56 0000 8383          link      A6,#0
00002A52  48E7 3820 8384          movem.l   D2/D3/D4/A2,-(A7)
00002A56  242E 0008 8385          move.l    8(A6),D2
00002A5A  262E 000C 8386          move.l    12(A6),D3
00002A5E  45F9 0080 8387          lea       _OSTCBCur.L,A2
00002A62  0360      
                    8388   ; INT8U      pcp;                                    /* Priority Ceiling Priority (PCP)              */
                    8389   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    8390   ; OS_CPU_SR  cpu_sr = 0u;
                    8391   ; #endif
                    8392   ; #ifdef OS_SAFETY_CRITICAL
                    8393   ; if (perr == (INT8U *)0) {
                    8394   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8395   ; return (OS_FALSE);
                    8396   ; }
                    8397   ; #endif
                    8398   ; #if OS_ARG_CHK_EN > 0u
                    8399   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    8400   ; *perr = OS_ERR_PEVENT_NULL;
                    8401   ; return (OS_FALSE);
                    8402   ; }
                    8403   ; #endif
                    8404   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
00002A64  2042      8405          move.l    D2,A0
00002A66  1010      8406          move.b    (A0),D0
00002A68  0C00 0004 8407          cmp.b     #4,D0
00002A6C  670C      8408          beq.s     OSMutexAccept_1
                    8409   ; *perr = OS_ERR_EVENT_TYPE;
00002A6E  2043      8410          move.l    D3,A0
00002A70  10BC 0001 8411          move.b    #1,(A0)
                    8412   ; return (OS_FALSE);
00002A74  4200      8413          clr.b     D0
00002A76  6000 0084 8414          bra       OSMutexAccept_3
                    8415   OSMutexAccept_1:
                    8416   ; }
                    8417   ; if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
00002A7A  1039 0080 8418          move.b    _OSIntNesting.L,D0
00002A7E  0246      
00002A80  0C00 0000 8419          cmp.b     #0,D0
00002A84  630C      8420          bls.s     OSMutexAccept_4
                    8421   ; *perr = OS_ERR_PEND_ISR;
00002A86  2043      8422          move.l    D3,A0
00002A88  10BC 0002 8423          move.b    #2,(A0)
                    8424   ; return (OS_FALSE);
00002A8C  4200      8425          clr.b     D0
00002A8E  6000 006C 8426          bra       OSMutexAccept_3
                    8427   OSMutexAccept_4:
                    8428   ; }
                    8429   ; OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
00002A92  40E7      8430          dc.w      16615
00002A94  007C      8431          dc.w      124
00002A96  0700      8432          dc.w      1792
                    8433   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                           */
00002A98  2042      8434          move.l    D2,A0
00002A9A  3028 0006 8435          move.w    6(A0),D0
00002A9E  E048      8436          lsr.w     #8,D0
00002AA0  1800      8437          move.b    D0,D4
                    8438   ; if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
00002AA2  2042      8439          move.l    D2,A0
00002AA4  3028 0006 8440          move.w    6(A0),D0
00002AA8  C07C 00FF 8441          and.w     #255,D0
00002AAC  0C40 00FF 8442          cmp.w     #255,D0
00002AB0  6600 0042 8443          bne       OSMutexAccept_6
                    8444   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
00002AB4  2042      8445          move.l    D2,A0
00002AB6  0268 FF00 8446          and.w     #65280,6(A0)
00002ABA  0006      
                    8447   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
00002ABC  2042      8448          move.l    D2,A0
00002ABE  2252      8449          move.l    (A2),A1
00002AC0  1029 0034 8450          move.b    52(A1),D0
00002AC4  C07C 00FF 8451          and.w     #255,D0
00002AC8  8168 0006 8452          or.w      D0,6(A0)
                    8453   ; pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
00002ACC  2042      8454          move.l    D2,A0
00002ACE  2152 0002 8455          move.l    (A2),2(A0)
                    8456   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
00002AD2  0C04 00FF 8457          cmp.b     #255,D4
00002AD6  6712      8458          beq.s     OSMutexAccept_8
00002AD8  2052      8459          move.l    (A2),A0
00002ADA  B828 0034 8460          cmp.b     52(A0),D4
00002ADE  650A      8461          blo.s     OSMutexAccept_8
                    8462   ; (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...      */
                    8463   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                  */
00002AE0  46DF      8464          dc.w      18143
                    8465   ; *perr = OS_ERR_PCP_LOWER;
00002AE2  2043      8466          move.l    D3,A0
00002AE4  10BC 0078 8467          move.b    #120,(A0)
00002AE8  6006      8468          bra.s     OSMutexAccept_9
                    8469   OSMutexAccept_8:
                    8470   ; } else {
                    8471   ; OS_EXIT_CRITICAL();
00002AEA  46DF      8472          dc.w      18143
                    8473   ; *perr = OS_ERR_NONE;
00002AEC  2043      8474          move.l    D3,A0
00002AEE  4210      8475          clr.b     (A0)
                    8476   OSMutexAccept_9:
                    8477   ; }
                    8478   ; return (OS_TRUE);
00002AF0  7001      8479          moveq     #1,D0
00002AF2  6008      8480          bra.s     OSMutexAccept_3
                    8481   OSMutexAccept_6:
                    8482   ; }
                    8483   ; OS_EXIT_CRITICAL();
00002AF4  46DF      8484          dc.w      18143
                    8485   ; *perr = OS_ERR_NONE;
00002AF6  2043      8486          move.l    D3,A0
00002AF8  4210      8487          clr.b     (A0)
                    8488   ; return (OS_FALSE);
00002AFA  4200      8489          clr.b     D0
                    8490   OSMutexAccept_3:
00002AFC  4CDF 041C 8491          movem.l   (A7)+,D2/D3/D4/A2
00002B00  4E5E      8492          unlk      A6
00002B02  4E75      8493          rts
                    8494   ; }
                    8495   ; #endif
                    8496   ; /*$PAGE*/
                    8497   ; /*
                    8498   ; *********************************************************************************************************
                    8499   ; *                                 CREATE A MUTUAL EXCLUSION SEMAPHORE
                    8500   ; *
                    8501   ; * Description: This function creates a mutual exclusion semaphore.
                    8502   ; *
                    8503   ; * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
                    8504   ; *                            other words, when the semaphore is acquired and a higher priority task
                    8505   ; *                            attempts to obtain the semaphore then the priority of the task owning the
                    8506   ; *                            semaphore is raised to this priority.  It is assumed that you will specify
                    8507   ; *                            a priority that is LOWER in value than ANY of the tasks competing for the
                    8508   ; *                            mutex. If the priority is specified as OS_PRIO_MUTEX_CEIL_DIS, then the
                    8509   ; *                            priority ceiling promotion is disabled. This way, the tasks accessing the
                    8510   ; *                            semaphore do not have their priority promoted.
                    8511   ; *
                    8512   ; *              perr          is a pointer to an error code which will be returned to your application:
                    8513   ; *                               OS_ERR_NONE         if the call was successful.
                    8514   ; *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
                    8515   ; *                               OS_ERR_PRIO_EXIST   if a task at the priority ceiling priority
                    8516   ; *                                                   already exist.
                    8517   ; *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
                    8518   ; *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
                    8519   ; *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
                    8520   ; *
                    8521   ; * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    8522   ; *                            created mutex.
                    8523   ; *              == (void *)0  if an error is detected.
                    8524   ; *
                    8525   ; * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' hold the priority number of the task
                    8526   ; *                 owning the mutex or 0xFF if no task owns the mutex.
                    8527   ; *
                    8528   ; *              2) The MOST  significant 8 bits of '.OSEventCnt' hold the priority number used to
                    8529   ; *                 reduce priority inversion or 0xFF (OS_PRIO_MUTEX_CEIL_DIS) if priority ceiling
                    8530   ; *                 promotion is disabled.
                    8531   ; *********************************************************************************************************
                    8532   ; */
                    8533   ; OS_EVENT  *OSMutexCreate (INT8U   prio,
                    8534   ; INT8U  *perr)
                    8535   ; {
                    8536   _OSMutexCreate:
00002B04  4E56 0000 8537          link      A6,#0
00002B08  48E7 3830 8538          movem.l   D2/D3/D4/A2/A3,-(A7)
00002B0C  162E 000B 8539          move.b    11(A6),D3
00002B10  C6BC 0000 8540          and.l     #255,D3
00002B14  00FF      
00002B16  282E 000C 8541          move.l    12(A6),D4
00002B1A  45F9 0080 8542          lea       _OSEventFreeList.L,A2
00002B1E  001A      
00002B20  47F9 0080 8543          lea       _OSTCBPrioTbl.L,A3
00002B24  0370      
                    8544   ; OS_EVENT  *pevent;
                    8545   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8546   ; OS_CPU_SR  cpu_sr = 0u;
                    8547   ; #endif
                    8548   ; #ifdef OS_SAFETY_CRITICAL
                    8549   ; if (perr == (INT8U *)0) {
                    8550   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8551   ; return ((OS_EVENT *)0);
                    8552   ; }
                    8553   ; #endif
                    8554   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    8555   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    8556   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8557   ; return ((OS_EVENT *)0);
                    8558   ; }
                    8559   ; #endif
                    8560   ; #if OS_ARG_CHK_EN > 0u
                    8561   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
                    8562   ; if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                             */
                    8563   ; *perr = OS_ERR_PRIO_INVALID;
                    8564   ; return ((OS_EVENT *)0);
                    8565   ; }
                    8566   ; }
                    8567   ; #endif
                    8568   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002B26  1039 0080 8569          move.b    _OSIntNesting.L,D0
00002B2A  0246      
00002B2C  0C00 0000 8570          cmp.b     #0,D0
00002B30  630C      8571          bls.s     OSMutexCreate_1
                    8572   ; *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
00002B32  2044      8573          move.l    D4,A0
00002B34  10BC 0010 8574          move.b    #16,(A0)
                    8575   ; return ((OS_EVENT *)0);
00002B38  4280      8576          clr.l     D0
00002B3A  6000 00A6 8577          bra       OSMutexCreate_3
                    8578   OSMutexCreate_1:
                    8579   ; }
                    8580   ; OS_ENTER_CRITICAL();
00002B3E  40E7      8581          dc.w      16615
00002B40  007C      8582          dc.w      124
00002B42  0700      8583          dc.w      1792
                    8584   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
00002B44  0C03 00FF 8585          cmp.b     #255,D3
00002B48  6730      8586          beq.s     OSMutexCreate_4
                    8587   ; if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist    */
00002B4A  C6BC 0000 8588          and.l     #255,D3
00002B4E  00FF      
00002B50  2003      8589          move.l    D3,D0
00002B52  E588      8590          lsl.l     #2,D0
00002B54  2033 0800 8591          move.l    0(A3,D0.L),D0
00002B58  670E      8592          beq.s     OSMutexCreate_6
                    8593   ; OS_EXIT_CRITICAL();                            /* Task already exist at priority ...       */
00002B5A  46DF      8594          dc.w      18143
                    8595   ; *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                     */
00002B5C  2044      8596          move.l    D4,A0
00002B5E  10BC 0028 8597          move.b    #40,(A0)
                    8598   ; return ((OS_EVENT *)0);
00002B62  4280      8599          clr.l     D0
00002B64  6000 007C 8600          bra       OSMutexCreate_3
                    8601   OSMutexCreate_6:
                    8602   ; }
                    8603   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry                  */
00002B68  C6BC 0000 8604          and.l     #255,D3
00002B6C  00FF      
00002B6E  2003      8605          move.l    D3,D0
00002B70  E588      8606          lsl.l     #2,D0
00002B72  27BC 0000 8607          move.l    #1,0(A3,D0.L)
00002B76  0001 0800 
                    8608   OSMutexCreate_4:
                    8609   ; }
                    8610   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
00002B7A  2412      8611          move.l    (A2),D2
                    8612   ; if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
00002B7C  4A82      8613          tst.l     D2
00002B7E  6622      8614          bne.s     OSMutexCreate_8
                    8615   ; if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
00002B80  0C03 00FF 8616          cmp.b     #255,D3
00002B84  670E      8617          beq.s     OSMutexCreate_10
                    8618   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry              */
00002B86  C6BC 0000 8619          and.l     #255,D3
00002B8A  00FF      
00002B8C  2003      8620          move.l    D3,D0
00002B8E  E588      8621          lsl.l     #2,D0
00002B90  42B3 0800 8622          clr.l     0(A3,D0.L)
                    8623   OSMutexCreate_10:
                    8624   ; }
                    8625   ; OS_EXIT_CRITICAL();
00002B94  46DF      8626          dc.w      18143
                    8627   ; *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks             */
00002B96  2044      8628          move.l    D4,A0
00002B98  10BC 0004 8629          move.b    #4,(A0)
                    8630   ; return (pevent);
00002B9C  2002      8631          move.l    D2,D0
00002B9E  6000 0042 8632          bra       OSMutexCreate_3
                    8633   OSMutexCreate_8:
                    8634   ; }
                    8635   ; OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list             */
00002BA2  2052      8636          move.l    (A2),A0
00002BA4  24A8 0002 8637          move.l    2(A0),(A2)
                    8638   ; OS_EXIT_CRITICAL();
00002BA8  46DF      8639          dc.w      18143
                    8640   ; pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
00002BAA  2042      8641          move.l    D2,A0
00002BAC  10BC 0004 8642          move.b    #4,(A0)
                    8643   ; pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.     */
00002BB0  1003      8644          move.b    D3,D0
00002BB2  C07C 00FF 8645          and.w     #255,D0
00002BB6  E148      8646          lsl.w     #8,D0
00002BB8  807C 00FF 8647          or.w      #255,D0
00002BBC  2042      8648          move.l    D2,A0
00002BBE  3140 0006 8649          move.w    D0,6(A0)
                    8650   ; pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex                 */
00002BC2  2042      8651          move.l    D2,A0
00002BC4  42A8 0002 8652          clr.l     2(A0)
                    8653   ; #if OS_EVENT_NAME_EN > 0u
                    8654   ; pevent->OSEventName = (INT8U *)(void *)"?";
00002BC8  41F9 0000 8655          lea       @ucos_ii_1.L,A0
00002BCC  5A8E      
00002BCE  2242      8656          move.l    D2,A1
00002BD0  2348 0012 8657          move.l    A0,18(A1)
                    8658   ; #endif
                    8659   ; OS_EventWaitListInit(pevent);
00002BD4  2F02      8660          move.l    D2,-(A7)
00002BD6  4EB8 10E0 8661          jsr       _OS_EventWaitListInit
00002BDA  584F      8662          addq.w    #4,A7
                    8663   ; *perr = OS_ERR_NONE;
00002BDC  2044      8664          move.l    D4,A0
00002BDE  4210      8665          clr.b     (A0)
                    8666   ; return (pevent);
00002BE0  2002      8667          move.l    D2,D0
                    8668   OSMutexCreate_3:
00002BE2  4CDF 0C1C 8669          movem.l   (A7)+,D2/D3/D4/A2/A3
00002BE6  4E5E      8670          unlk      A6
00002BE8  4E75      8671          rts
                    8672   ; }
                    8673   ; /*$PAGE*/
                    8674   ; /*
                    8675   ; *********************************************************************************************************
                    8676   ; *                                           DELETE A MUTEX
                    8677   ; *
                    8678   ; * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
                    8679   ; *
                    8680   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
                    8681   ; *
                    8682   ; *              opt           determines delete options as follows:
                    8683   ; *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
                    8684   ; *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
                    8685   ; *                                                    In this case, all the tasks pending will be readied.
                    8686   ; *
                    8687   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    8688   ; *                            OS_ERR_NONE             The call was successful and the mutex was deleted
                    8689   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
                    8690   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    8691   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
                    8692   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    8693   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    8694   ; *
                    8695   ; * Returns    : pevent        upon error
                    8696   ; *              (OS_EVENT *)0 if the mutex was successfully deleted.
                    8697   ; *
                    8698   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    8699   ; *                 the mutex MUST check the return code of OSMutexPend().
                    8700   ; *
                    8701   ; *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
                    8702   ; *                 time is directly proportional to the number of tasks waiting on the mutex.
                    8703   ; *
                    8704   ; *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
                    8705   ; *                 resource(s) will no longer be guarded by the mutex.
                    8706   ; *
                    8707   ; *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
                    8708   ; *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
                    8709   ; *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
                    8710   ; *                            that task will be made ready-to-run at its original priority.
                    8711   ; *********************************************************************************************************
                    8712   ; */
                    8713   ; #if OS_MUTEX_DEL_EN > 0u
                    8714   ; OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
                    8715   ; INT8U      opt,
                    8716   ; INT8U     *perr)
                    8717   ; {
                    8718   _OSMutexDel:
00002BEA  4E56 FFFC 8719          link      A6,#-4
00002BEE  48E7 3F20 8720          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00002BF2  242E 0008 8721          move.l    8(A6),D2
00002BF6  282E 0010 8722          move.l    16(A6),D4
00002BFA  45F9 0080 8723          lea       _OSEventFreeList.L,A2
00002BFE  001A      
                    8724   ; BOOLEAN    tasks_waiting;
                    8725   ; OS_EVENT  *pevent_return;
                    8726   ; INT8U      pcp;                                        /* Priority ceiling priority                */
                    8727   ; INT8U      prio;
                    8728   ; OS_TCB    *ptcb;
                    8729   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    8730   ; OS_CPU_SR  cpu_sr = 0u;
                    8731   ; #endif
                    8732   ; #ifdef OS_SAFETY_CRITICAL
                    8733   ; if (perr == (INT8U *)0) {
                    8734   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    8735   ; return ((OS_EVENT *)0);
                    8736   ; }
                    8737   ; #endif
                    8738   ; #if OS_ARG_CHK_EN > 0u
                    8739   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    8740   ; *perr = OS_ERR_PEVENT_NULL;
                    8741   ; return (pevent);
                    8742   ; }
                    8743   ; #endif
                    8744   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00002C00  2042      8745          move.l    D2,A0
00002C02  1010      8746          move.b    (A0),D0
00002C04  0C00 0004 8747          cmp.b     #4,D0
00002C08  670C      8748          beq.s     OSMutexDel_1
                    8749   ; *perr = OS_ERR_EVENT_TYPE;
00002C0A  2044      8750          move.l    D4,A0
00002C0C  10BC 0001 8751          move.b    #1,(A0)
                    8752   ; return (pevent);
00002C10  2002      8753          move.l    D2,D0
00002C12  6000 017C 8754          bra       OSMutexDel_3
                    8755   OSMutexDel_1:
                    8756   ; }
                    8757   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002C16  1039 0080 8758          move.b    _OSIntNesting.L,D0
00002C1A  0246      
00002C1C  0C00 0000 8759          cmp.b     #0,D0
00002C20  630C      8760          bls.s     OSMutexDel_4
                    8761   ; *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
00002C22  2044      8762          move.l    D4,A0
00002C24  10BC 000F 8763          move.b    #15,(A0)
                    8764   ; return (pevent);
00002C28  2002      8765          move.l    D2,D0
00002C2A  6000 0164 8766          bra       OSMutexDel_3
                    8767   OSMutexDel_4:
                    8768   ; }
                    8769   ; OS_ENTER_CRITICAL();
00002C2E  40E7      8770          dc.w      16615
00002C30  007C      8771          dc.w      124
00002C32  0700      8772          dc.w      1792
                    8773   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
00002C34  2042      8774          move.l    D2,A0
00002C36  1028 0008 8775          move.b    8(A0),D0
00002C3A  6704      8776          beq.s     OSMutexDel_6
                    8777   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00002C3C  7E01      8778          moveq     #1,D7
00002C3E  6002      8779          bra.s     OSMutexDel_7
                    8780   OSMutexDel_6:
                    8781   ; } else {
                    8782   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00002C40  7E00      8783          moveq     #0,D7
                    8784   OSMutexDel_7:
                    8785   ; }
                    8786   ; switch (opt) {
00002C42  102E 000F 8787          move.b    15(A6),D0
00002C46  C0BC 0000 8788          and.l     #255,D0
00002C4A  00FF      
00002C4C  0C80 0000 8789          cmp.l     #1,D0
00002C50  0001      
00002C52  6700 006E 8790          beq       OSMutexDel_11
00002C56  6200 012C 8791          bhi       OSMutexDel_8
00002C5A  4A80      8792          tst.l     D0
00002C5C  6704      8793          beq.s     OSMutexDel_10
00002C5E  6000 0124 8794          bra       OSMutexDel_8
                    8795   OSMutexDel_10:
                    8796   ; case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
                    8797   ; if (tasks_waiting == OS_FALSE) {
00002C62  4A07      8798          tst.b     D7
00002C64  6600 004E 8799          bne       OSMutexDel_13
                    8800   ; #if OS_EVENT_NAME_EN > 0u
                    8801   ; pevent->OSEventName   = (INT8U *)(void *)"?";
00002C68  41F9 0000 8802          lea       @ucos_ii_1.L,A0
00002C6C  5A8E      
00002C6E  2242      8803          move.l    D2,A1
00002C70  2348 0012 8804          move.l    A0,18(A1)
                    8805   ; #endif
                    8806   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
00002C74  2042      8807          move.l    D2,A0
00002C76  3028 0006 8808          move.w    6(A0),D0
00002C7A  E048      8809          lsr.w     #8,D0
00002C7C  1600      8810          move.b    D0,D3
                    8811   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00002C7E  0C03 00FF 8812          cmp.b     #255,D3
00002C82  6714      8813          beq.s     OSMutexDel_15
                    8814   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                          */
00002C84  C6BC 0000 8815          and.l     #255,D3
00002C88  00FF      
00002C8A  2003      8816          move.l    D3,D0
00002C8C  E588      8817          lsl.l     #2,D0
00002C8E  41F9 0080 8818          lea       _OSTCBPrioTbl.L,A0
00002C92  0370      
00002C94  42B0 0800 8819          clr.l     0(A0,D0.L)
                    8820   OSMutexDel_15:
                    8821   ; }
                    8822   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
00002C98  2042      8823          move.l    D2,A0
00002C9A  4210      8824          clr.b     (A0)
                    8825   ; pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free list  */
00002C9C  2042      8826          move.l    D2,A0
00002C9E  2152 0002 8827          move.l    (A2),2(A0)
                    8828   ; pevent->OSEventCnt    = 0u;
00002CA2  2042      8829          move.l    D2,A0
00002CA4  4268 0006 8830          clr.w     6(A0)
                    8831   ; OSEventFreeList       = pevent;
00002CA8  2482      8832          move.l    D2,(A2)
                    8833   ; OS_EXIT_CRITICAL();
00002CAA  46DF      8834          dc.w      18143
                    8835   ; *perr                 = OS_ERR_NONE;
00002CAC  2044      8836          move.l    D4,A0
00002CAE  4210      8837          clr.b     (A0)
                    8838   ; pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted                   */
00002CB0  4285      8839          clr.l     D5
00002CB2  600A      8840          bra.s     OSMutexDel_14
                    8841   OSMutexDel_13:
                    8842   ; } else {
                    8843   ; OS_EXIT_CRITICAL();
00002CB4  46DF      8844          dc.w      18143
                    8845   ; *perr                 = OS_ERR_TASK_WAITING;
00002CB6  2044      8846          move.l    D4,A0
00002CB8  10BC 0049 8847          move.b    #73,(A0)
                    8848   ; pevent_return         = pevent;
00002CBC  2A02      8849          move.l    D2,D5
                    8850   OSMutexDel_14:
                    8851   ; }
                    8852   ; break;
00002CBE  6000 00CE 8853          bra       OSMutexDel_9
                    8854   OSMutexDel_11:
                    8855   ; case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
                    8856   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex       */
00002CC2  2042      8857          move.l    D2,A0
00002CC4  3028 0006 8858          move.w    6(A0),D0
00002CC8  E048      8859          lsr.w     #8,D0
00002CCA  1600      8860          move.b    D0,D3
                    8861   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00002CCC  0C03 00FF 8862          cmp.b     #255,D3
00002CD0  6700 0038 8863          beq       OSMutexDel_21
                    8864   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig prio  */
00002CD4  2042      8865          move.l    D2,A0
00002CD6  3028 0006 8866          move.w    6(A0),D0
00002CDA  C07C 00FF 8867          and.w     #255,D0
00002CDE  1D40 FFFF 8868          move.b    D0,-1(A6)
                    8869   ; ptcb = (OS_TCB *)pevent->OSEventPtr;
00002CE2  2042      8870          move.l    D2,A0
00002CE4  2C28 0002 8871          move.l    2(A0),D6
                    8872   ; if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex           */
00002CE8  4A86      8873          tst.l     D6
00002CEA  671E      8874          beq.s     OSMutexDel_21
                    8875   ; if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed         */
00002CEC  2046      8876          move.l    D6,A0
00002CEE  B628 0034 8877          cmp.b     52(A0),D3
00002CF2  6616      8878          bne.s     OSMutexDel_21
                    8879   ; OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio    */
00002CF4  122E FFFF 8880          move.b    -1(A6),D1
00002CF8  C2BC 0000 8881          and.l     #255,D1
00002CFC  00FF      
00002CFE  2F01      8882          move.l    D1,-(A7)
00002D00  2F06      8883          move.l    D6,-(A7)
00002D02  4EB9 0000 8884          jsr       @ucos_ii_OSMutex_RdyAtPrio
00002D06  3246      
00002D08  504F      8885          addq.w    #8,A7
                    8886   OSMutexDel_21:
                    8887   ; }
                    8888   ; }
                    8889   ; }
                    8890   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
                    8891   OSMutexDel_23:
00002D0A  2042      8892          move.l    D2,A0
00002D0C  1028 0008 8893          move.b    8(A0),D0
00002D10  671C      8894          beq.s     OSMutexDel_25
                    8895   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
00002D12  4878 0002 8896          pea       2
00002D16  4878 0010 8897          pea       16
00002D1A  42A7      8898          clr.l     -(A7)
00002D1C  2F02      8899          move.l    D2,-(A7)
00002D1E  4EB8 0E18 8900          jsr       _OS_EventTaskRdy
00002D22  DEFC 0010 8901          add.w     #16,A7
00002D26  C0BC 0000 8902          and.l     #255,D0
00002D2A  00FF      
00002D2C  60DC      8903          bra       OSMutexDel_23
                    8904   OSMutexDel_25:
                    8905   ; }
                    8906   ; #if OS_EVENT_NAME_EN > 0u
                    8907   ; pevent->OSEventName   = (INT8U *)(void *)"?";
00002D2E  41F9 0000 8908          lea       @ucos_ii_1.L,A0
00002D32  5A8E      
00002D34  2242      8909          move.l    D2,A1
00002D36  2348 0012 8910          move.l    A0,18(A1)
                    8911   ; #endif
                    8912   ; pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
00002D3A  2042      8913          move.l    D2,A0
00002D3C  3028 0006 8914          move.w    6(A0),D0
00002D40  E048      8915          lsr.w     #8,D0
00002D42  1600      8916          move.b    D0,D3
                    8917   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00002D44  0C03 00FF 8918          cmp.b     #255,D3
00002D48  6714      8919          beq.s     OSMutexDel_26
                    8920   ; OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                          */
00002D4A  C6BC 0000 8921          and.l     #255,D3
00002D4E  00FF      
00002D50  2003      8922          move.l    D3,D0
00002D52  E588      8923          lsl.l     #2,D0
00002D54  41F9 0080 8924          lea       _OSTCBPrioTbl.L,A0
00002D58  0370      
00002D5A  42B0 0800 8925          clr.l     0(A0,D0.L)
                    8926   OSMutexDel_26:
                    8927   ; }
                    8928   ; pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
00002D5E  2042      8929          move.l    D2,A0
00002D60  4210      8930          clr.b     (A0)
                    8931   ; pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free list  */
00002D62  2042      8932          move.l    D2,A0
00002D64  2152 0002 8933          move.l    (A2),2(A0)
                    8934   ; pevent->OSEventCnt    = 0u;
00002D68  2042      8935          move.l    D2,A0
00002D6A  4268 0006 8936          clr.w     6(A0)
                    8937   ; OSEventFreeList       = pevent;               /* Get next free event control block        */
00002D6E  2482      8938          move.l    D2,(A2)
                    8939   ; OS_EXIT_CRITICAL();
00002D70  46DF      8940          dc.w      18143
                    8941   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00002D72  0C07 0001 8942          cmp.b     #1,D7
00002D76  6604      8943          bne.s     OSMutexDel_28
                    8944   ; OS_Sched();                               /* Find highest priority task ready to run  */
00002D78  4EB8 13F8 8945          jsr       _OS_Sched
                    8946   OSMutexDel_28:
                    8947   ; }
                    8948   ; *perr         = OS_ERR_NONE;
00002D7C  2044      8949          move.l    D4,A0
00002D7E  4210      8950          clr.b     (A0)
                    8951   ; pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
00002D80  4285      8952          clr.l     D5
                    8953   ; break;
00002D82  600A      8954          bra.s     OSMutexDel_9
                    8955   OSMutexDel_8:
                    8956   ; default:
                    8957   ; OS_EXIT_CRITICAL();
00002D84  46DF      8958          dc.w      18143
                    8959   ; *perr         = OS_ERR_INVALID_OPT;
00002D86  2044      8960          move.l    D4,A0
00002D88  10BC 0007 8961          move.b    #7,(A0)
                    8962   ; pevent_return = pevent;
00002D8C  2A02      8963          move.l    D2,D5
                    8964   ; break;
                    8965   OSMutexDel_9:
                    8966   ; }
                    8967   ; return (pevent_return);
00002D8E  2005      8968          move.l    D5,D0
                    8969   OSMutexDel_3:
00002D90  4CDF 04FC 8970          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00002D94  4E5E      8971          unlk      A6
00002D96  4E75      8972          rts
                    8973   ; }
                    8974   ; #endif
                    8975   ; /*$PAGE*/
                    8976   ; /*
                    8977   ; *********************************************************************************************************
                    8978   ; *                                 PEND ON MUTUAL EXCLUSION SEMAPHORE
                    8979   ; *
                    8980   ; * Description: This function waits for a mutual exclusion semaphore.
                    8981   ; *
                    8982   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    8983   ; *                            mutex.
                    8984   ; *
                    8985   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    8986   ; *                            wait for the resource up to the amount of time specified by this argument.
                    8987   ; *                            If you specify 0, however, your task will wait forever at the specified
                    8988   ; *                            mutex or, until the resource becomes available.
                    8989   ; *
                    8990   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    8991   ; *                            messages are:
                    8992   ; *                               OS_ERR_NONE        The call was successful and your task owns the mutex
                    8993   ; *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
                    8994   ; *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
                    8995   ; *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
                    8996   ; *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
                    8997   ; *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
                    8998   ; *                                                  would lead to a suspension.
                    8999   ; *                               OS_ERR_PCP_LOWER   If the priority of the task that owns the Mutex is
                    9000   ; *                                                  HIGHER (i.e. a lower number) than the PCP.  This error
                    9001   ; *                                                  indicates that you did not set the PCP higher (lower
                    9002   ; *                                                  number) than ALL the tasks that compete for the Mutex.
                    9003   ; *                                                  Unfortunately, this is something that could not be
                    9004   ; *                                                  detected when the Mutex is created because we don't know
                    9005   ; *                                                  what tasks will be using the Mutex.
                    9006   ; *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
                    9007   ; *
                    9008   ; * Returns    : none
                    9009   ; *
                    9010   ; * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
                    9011   ; *
                    9012   ; *              2) You MUST NOT change the priority of the task that owns the mutex
                    9013   ; *********************************************************************************************************
                    9014   ; */
                    9015   ; void  OSMutexPend (OS_EVENT  *pevent,
                    9016   ; INT32U     timeout,
                    9017   ; INT8U     *perr)
                    9018   ; {
                    9019   _OSMutexPend:
00002D98  4E56 FFFC 9020          link      A6,#-4
00002D9C  48E7 3F30 9021          movem.l   D2/D3/D4/D5/D6/D7/A2/A3,-(A7)
00002DA0  45F9 0080 9022          lea       _OSTCBCur.L,A2
00002DA4  0360      
00002DA6  262E 0008 9023          move.l    8(A6),D3
00002DAA  2A2E 0010 9024          move.l    16(A6),D5
00002DAE  47F9 0080 9025          lea       _OSRdyTbl.L,A3
00002DB2  0250      
                    9026   ; INT8U      pcp;                                        /* Priority Ceiling Priority (PCP)          */
                    9027   ; INT8U      mprio;                                      /* Mutex owner priority                     */
                    9028   ; BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
                    9029   ; OS_TCB    *ptcb;
                    9030   ; OS_EVENT  *pevent2;
                    9031   ; INT8U      y;
                    9032   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    9033   ; OS_CPU_SR  cpu_sr = 0u;
                    9034   ; #endif
                    9035   ; #ifdef OS_SAFETY_CRITICAL
                    9036   ; if (perr == (INT8U *)0) {
                    9037   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9038   ; return;
                    9039   ; }
                    9040   ; #endif
                    9041   ; #if OS_ARG_CHK_EN > 0u
                    9042   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9043   ; *perr = OS_ERR_PEVENT_NULL;
                    9044   ; return;
                    9045   ; }
                    9046   ; #endif
                    9047   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
00002DB4  2043      9048          move.l    D3,A0
00002DB6  1010      9049          move.b    (A0),D0
00002DB8  0C00 0004 9050          cmp.b     #4,D0
00002DBC  670A      9051          beq.s     OSMutexPend_1
                    9052   ; *perr = OS_ERR_EVENT_TYPE;
00002DBE  2045      9053          move.l    D5,A0
00002DC0  10BC 0001 9054          move.b    #1,(A0)
                    9055   ; return;
00002DC4  6000 02AC 9056          bra       OSMutexPend_3
                    9057   OSMutexPend_1:
                    9058   ; }
                    9059   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00002DC8  1039 0080 9060          move.b    _OSIntNesting.L,D0
00002DCC  0246      
00002DCE  0C00 0000 9061          cmp.b     #0,D0
00002DD2  630A      9062          bls.s     OSMutexPend_4
                    9063   ; *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
00002DD4  2045      9064          move.l    D5,A0
00002DD6  10BC 0002 9065          move.b    #2,(A0)
                    9066   ; return;
00002DDA  6000 0296 9067          bra       OSMutexPend_3
                    9068   OSMutexPend_4:
                    9069   ; }
                    9070   ; if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
00002DDE  1039 0080 9071          move.b    _OSLockNesting.L,D0
00002DE2  0248      
00002DE4  0C00 0000 9072          cmp.b     #0,D0
00002DE8  630A      9073          bls.s     OSMutexPend_6
                    9074   ; *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
00002DEA  2045      9075          move.l    D5,A0
00002DEC  10BC 000D 9076          move.b    #13,(A0)
                    9077   ; return;
00002DF0  6000 0280 9078          bra       OSMutexPend_3
                    9079   OSMutexPend_6:
                    9080   ; }
                    9081   ; /*$PAGE*/
                    9082   ; OS_ENTER_CRITICAL();
00002DF4  40E7      9083          dc.w      16615
00002DF6  007C      9084          dc.w      124
00002DF8  0700      9085          dc.w      1792
                    9086   ; pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                       */
00002DFA  2043      9087          move.l    D3,A0
00002DFC  3028 0006 9088          move.w    6(A0),D0
00002E00  E048      9089          lsr.w     #8,D0
00002E02  1E00      9090          move.b    D0,D7
                    9091   ; /* Is Mutex available?                      */
                    9092   ; if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
00002E04  2043      9093          move.l    D3,A0
00002E06  3028 0006 9094          move.w    6(A0),D0
00002E0A  C07C 00FF 9095          and.w     #255,D0
00002E0E  C07C 00FF 9096          and.w     #255,D0
00002E12  0C40 00FF 9097          cmp.w     #255,D0
00002E16  6600 0042 9098          bne       OSMutexPend_8
                    9099   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
00002E1A  2043      9100          move.l    D3,A0
00002E1C  0268 FF00 9101          and.w     #65280,6(A0)
00002E20  0006      
                    9102   ; pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
00002E22  2043      9103          move.l    D3,A0
00002E24  2252      9104          move.l    (A2),A1
00002E26  1029 0034 9105          move.b    52(A1),D0
00002E2A  C07C 00FF 9106          and.w     #255,D0
00002E2E  8168 0006 9107          or.w      D0,6(A0)
                    9108   ; pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
00002E32  2043      9109          move.l    D3,A0
00002E34  2152 0002 9110          move.l    (A2),2(A0)
                    9111   ; if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
00002E38  0C07 00FF 9112          cmp.b     #255,D7
00002E3C  6712      9113          beq.s     OSMutexPend_10
00002E3E  2052      9114          move.l    (A2),A0
00002E40  BE28 0034 9115          cmp.b     52(A0),D7
00002E44  650A      9116          blo.s     OSMutexPend_10
                    9117   ; (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio ...  */
                    9118   ; OS_EXIT_CRITICAL();                           /*      ... than current task!              */
00002E46  46DF      9119          dc.w      18143
                    9120   ; *perr = OS_ERR_PCP_LOWER;
00002E48  2045      9121          move.l    D5,A0
00002E4A  10BC 0078 9122          move.b    #120,(A0)
00002E4E  6006      9123          bra.s     OSMutexPend_11
                    9124   OSMutexPend_10:
                    9125   ; } else {
                    9126   ; OS_EXIT_CRITICAL();
00002E50  46DF      9127          dc.w      18143
                    9128   ; *perr = OS_ERR_NONE;
00002E52  2045      9129          move.l    D5,A0
00002E54  4210      9130          clr.b     (A0)
                    9131   OSMutexPend_11:
                    9132   ; }
                    9133   ; return;
00002E56  6000 021A 9134          bra       OSMutexPend_3
                    9135   OSMutexPend_8:
                    9136   ; }
                    9137   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
00002E5A  0C07 00FF 9138          cmp.b     #255,D7
00002E5E  6700 018A 9139          beq       OSMutexPend_16
                    9140   ; mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owner   */
00002E62  2043      9141          move.l    D3,A0
00002E64  3028 0006 9142          move.w    6(A0),D0
00002E68  C07C 00FF 9143          and.w     #255,D0
00002E6C  1D40 FFFE 9144          move.b    D0,-2(A6)
                    9145   ; ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owner   */
00002E70  2043      9146          move.l    D3,A0
00002E72  2428 0002 9147          move.l    2(A0),D2
                    9148   ; if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of owner?*/
00002E76  2042      9149          move.l    D2,A0
00002E78  BE28 0034 9150          cmp.b     52(A0),D7
00002E7C  6400 016C 9151          bhs       OSMutexPend_16
                    9152   ; if (mprio > OSTCBCur->OSTCBPrio) {
00002E80  2052      9153          move.l    (A2),A0
00002E82  102E FFFE 9154          move.b    -2(A6),D0
00002E86  B028 0034 9155          cmp.b     52(A0),D0
00002E8A  6300 015E 9156          bls       OSMutexPend_16
                    9157   ; y = ptcb->OSTCBY;
00002E8E  2042      9158          move.l    D2,A0
00002E90  1C28 0036 9159          move.b    54(A0),D6
                    9160   ; if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is ready   */
00002E94  CCBC 0000 9161          and.l     #255,D6
00002E98  00FF      
00002E9A  1033 6800 9162          move.b    0(A3,D6.L),D0
00002E9E  2042      9163          move.l    D2,A0
00002EA0  C028 0037 9164          and.b     55(A0),D0
00002EA4  6736      9165          beq.s     OSMutexPend_18
                    9166   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy ...*/
00002EA6  CCBC 0000 9167          and.l     #255,D6
00002EAA  00FF      
00002EAC  2042      9168          move.l    D2,A0
00002EAE  1028 0037 9169          move.b    55(A0),D0
00002EB2  4600      9170          not.b     D0
00002EB4  C133 6800 9171          and.b     D0,0(A3,D6.L)
                    9172   ; if (OSRdyTbl[y] == 0u) {                      /*          ... list at current prio */
00002EB8  CCBC 0000 9173          and.l     #255,D6
00002EBC  00FF      
00002EBE  1033 6800 9174          move.b    0(A3,D6.L),D0
00002EC2  660E      9175          bne.s     OSMutexPend_20
                    9176   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00002EC4  2042      9177          move.l    D2,A0
00002EC6  1028 0038 9178          move.b    56(A0),D0
00002ECA  4600      9179          not.b     D0
00002ECC  C139 0080 9180          and.b     D0,_OSRdyGrp.L
00002ED0  024E      
                    9181   OSMutexPend_20:
                    9182   ; }
                    9183   ; rdy = OS_TRUE;
00002ED2  1D7C 0001 9184          move.b    #1,-1(A6)
00002ED6  FFFF      
00002ED8  6000 004C 9185          bra       OSMutexPend_19
                    9186   OSMutexPend_18:
                    9187   ; } else {
                    9188   ; pevent2 = ptcb->OSTCBEventPtr;
00002EDC  2042      9189          move.l    D2,A0
00002EDE  2828 001C 9190          move.l    28(A0),D4
                    9191   ; if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list       */
00002EE2  4A84      9192          tst.l     D4
00002EE4  6700 003C 9193          beq       OSMutexPend_24
                    9194   ; y = ptcb->OSTCBY;
00002EE8  2042      9195          move.l    D2,A0
00002EEA  1C28 0036 9196          move.b    54(A0),D6
                    9197   ; pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
00002EEE  2044      9198          move.l    D4,A0
00002EF0  CCBC 0000 9199          and.l     #255,D6
00002EF4  00FF      
00002EF6  D1C6      9200          add.l     D6,A0
00002EF8  2242      9201          move.l    D2,A1
00002EFA  1029 0037 9202          move.b    55(A1),D0
00002EFE  4600      9203          not.b     D0
00002F00  C128 000A 9204          and.b     D0,10(A0)
                    9205   ; if (pevent2->OSEventTbl[y] == 0u) {
00002F04  2044      9206          move.l    D4,A0
00002F06  CCBC 0000 9207          and.l     #255,D6
00002F0A  00FF      
00002F0C  D1C6      9208          add.l     D6,A0
00002F0E  1028 000A 9209          move.b    10(A0),D0
00002F12  660E      9210          bne.s     OSMutexPend_24
                    9211   ; pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00002F14  2044      9212          move.l    D4,A0
00002F16  2242      9213          move.l    D2,A1
00002F18  1029 0038 9214          move.b    56(A1),D0
00002F1C  4600      9215          not.b     D0
00002F1E  C128 0008 9216          and.b     D0,8(A0)
                    9217   OSMutexPend_24:
                    9218   ; }
                    9219   ; }
                    9220   ; rdy = OS_FALSE;                        /* No                                       */
00002F22  422E FFFF 9221          clr.b     -1(A6)
                    9222   OSMutexPend_19:
                    9223   ; }
                    9224   ; ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP            */
00002F26  2042      9225          move.l    D2,A0
00002F28  1147 0034 9226          move.b    D7,52(A0)
                    9227   ; #if OS_LOWEST_PRIO <= 63u
                    9228   ; ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
00002F2C  2042      9229          move.l    D2,A0
00002F2E  1028 0034 9230          move.b    52(A0),D0
00002F32  E608      9231          lsr.b     #3,D0
00002F34  2042      9232          move.l    D2,A0
00002F36  1140 0036 9233          move.b    D0,54(A0)
                    9234   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
00002F3A  2042      9235          move.l    D2,A0
00002F3C  1028 0034 9236          move.b    52(A0),D0
00002F40  C03C 0007 9237          and.b     #7,D0
00002F44  2042      9238          move.l    D2,A0
00002F46  1140 0035 9239          move.b    D0,53(A0)
                    9240   ; #else
                    9241   ; ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
                    9242   ; ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
                    9243   ; #endif
                    9244   ; ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
00002F4A  7001      9245          moveq     #1,D0
00002F4C  2042      9246          move.l    D2,A0
00002F4E  1228 0036 9247          move.b    54(A0),D1
00002F52  C2BC 0000 9248          and.l     #255,D1
00002F56  00FF      
00002F58  E3A8      9249          lsl.l     D1,D0
00002F5A  2042      9250          move.l    D2,A0
00002F5C  1140 0038 9251          move.b    D0,56(A0)
                    9252   ; ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
00002F60  7001      9253          moveq     #1,D0
00002F62  2042      9254          move.l    D2,A0
00002F64  1228 0035 9255          move.b    53(A0),D1
00002F68  C2BC 0000 9256          and.l     #255,D1
00002F6C  00FF      
00002F6E  E3A8      9257          lsl.l     D1,D0
00002F70  2042      9258          move.l    D2,A0
00002F72  1140 0037 9259          move.b    D0,55(A0)
                    9260   ; if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority ...*/
00002F76  102E FFFF 9261          move.b    -1(A6),D0
00002F7A  0C00 0001 9262          cmp.b     #1,D0
00002F7E  6626      9263          bne.s     OSMutexPend_26
                    9264   ; OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.   */
00002F80  2042      9265          move.l    D2,A0
00002F82  1028 0038 9266          move.b    56(A0),D0
00002F86  8139 0080 9267          or.b      D0,_OSRdyGrp.L
00002F8A  024E      
                    9268   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00002F8C  2042      9269          move.l    D2,A0
00002F8E  1028 0036 9270          move.b    54(A0),D0
00002F92  C0BC 0000 9271          and.l     #255,D0
00002F96  00FF      
00002F98  2042      9272          move.l    D2,A0
00002F9A  1228 0037 9273          move.b    55(A0),D1
00002F9E  8333 0800 9274          or.b      D1,0(A3,D0.L)
00002FA2  6000 0032 9275          bra       OSMutexPend_28
                    9276   OSMutexPend_26:
                    9277   ; } else {
                    9278   ; pevent2 = ptcb->OSTCBEventPtr;
00002FA6  2042      9279          move.l    D2,A0
00002FA8  2828 001C 9280          move.l    28(A0),D4
                    9281   ; if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list                   */
00002FAC  4A84      9282          tst.l     D4
00002FAE  6726      9283          beq.s     OSMutexPend_28
                    9284   ; pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
00002FB0  2044      9285          move.l    D4,A0
00002FB2  2242      9286          move.l    D2,A1
00002FB4  1029 0038 9287          move.b    56(A1),D0
00002FB8  8128 0008 9288          or.b      D0,8(A0)
                    9289   ; pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00002FBC  2044      9290          move.l    D4,A0
00002FBE  2242      9291          move.l    D2,A1
00002FC0  1029 0036 9292          move.b    54(A1),D0
00002FC4  C0BC 0000 9293          and.l     #255,D0
00002FC8  00FF      
00002FCA  D1C0      9294          add.l     D0,A0
00002FCC  2242      9295          move.l    D2,A1
00002FCE  1029 0037 9296          move.b    55(A1),D0
00002FD2  8128 000A 9297          or.b      D0,10(A0)
                    9298   OSMutexPend_28:
                    9299   ; }
                    9300   ; }
                    9301   ; OSTCBPrioTbl[pcp] = ptcb;
00002FD6  CEBC 0000 9302          and.l     #255,D7
00002FDA  00FF      
00002FDC  2007      9303          move.l    D7,D0
00002FDE  E588      9304          lsl.l     #2,D0
00002FE0  41F9 0080 9305          lea       _OSTCBPrioTbl.L,A0
00002FE4  0370      
00002FE6  2182 0800 9306          move.l    D2,0(A0,D0.L)
                    9307   OSMutexPend_16:
                    9308   ; }
                    9309   ; }
                    9310   ; }
                    9311   ; OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
00002FEA  2052      9312          move.l    (A2),A0
00002FEC  0028 0010 9313          or.b      #16,50(A0)
00002FF0  0032      
                    9314   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00002FF2  2052      9315          move.l    (A2),A0
00002FF4  4228 0033 9316          clr.b     51(A0)
                    9317   ; OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
00002FF8  2052      9318          move.l    (A2),A0
00002FFA  216E 000C 9319          move.l    12(A6),46(A0)
00002FFE  002E      
                    9320   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
00003000  2F03      9321          move.l    D3,-(A7)
00003002  4EB8 0EFC 9322          jsr       _OS_EventTaskWait
00003006  584F      9323          addq.w    #4,A7
                    9324   ; OS_EXIT_CRITICAL();
00003008  46DF      9325          dc.w      18143
                    9326   ; OS_Sched();                                       /* Find next highest priority task ready         */
0000300A  4EB8 13F8 9327          jsr       _OS_Sched
                    9328   ; OS_ENTER_CRITICAL();
0000300E  40E7      9329          dc.w      16615
00003010  007C      9330          dc.w      124
00003012  0700      9331          dc.w      1792
                    9332   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00003014  2052      9333          move.l    (A2),A0
00003016  1028 0033 9334          move.b    51(A0),D0
0000301A  C0BC 0000 9335          and.l     #255,D0
0000301E  00FF      
00003020  0C80 0000 9336          cmp.l     #1,D0
00003024  0001      
00003026  6720      9337          beq.s     OSMutexPend_34
00003028  6206      9338          bhi.s     OSMutexPend_36
0000302A  4A80      9339          tst.l     D0
0000302C  670C      9340          beq.s     OSMutexPend_32
0000302E  6018      9341          bra.s     OSMutexPend_34
                    9342   OSMutexPend_36:
00003030  0C80 0000 9343          cmp.l     #2,D0
00003034  0002      
00003036  6708      9344          beq.s     OSMutexPend_33
00003038  600E      9345          bra.s     OSMutexPend_34
                    9346   OSMutexPend_32:
                    9347   ; case OS_STAT_PEND_OK:
                    9348   ; *perr = OS_ERR_NONE;
0000303A  2045      9349          move.l    D5,A0
0000303C  4210      9350          clr.b     (A0)
                    9351   ; break;
0000303E  6018      9352          bra.s     OSMutexPend_31
                    9353   OSMutexPend_33:
                    9354   ; case OS_STAT_PEND_ABORT:
                    9355   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
00003040  2045      9356          move.l    D5,A0
00003042  10BC 000E 9357          move.b    #14,(A0)
                    9358   ; break;
00003046  6010      9359          bra.s     OSMutexPend_31
                    9360   OSMutexPend_34:
                    9361   ; case OS_STAT_PEND_TO:
                    9362   ; default:
                    9363   ; OS_EventTaskRemove(OSTCBCur, pevent);
00003048  2F03      9364          move.l    D3,-(A7)
0000304A  2F12      9365          move.l    (A2),-(A7)
0000304C  4EB8 101E 9366          jsr       _OS_EventTaskRemove
00003050  504F      9367          addq.w    #8,A7
                    9368   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
00003052  2045      9369          move.l    D5,A0
00003054  10BC 000A 9370          move.b    #10,(A0)
                    9371   ; break;
                    9372   OSMutexPend_31:
                    9373   ; }
                    9374   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00003058  2052      9375          move.l    (A2),A0
0000305A  4228 0032 9376          clr.b     50(A0)
                    9377   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
0000305E  2052      9378          move.l    (A2),A0
00003060  4228 0033 9379          clr.b     51(A0)
                    9380   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00003064  2052      9381          move.l    (A2),A0
00003066  42A8 001C 9382          clr.l     28(A0)
                    9383   ; #if (OS_EVENT_MULTI_EN > 0u)
                    9384   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
0000306A  2052      9385          move.l    (A2),A0
0000306C  42A8 0020 9386          clr.l     32(A0)
                    9387   ; #endif
                    9388   ; OS_EXIT_CRITICAL();
00003070  46DF      9389          dc.w      18143
                    9390   OSMutexPend_3:
00003072  4CDF 0CFC 9391          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3
00003076  4E5E      9392          unlk      A6
00003078  4E75      9393          rts
                    9394   ; }
                    9395   ; /*$PAGE*/
                    9396   ; /*
                    9397   ; *********************************************************************************************************
                    9398   ; *                                POST TO A MUTUAL EXCLUSION SEMAPHORE
                    9399   ; *
                    9400   ; * Description: This function signals a mutual exclusion semaphore
                    9401   ; *
                    9402   ; * Arguments  : pevent              is a pointer to the event control block associated with the desired
                    9403   ; *                                  mutex.
                    9404   ; *
                    9405   ; * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
                    9406   ; *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
                    9407   ; *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
                    9408   ; *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
                    9409   ; *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
                    9410   ; *              OS_ERR_PCP_LOWER        If the priority of the new task that owns the Mutex is
                    9411   ; *                                      HIGHER (i.e. a lower number) than the PCP.  This error
                    9412   ; *                                      indicates that you did not set the PCP higher (lower
                    9413   ; *                                      number) than ALL the tasks that compete for the Mutex.
                    9414   ; *                                      Unfortunately, this is something that could not be
                    9415   ; *                                      detected when the Mutex is created because we don't know
                    9416   ; *                                      what tasks will be using the Mutex.
                    9417   ; *********************************************************************************************************
                    9418   ; */
                    9419   ; INT8U  OSMutexPost (OS_EVENT *pevent)
                    9420   ; {
                    9421   _OSMutexPost:
0000307A  4E56 0000 9422          link      A6,#0
0000307E  48E7 3820 9423          movem.l   D2/D3/D4/A2,-(A7)
00003082  242E 0008 9424          move.l    8(A6),D2
00003086  45F9 0080 9425          lea       _OSTCBCur.L,A2
0000308A  0360      
                    9426   ; INT8U      pcp;                                   /* Priority ceiling priority                     */
                    9427   ; INT8U      prio;
                    9428   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    9429   ; OS_CPU_SR  cpu_sr = 0u;
                    9430   ; #endif
                    9431   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
0000308C  1039 0080 9432          move.b    _OSIntNesting.L,D0
00003090  0246      
00003092  0C00 0000 9433          cmp.b     #0,D0
00003096  6306      9434          bls.s     OSMutexPost_1
                    9435   ; return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
00003098  7005      9436          moveq     #5,D0
0000309A  6000 00F0 9437          bra       OSMutexPost_3
                    9438   OSMutexPost_1:
                    9439   ; }
                    9440   ; #if OS_ARG_CHK_EN > 0u
                    9441   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    9442   ; return (OS_ERR_PEVENT_NULL);
                    9443   ; }
                    9444   ; #endif
                    9445   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
0000309E  2042      9446          move.l    D2,A0
000030A0  1010      9447          move.b    (A0),D0
000030A2  0C00 0004 9448          cmp.b     #4,D0
000030A6  6706      9449          beq.s     OSMutexPost_4
                    9450   ; return (OS_ERR_EVENT_TYPE);
000030A8  7001      9451          moveq     #1,D0
000030AA  6000 00E0 9452          bra       OSMutexPost_3
                    9453   OSMutexPost_4:
                    9454   ; }
                    9455   ; OS_ENTER_CRITICAL();
000030AE  40E7      9456          dc.w      16615
000030B0  007C      9457          dc.w      124
000030B2  0700      9458          dc.w      1792
                    9459   ; pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex        */
000030B4  2042      9460          move.l    D2,A0
000030B6  3028 0006 9461          move.w    6(A0),D0
000030BA  E048      9462          lsr.w     #8,D0
000030BC  1800      9463          move.b    D0,D4
                    9464   ; prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
000030BE  2042      9465          move.l    D2,A0
000030C0  3028 0006 9466          move.w    6(A0),D0
000030C4  C07C 00FF 9467          and.w     #255,D0
000030C8  1600      9468          move.b    D0,D3
                    9469   ; if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
000030CA  2042      9470          move.l    D2,A0
000030CC  2012      9471          move.l    (A2),D0
000030CE  B0A8 0002 9472          cmp.l     2(A0),D0
000030D2  6708      9473          beq.s     OSMutexPost_6
                    9474   ; OS_EXIT_CRITICAL();
000030D4  46DF      9475          dc.w      18143
                    9476   ; return (OS_ERR_NOT_MUTEX_OWNER);
000030D6  7064      9477          moveq     #100,D0
000030D8  6000 00B2 9478          bra       OSMutexPost_3
                    9479   OSMutexPost_6:
                    9480   ; }
                    9481   ; if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
000030DC  0C04 00FF 9482          cmp.b     #255,D4
000030E0  6732      9483          beq.s     OSMutexPost_8
                    9484   ; if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priority? */
000030E2  2052      9485          move.l    (A2),A0
000030E4  B828 0034 9486          cmp.b     52(A0),D4
000030E8  6612      9487          bne.s     OSMutexPost_10
                    9488   ; OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority          */
000030EA  C6BC 0000 9489          and.l     #255,D3
000030EE  00FF      
000030F0  2F03      9490          move.l    D3,-(A7)
000030F2  2F12      9491          move.l    (A2),-(A7)
000030F4  4EB9 0000 9492          jsr       @ucos_ii_OSMutex_RdyAtPrio
000030F8  3246      
000030FA  504F      9493          addq.w    #8,A7
                    9494   OSMutexPost_10:
                    9495   ; }
                    9496   ; OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                           */
000030FC  C8BC 0000 9497          and.l     #255,D4
00003100  00FF      
00003102  2004      9498          move.l    D4,D0
00003104  E588      9499          lsl.l     #2,D0
00003106  41F9 0080 9500          lea       _OSTCBPrioTbl.L,A0
0000310A  0370      
0000310C  21BC 0000 9501          move.l    #1,0(A0,D0.L)
00003110  0001 0800 
                    9502   OSMutexPost_8:
                    9503   ; }
                    9504   ; if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
00003114  2042      9505          move.l    D2,A0
00003116  1028 0008 9506          move.b    8(A0),D0
0000311A  6700 005E 9507          beq       OSMutexPost_12
                    9508   ; /* Yes, Make HPT waiting for mutex ready         */
                    9509   ; prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
0000311E  42A7      9510          clr.l     -(A7)
00003120  4878 0010 9511          pea       16
00003124  42A7      9512          clr.l     -(A7)
00003126  2F02      9513          move.l    D2,-(A7)
00003128  4EB8 0E18 9514          jsr       _OS_EventTaskRdy
0000312C  DEFC 0010 9515          add.w     #16,A7
00003130  1600      9516          move.b    D0,D3
                    9517   ; pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
00003132  2042      9518          move.l    D2,A0
00003134  0268 FF00 9519          and.w     #65280,6(A0)
00003138  0006      
                    9520   ; pevent->OSEventCnt |= prio;
0000313A  2042      9521          move.l    D2,A0
0000313C  C67C 00FF 9522          and.w     #255,D3
00003140  8768 0006 9523          or.w      D3,6(A0)
                    9524   ; pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
00003144  C6BC 0000 9525          and.l     #255,D3
00003148  00FF      
0000314A  2003      9526          move.l    D3,D0
0000314C  E588      9527          lsl.l     #2,D0
0000314E  41F9 0080 9528          lea       _OSTCBPrioTbl.L,A0
00003152  0370      
00003154  2242      9529          move.l    D2,A1
00003156  2370 0800 9530          move.l    0(A0,D0.L),2(A1)
0000315A  0002      
                    9531   ; if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
0000315C  0C04 00FF 9532          cmp.b     #255,D4
00003160  670E      9533          beq.s     OSMutexPost_14
00003162  B604      9534          cmp.b     D4,D3
00003164  620A      9535          bhi.s     OSMutexPost_14
                    9536   ; (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...       */
                    9537   ; OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
00003166  46DF      9538          dc.w      18143
                    9539   ; OS_Sched();                               /*      Find highest priority task ready to run  */
00003168  4EB8 13F8 9540          jsr       _OS_Sched
                    9541   ; return (OS_ERR_PCP_LOWER);
0000316C  7078      9542          moveq     #120,D0
0000316E  601C      9543          bra.s     OSMutexPost_3
                    9544   OSMutexPost_14:
                    9545   ; } else {
                    9546   ; OS_EXIT_CRITICAL();
00003170  46DF      9547          dc.w      18143
                    9548   ; OS_Sched();                               /*      Find highest priority task ready to run  */
00003172  4EB8 13F8 9549          jsr       _OS_Sched
                    9550   ; return (OS_ERR_NONE);
00003176  4200      9551          clr.b     D0
00003178  6012      9552          bra.s     OSMutexPost_3
                    9553   OSMutexPost_12:
                    9554   ; }
                    9555   ; }
                    9556   ; pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
0000317A  2042      9557          move.l    D2,A0
0000317C  0068 00FF 9558          or.w      #255,6(A0)
00003180  0006      
                    9559   ; pevent->OSEventPtr  = (void *)0;
00003182  2042      9560          move.l    D2,A0
00003184  42A8 0002 9561          clr.l     2(A0)
                    9562   ; OS_EXIT_CRITICAL();
00003188  46DF      9563          dc.w      18143
                    9564   ; return (OS_ERR_NONE);
0000318A  4200      9565          clr.b     D0
                    9566   OSMutexPost_3:
0000318C  4CDF 041C 9567          movem.l   (A7)+,D2/D3/D4/A2
00003190  4E5E      9568          unlk      A6
00003192  4E75      9569          rts
                    9570   ; }
                    9571   ; /*$PAGE*/
                    9572   ; /*
                    9573   ; *********************************************************************************************************
                    9574   ; *                                 QUERY A MUTUAL EXCLUSION SEMAPHORE
                    9575   ; *
                    9576   ; * Description: This function obtains information about a mutex
                    9577   ; *
                    9578   ; * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
                    9579   ; *
                    9580   ; *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
                    9581   ; *
                    9582   ; * Returns    : OS_ERR_NONE          The call was successful and the message was sent
                    9583   ; *              OS_ERR_QUERY_ISR     If you called this function from an ISR
                    9584   ; *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
                    9585   ; *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
                    9586   ; *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
                    9587   ; *********************************************************************************************************
                    9588   ; */
                    9589   ; #if OS_MUTEX_QUERY_EN > 0u
                    9590   ; INT8U  OSMutexQuery (OS_EVENT       *pevent,
                    9591   ; OS_MUTEX_DATA  *p_mutex_data)
                    9592   ; {
                    9593   _OSMutexQuery:
00003194  4E56 FFF8 9594          link      A6,#-8
00003198  48E7 3800 9595          movem.l   D2/D3/D4,-(A7)
0000319C  242E 000C 9596          move.l    12(A6),D2
000031A0  262E 0008 9597          move.l    8(A6),D3
                    9598   ; INT8U       i;
                    9599   ; OS_PRIO    *psrc;
                    9600   ; OS_PRIO    *pdest;
                    9601   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    9602   ; OS_CPU_SR   cpu_sr = 0u;
                    9603   ; #endif
                    9604   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000031A4  1039 0080 9605          move.b    _OSIntNesting.L,D0
000031A8  0246      
000031AA  0C00 0000 9606          cmp.b     #0,D0
000031AE  6306      9607          bls.s     OSMutexQuery_1
                    9608   ; return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
000031B0  7006      9609          moveq     #6,D0
000031B2  6000 008A 9610          bra       OSMutexQuery_3
                    9611   OSMutexQuery_1:
                    9612   ; }
                    9613   ; #if OS_ARG_CHK_EN > 0u
                    9614   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    9615   ; return (OS_ERR_PEVENT_NULL);
                    9616   ; }
                    9617   ; if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
                    9618   ; return (OS_ERR_PDATA_NULL);
                    9619   ; }
                    9620   ; #endif
                    9621   ; if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
000031B6  2043      9622          move.l    D3,A0
000031B8  1010      9623          move.b    (A0),D0
000031BA  0C00 0004 9624          cmp.b     #4,D0
000031BE  6706      9625          beq.s     OSMutexQuery_4
                    9626   ; return (OS_ERR_EVENT_TYPE);
000031C0  7001      9627          moveq     #1,D0
000031C2  6000 007A 9628          bra       OSMutexQuery_3
                    9629   OSMutexQuery_4:
                    9630   ; }
                    9631   ; OS_ENTER_CRITICAL();
000031C6  40E7      9632          dc.w      16615
000031C8  007C      9633          dc.w      124
000031CA  0700      9634          dc.w      1792
                    9635   ; p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
000031CC  2043      9636          move.l    D3,A0
000031CE  3028 0006 9637          move.w    6(A0),D0
000031D2  E048      9638          lsr.w     #8,D0
000031D4  2042      9639          move.l    D2,A0
000031D6  1140 000B 9640          move.b    D0,11(A0)
                    9641   ; p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
000031DA  2043      9642          move.l    D3,A0
000031DC  3028 0006 9643          move.w    6(A0),D0
000031E0  C07C 00FF 9644          and.w     #255,D0
000031E4  2042      9645          move.l    D2,A0
000031E6  1140 000A 9646          move.b    D0,10(A0)
                    9647   ; if (p_mutex_data->OSOwnerPrio == 0xFFu) {
000031EA  2042      9648          move.l    D2,A0
000031EC  1028 000A 9649          move.b    10(A0),D0
000031F0  0C00 00FF 9650          cmp.b     #255,D0
000031F4  660A      9651          bne.s     OSMutexQuery_6
                    9652   ; p_mutex_data->OSValue = OS_TRUE;
000031F6  2042      9653          move.l    D2,A0
000031F8  117C 0001 9654          move.b    #1,9(A0)
000031FC  0009      
000031FE  6006      9655          bra.s     OSMutexQuery_7
                    9656   OSMutexQuery_6:
                    9657   ; } else {
                    9658   ; p_mutex_data->OSValue = OS_FALSE;
00003200  2042      9659          move.l    D2,A0
00003202  4228 0009 9660          clr.b     9(A0)
                    9661   OSMutexQuery_7:
                    9662   ; }
                    9663   ; p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
00003206  2043      9664          move.l    D3,A0
00003208  2242      9665          move.l    D2,A1
0000320A  1368 0008 9666          move.b    8(A0),8(A1)
0000320E  0008      
                    9667   ; psrc                      = &pevent->OSEventTbl[0];
00003210  700A      9668          moveq     #10,D0
00003212  D083      9669          add.l     D3,D0
00003214  2D40 FFF8 9670          move.l    D0,-8(A6)
                    9671   ; pdest                     = &p_mutex_data->OSEventTbl[0];
00003218  2D42 FFFC 9672          move.l    D2,-4(A6)
                    9673   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
0000321C  4204      9674          clr.b     D4
                    9675   OSMutexQuery_8:
0000321E  0C04 0008 9676          cmp.b     #8,D4
00003222  6416      9677          bhs.s     OSMutexQuery_10
                    9678   ; *pdest++ = *psrc++;
00003224  206E FFF8 9679          move.l    -8(A6),A0
00003228  52AE FFF8 9680          addq.l    #1,-8(A6)
0000322C  226E FFFC 9681          move.l    -4(A6),A1
00003230  52AE FFFC 9682          addq.l    #1,-4(A6)
00003234  1290      9683          move.b    (A0),(A1)
00003236  5204      9684          addq.b    #1,D4
00003238  60E4      9685          bra       OSMutexQuery_8
                    9686   OSMutexQuery_10:
                    9687   ; }
                    9688   ; OS_EXIT_CRITICAL();
0000323A  46DF      9689          dc.w      18143
                    9690   ; return (OS_ERR_NONE);
0000323C  4200      9691          clr.b     D0
                    9692   OSMutexQuery_3:
0000323E  4CDF 001C 9693          movem.l   (A7)+,D2/D3/D4
00003242  4E5E      9694          unlk      A6
00003244  4E75      9695          rts
                    9696   ; }
                    9697   ; #endif                                                     /* OS_MUTEX_QUERY_EN                        */
                    9698   ; /*$PAGE*/
                    9699   ; /*
                    9700   ; *********************************************************************************************************
                    9701   ; *                            RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
                    9702   ; *
                    9703   ; * Description: This function makes a task ready at the specified priority
                    9704   ; *
                    9705   ; * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
                    9706   ; *
                    9707   ; *              prio            is the desired priority
                    9708   ; *
                    9709   ; * Returns    : none
                    9710   ; *********************************************************************************************************
                    9711   ; */
                    9712   ; static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
                    9713   ; INT8U    prio)
                    9714   ; {
                    9715   @ucos_ii_OSMutex_RdyAtPrio:
00003246  4E56 0000 9716          link      A6,#0
0000324A  48E7 3820 9717          movem.l   D2/D3/D4/A2,-(A7)
0000324E  242E 0008 9718          move.l    8(A6),D2
00003252  162E 000F 9719          move.b    15(A6),D3
00003256  C6BC 0000 9720          and.l     #255,D3
0000325A  00FF      
0000325C  45F9 0080 9721          lea       _OSRdyTbl.L,A2
00003260  0250      
                    9722   ; INT8U  y;
                    9723   ; y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'    */
00003262  2042      9724          move.l    D2,A0
00003264  1828 0036 9725          move.b    54(A0),D4
                    9726   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
00003268  C8BC 0000 9727          and.l     #255,D4
0000326C  00FF      
0000326E  2042      9728          move.l    D2,A0
00003270  1028 0037 9729          move.b    55(A0),D0
00003274  4600      9730          not.b     D0
00003276  C132 4800 9731          and.b     D0,0(A2,D4.L)
                    9732   ; if (OSRdyTbl[y] == 0u) {
0000327A  C8BC 0000 9733          and.l     #255,D4
0000327E  00FF      
00003280  1032 4800 9734          move.b    0(A2,D4.L),D0
00003284  660E      9735          bne.s     @ucos_ii_OSMutex_RdyAtPrio_1
                    9736   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00003286  2042      9737          move.l    D2,A0
00003288  1028 0038 9738          move.b    56(A0),D0
0000328C  4600      9739          not.b     D0
0000328E  C139 0080 9740          and.b     D0,_OSRdyGrp.L
00003292  024E      
                    9741   @ucos_ii_OSMutex_RdyAtPrio_1:
                    9742   ; }
                    9743   ; ptcb->OSTCBPrio         = prio;
00003294  2042      9744          move.l    D2,A0
00003296  1143 0034 9745          move.b    D3,52(A0)
                    9746   ; OSPrioCur               = prio;                        /* The current task is now at this priority */
0000329A  13C3 0080 9747          move.b    D3,_OSPrioCur.L
0000329E  024A      
                    9748   ; #if OS_LOWEST_PRIO <= 63u
                    9749   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
000032A0  1003      9750          move.b    D3,D0
000032A2  E608      9751          lsr.b     #3,D0
000032A4  C03C 0007 9752          and.b     #7,D0
000032A8  2042      9753          move.l    D2,A0
000032AA  1140 0036 9754          move.b    D0,54(A0)
                    9755   ; ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
000032AE  1003      9756          move.b    D3,D0
000032B0  C03C 0007 9757          and.b     #7,D0
000032B4  2042      9758          move.l    D2,A0
000032B6  1140 0035 9759          move.b    D0,53(A0)
                    9760   ; #else
                    9761   ; ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
                    9762   ; ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
                    9763   ; #endif
                    9764   ; ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
000032BA  7001      9765          moveq     #1,D0
000032BC  2042      9766          move.l    D2,A0
000032BE  1228 0036 9767          move.b    54(A0),D1
000032C2  C2BC 0000 9768          and.l     #255,D1
000032C6  00FF      
000032C8  E3A8      9769          lsl.l     D1,D0
000032CA  2042      9770          move.l    D2,A0
000032CC  1140 0038 9771          move.b    D0,56(A0)
                    9772   ; ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
000032D0  7001      9773          moveq     #1,D0
000032D2  2042      9774          move.l    D2,A0
000032D4  1228 0035 9775          move.b    53(A0),D1
000032D8  C2BC 0000 9776          and.l     #255,D1
000032DC  00FF      
000032DE  E3A8      9777          lsl.l     D1,D0
000032E0  2042      9778          move.l    D2,A0
000032E2  1140 0037 9779          move.b    D0,55(A0)
                    9780   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
000032E6  2042      9781          move.l    D2,A0
000032E8  1028 0038 9782          move.b    56(A0),D0
000032EC  8139 0080 9783          or.b      D0,_OSRdyGrp.L
000032F0  024E      
                    9784   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
000032F2  2042      9785          move.l    D2,A0
000032F4  1028 0036 9786          move.b    54(A0),D0
000032F8  C0BC 0000 9787          and.l     #255,D0
000032FC  00FF      
000032FE  2042      9788          move.l    D2,A0
00003300  1228 0037 9789          move.b    55(A0),D1
00003304  8332 0800 9790          or.b      D1,0(A2,D0.L)
                    9791   ; OSTCBPrioTbl[prio]      = ptcb;
00003308  C6BC 0000 9792          and.l     #255,D3
0000330C  00FF      
0000330E  2003      9793          move.l    D3,D0
00003310  E588      9794          lsl.l     #2,D0
00003312  41F9 0080 9795          lea       _OSTCBPrioTbl.L,A0
00003316  0370      
00003318  2182 0800 9796          move.l    D2,0(A0,D0.L)
0000331C  4CDF 041C 9797          movem.l   (A7)+,D2/D3/D4/A2
00003320  4E5E      9798          unlk      A6
00003322  4E75      9799          rts
                    9800   ; /*
                    9801   ; *********************************************************************************************************
                    9802   ; *                                                uC/OS-II
                    9803   ; *                                          The Real-Time Kernel
                    9804   ; *                                        MESSAGE QUEUE MANAGEMENT
                    9805   ; *
                    9806   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    9807   ; *                                           All Rights Reserved
                    9808   ; *
                    9809   ; * File    : OS_Q.C
                    9810   ; * By      : Jean J. Labrosse
                    9811   ; * Version : V2.92.07
                    9812   ; *
                    9813   ; * LICENSING TERMS:
                    9814   ; * ---------------
                    9815   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    9816   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    9817   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    9818   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    9819   ; * licensing fee.
                    9820   ; *********************************************************************************************************
                    9821   ; */
                    9822   ; #define  MICRIUM_SOURCE
                    9823   ; #ifndef  OS_MASTER_FILE
                    9824   ; #include <ucos_ii.h>
                    9825   ; #endif
                    9826   ; #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
                    9827   ; /*
                    9828   ; *********************************************************************************************************
                    9829   ; *                                      ACCEPT MESSAGE FROM QUEUE
                    9830   ; *
                    9831   ; * Description: This function checks the queue to see if a message is available.  Unlike OSQPend(),
                    9832   ; *              OSQAccept() does not suspend the calling task if a message is not available.
                    9833   ; *
                    9834   ; * Arguments  : pevent        is a pointer to the event control block
                    9835   ; *
                    9836   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    9837   ; *                            messages are:
                    9838   ; *
                    9839   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    9840   ; *                                                message.
                    9841   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    9842   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    9843   ; *                            OS_ERR_Q_EMPTY      The queue did not contain any messages
                    9844   ; *
                    9845   ; * Returns    : != (void *)0  is the message in the queue if one is available.  The message is removed
                    9846   ; *                            from the so the next time OSQAccept() is called, the queue will contain
                    9847   ; *                            one less entry.
                    9848   ; *              == (void *)0  if you received a NULL pointer message
                    9849   ; *                            if the queue is empty or,
                    9850   ; *                            if 'pevent' is a NULL pointer or,
                    9851   ; *                            if you passed an invalid event type
                    9852   ; *
                    9853   ; * Note(s)    : As of V2.60, you can now pass NULL pointers through queues.  Because of this, the argument
                    9854   ; *              'perr' has been added to the API to tell you about the outcome of the call.
                    9855   ; *********************************************************************************************************
                    9856   ; */
                    9857   ; #if OS_Q_ACCEPT_EN > 0u
                    9858   ; void  *OSQAccept (OS_EVENT  *pevent,
                    9859   ; INT8U     *perr)
                    9860   ; {
                    9861   _OSQAccept:
00003324  4E56 0000 9862          link      A6,#0
00003328  48E7 3800 9863          movem.l   D2/D3/D4,-(A7)
0000332C  282E 000C 9864          move.l    12(A6),D4
                    9865   ; void      *pmsg;
                    9866   ; OS_Q      *pq;
                    9867   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    9868   ; OS_CPU_SR  cpu_sr = 0u;
                    9869   ; #endif
                    9870   ; #ifdef OS_SAFETY_CRITICAL
                    9871   ; if (perr == (INT8U *)0) {
                    9872   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9873   ; return ((void *)0);
                    9874   ; }
                    9875   ; #endif
                    9876   ; #if OS_ARG_CHK_EN > 0u
                    9877   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    9878   ; *perr = OS_ERR_PEVENT_NULL;
                    9879   ; return ((void *)0);
                    9880   ; }
                    9881   ; #endif
                    9882   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00003330  206E 0008 9883          move.l    8(A6),A0
00003334  1010      9884          move.b    (A0),D0
00003336  0C00 0002 9885          cmp.b     #2,D0
0000333A  670C      9886          beq.s     OSQAccept_1
                    9887   ; *perr = OS_ERR_EVENT_TYPE;
0000333C  2044      9888          move.l    D4,A0
0000333E  10BC 0001 9889          move.b    #1,(A0)
                    9890   ; return ((void *)0);
00003342  4280      9891          clr.l     D0
00003344  6000 0064 9892          bra       OSQAccept_3
                    9893   OSQAccept_1:
                    9894   ; }
                    9895   ; OS_ENTER_CRITICAL();
00003348  40E7      9896          dc.w      16615
0000334A  007C      9897          dc.w      124
0000334C  0700      9898          dc.w      1792
                    9899   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
0000334E  206E 0008 9900          move.l    8(A6),A0
00003352  2428 0002 9901          move.l    2(A0),D2
                    9902   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
00003356  2042      9903          move.l    D2,A0
00003358  3028 0016 9904          move.w    22(A0),D0
0000335C  0C40 0000 9905          cmp.w     #0,D0
00003360  6300 003C 9906          bls       OSQAccept_4
                    9907   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
00003364  2002      9908          move.l    D2,D0
00003366  0680 0000 9909          add.l     #16,D0
0000336A  0010      
0000336C  2040      9910          move.l    D0,A0
0000336E  2250      9911          move.l    (A0),A1
00003370  5890      9912          addq.l    #4,(A0)
00003372  2611      9913          move.l    (A1),D3
                    9914   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
00003374  2002      9915          move.l    D2,D0
00003376  0680 0000 9916          add.l     #22,D0
0000337A  0016      
0000337C  2040      9917          move.l    D0,A0
0000337E  5350      9918          subq.w    #1,(A0)
                    9919   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00003380  2042      9920          move.l    D2,A0
00003382  2242      9921          move.l    D2,A1
00003384  2028 0010 9922          move.l    16(A0),D0
00003388  B0A9 0008 9923          cmp.l     8(A1),D0
0000338C  660A      9924          bne.s     OSQAccept_6
                    9925   ; pq->OSQOut = pq->OSQStart;
0000338E  2042      9926          move.l    D2,A0
00003390  2242      9927          move.l    D2,A1
00003392  2368 0004 9928          move.l    4(A0),16(A1)
00003396  0010      
                    9929   OSQAccept_6:
                    9930   ; }
                    9931   ; *perr = OS_ERR_NONE;
00003398  2044      9932          move.l    D4,A0
0000339A  4210      9933          clr.b     (A0)
0000339C  6008      9934          bra.s     OSQAccept_5
                    9935   OSQAccept_4:
                    9936   ; } else {
                    9937   ; *perr = OS_ERR_Q_EMPTY;
0000339E  2044      9938          move.l    D4,A0
000033A0  10BC 001F 9939          move.b    #31,(A0)
                    9940   ; pmsg  = (void *)0;                       /* Queue is empty                                     */
000033A4  4283      9941          clr.l     D3
                    9942   OSQAccept_5:
                    9943   ; }
                    9944   ; OS_EXIT_CRITICAL();
000033A6  46DF      9945          dc.w      18143
                    9946   ; return (pmsg);                               /* Return message received (or NULL)                  */
000033A8  2003      9947          move.l    D3,D0
                    9948   OSQAccept_3:
000033AA  4CDF 001C 9949          movem.l   (A7)+,D2/D3/D4
000033AE  4E5E      9950          unlk      A6
000033B0  4E75      9951          rts
                    9952   ; }
                    9953   ; #endif
                    9954   ; /*$PAGE*/
                    9955   ; /*
                    9956   ; *********************************************************************************************************
                    9957   ; *                                       CREATE A MESSAGE QUEUE
                    9958   ; *
                    9959   ; * Description: This function creates a message queue if free event control blocks are available.
                    9960   ; *
                    9961   ; * Arguments  : start         is a pointer to the base address of the message queue storage area.  The
                    9962   ; *                            storage area MUST be declared as an array of pointers to 'void' as follows
                    9963   ; *
                    9964   ; *                            void *MessageStorage[size]
                    9965   ; *
                    9966   ; *              size          is the number of elements in the storage area
                    9967   ; *
                    9968   ; * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
                    9969   ; *                                created queue
                    9970   ; *              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
                    9971   ; *********************************************************************************************************
                    9972   ; */
                    9973   ; OS_EVENT  *OSQCreate (void    **start,
                    9974   ; INT16U    size)
                    9975   ; {
                    9976   _OSQCreate:
000033B2  4E56 0000 9977          link      A6,#0
000033B6  48E7 3830 9978          movem.l   D2/D3/D4/A2/A3,-(A7)
000033BA  45F9 0080 9979          lea       _OSEventFreeList.L,A2
000033BE  001A      
000033C0  282E 0008 9980          move.l    8(A6),D4
000033C4  47F9 0080 9981          lea       _OSQFreeList.L,A3
000033C8  0C50      
                    9982   ; OS_EVENT  *pevent;
                    9983   ; OS_Q      *pq;
                    9984   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    9985   ; OS_CPU_SR  cpu_sr = 0u;
                    9986   ; #endif
                    9987   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    9988   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    9989   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    9990   ; return ((OS_EVENT *)0);
                    9991   ; }
                    9992   ; #endif
                    9993   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000033CA  1039 0080 9994          move.b    _OSIntNesting.L,D0
000033CE  0246      
000033D0  0C00 0000 9995          cmp.b     #0,D0
000033D4  6306      9996          bls.s     OSQCreate_1
                    9997   ; return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
000033D6  4280      9998          clr.l     D0
000033D8  6000 009C 9999          bra       OSQCreate_3
                    10000   OSQCreate_1:
                    10001   ; }
                    10002   ; OS_ENTER_CRITICAL();
000033DC  40E7      10003          dc.w      16615
000033DE  007C      10004          dc.w      124
000033E0  0700      10005          dc.w      1792
                    10006   ; pevent = OSEventFreeList;                    /* Get next free event control block                  */
000033E2  2412      10007          move.l    (A2),D2
                    10008   ; if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
000033E4  2012      10009          move.l    (A2),D0
000033E6  6706      10010          beq.s     OSQCreate_4
                    10011   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
000033E8  2052      10012          move.l    (A2),A0
000033EA  24A8 0002 10013          move.l    2(A0),(A2)
                    10014   OSQCreate_4:
                    10015   ; }
                    10016   ; OS_EXIT_CRITICAL();
000033EE  46DF      10017          dc.w      18143
                    10018   ; if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
000033F0  4A82      10019          tst.l     D2
000033F2  6700 0080 10020          beq       OSQCreate_9
                    10021   ; OS_ENTER_CRITICAL();
000033F6  40E7      10022          dc.w      16615
000033F8  007C      10023          dc.w      124
000033FA  0700      10024          dc.w      1792
                    10025   ; pq = OSQFreeList;                        /* Get a free queue control block                     */
000033FC  2613      10026          move.l    (A3),D3
                    10027   ; if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
000033FE  4A83      10028          tst.l     D3
00003400  6700 0066 10029          beq       OSQCreate_8
                    10030   ; OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
00003404  2053      10031          move.l    (A3),A0
00003406  2690      10032          move.l    (A0),(A3)
                    10033   ; OS_EXIT_CRITICAL();
00003408  46DF      10034          dc.w      18143
                    10035   ; pq->OSQStart           = start;               /*      Initialize the queue                 */
0000340A  2043      10036          move.l    D3,A0
0000340C  2144 0004 10037          move.l    D4,4(A0)
                    10038   ; pq->OSQEnd             = &start[size];
00003410  2004      10039          move.l    D4,D0
00003412  322E 000E 10040          move.w    14(A6),D1
00003416  C2BC 0000 10041          and.l     #65535,D1
0000341A  FFFF      
0000341C  E589      10042          lsl.l     #2,D1
0000341E  D081      10043          add.l     D1,D0
00003420  2043      10044          move.l    D3,A0
00003422  2140 0008 10045          move.l    D0,8(A0)
                    10046   ; pq->OSQIn              = start;
00003426  2043      10047          move.l    D3,A0
00003428  2144 000C 10048          move.l    D4,12(A0)
                    10049   ; pq->OSQOut             = start;
0000342C  2043      10050          move.l    D3,A0
0000342E  2144 0010 10051          move.l    D4,16(A0)
                    10052   ; pq->OSQSize            = size;
00003432  2043      10053          move.l    D3,A0
00003434  316E 000E 10054          move.w    14(A6),20(A0)
00003438  0014      
                    10055   ; pq->OSQEntries         = 0u;
0000343A  2043      10056          move.l    D3,A0
0000343C  4268 0016 10057          clr.w     22(A0)
                    10058   ; pevent->OSEventType    = OS_EVENT_TYPE_Q;
00003440  2042      10059          move.l    D2,A0
00003442  10BC 0002 10060          move.b    #2,(A0)
                    10061   ; pevent->OSEventCnt     = 0u;
00003446  2042      10062          move.l    D2,A0
00003448  4268 0006 10063          clr.w     6(A0)
                    10064   ; pevent->OSEventPtr     = pq;
0000344C  2042      10065          move.l    D2,A0
0000344E  2143 0002 10066          move.l    D3,2(A0)
                    10067   ; #if OS_EVENT_NAME_EN > 0u
                    10068   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003452  41F9 0000 10069          lea       @ucos_ii_1.L,A0
00003456  5A8E      
00003458  2242      10070          move.l    D2,A1
0000345A  2348 0012 10071          move.l    A0,18(A1)
                    10072   ; #endif
                    10073   ; OS_EventWaitListInit(pevent);                 /*      Initialize the wait list             */
0000345E  2F02      10074          move.l    D2,-(A7)
00003460  4EB8 10E0 10075          jsr       _OS_EventWaitListInit
00003464  584F      10076          addq.w    #4,A7
00003466  600C      10077          bra.s     OSQCreate_9
                    10078   OSQCreate_8:
                    10079   ; } else {
                    10080   ; pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
00003468  2042      10081          move.l    D2,A0
0000346A  2152 0002 10082          move.l    (A2),2(A0)
                    10083   ; OSEventFreeList    = pevent;
0000346E  2482      10084          move.l    D2,(A2)
                    10085   ; OS_EXIT_CRITICAL();
00003470  46DF      10086          dc.w      18143
                    10087   ; pevent = (OS_EVENT *)0;
00003472  4282      10088          clr.l     D2
                    10089   OSQCreate_9:
                    10090   ; }
                    10091   ; }
                    10092   ; return (pevent);
00003474  2002      10093          move.l    D2,D0
                    10094   OSQCreate_3:
00003476  4CDF 0C1C 10095          movem.l   (A7)+,D2/D3/D4/A2/A3
0000347A  4E5E      10096          unlk      A6
0000347C  4E75      10097          rts
                    10098   ; }
                    10099   ; /*$PAGE*/
                    10100   ; /*
                    10101   ; *********************************************************************************************************
                    10102   ; *                                       DELETE A MESSAGE QUEUE
                    10103   ; *
                    10104   ; * Description: This function deletes a message queue and readies all tasks pending on the queue.
                    10105   ; *
                    10106   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    10107   ; *                            queue.
                    10108   ; *
                    10109   ; *              opt           determines delete options as follows:
                    10110   ; *                            opt == OS_DEL_NO_PEND   Delete the queue ONLY if no task pending
                    10111   ; *                            opt == OS_DEL_ALWAYS    Deletes the queue even if tasks are waiting.
                    10112   ; *                                                    In this case, all the tasks pending will be readied.
                    10113   ; *
                    10114   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    10115   ; *                            OS_ERR_NONE             The call was successful and the queue was deleted
                    10116   ; *                            OS_ERR_DEL_ISR          If you tried to delete the queue from an ISR
                    10117   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    10118   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the queue
                    10119   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a queue
                    10120   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    10121   ; *
                    10122   ; * Returns    : pevent        upon error
                    10123   ; *              (OS_EVENT *)0 if the queue was successfully deleted.
                    10124   ; *
                    10125   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    10126   ; *                 the queue MUST check the return code of OSQPend().
                    10127   ; *              2) OSQAccept() callers will not know that the intended queue has been deleted unless
                    10128   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    10129   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    10130   ; *                 time is directly proportional to the number of tasks waiting on the queue.
                    10131   ; *              4) Because ALL tasks pending on the queue will be readied, you MUST be careful in
                    10132   ; *                 applications where the queue is used for mutual exclusion because the resource(s)
                    10133   ; *                 will no longer be guarded by the queue.
                    10134   ; *              5) If the storage for the message queue was allocated dynamically (i.e. using a malloc()
                    10135   ; *                 type call) then your application MUST release the memory storage by call the counterpart
                    10136   ; *                 call of the dynamic allocation scheme used.  If the queue storage was created statically
                    10137   ; *                 then, the storage can be reused.
                    10138   ; *              6) All tasks that were waiting for the queue will be readied and returned an 
                    10139   ; *                 OS_ERR_PEND_ABORT if OSQDel() was called with OS_DEL_ALWAYS
                    10140   ; *********************************************************************************************************
                    10141   ; */
                    10142   ; #if OS_Q_DEL_EN > 0u
                    10143   ; OS_EVENT  *OSQDel (OS_EVENT  *pevent,
                    10144   ; INT8U      opt,
                    10145   ; INT8U     *perr)
                    10146   ; {
                    10147   _OSQDel:
0000347E  4E56 0000 10148          link      A6,#0
00003482  48E7 3E30 10149          movem.l   D2/D3/D4/D5/D6/A2/A3,-(A7)
00003486  242E 0008 10150          move.l    8(A6),D2
0000348A  282E 0010 10151          move.l    16(A6),D4
0000348E  45F9 0080 10152          lea       _OSEventFreeList.L,A2
00003492  001A      
00003494  47F9 0080 10153          lea       _OSQFreeList.L,A3
00003498  0C50      
                    10154   ; BOOLEAN    tasks_waiting;
                    10155   ; OS_EVENT  *pevent_return;
                    10156   ; OS_Q      *pq;
                    10157   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10158   ; OS_CPU_SR  cpu_sr = 0u;
                    10159   ; #endif
                    10160   ; #ifdef OS_SAFETY_CRITICAL
                    10161   ; if (perr == (INT8U *)0) {
                    10162   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10163   ; return ((OS_EVENT *)0);
                    10164   ; }
                    10165   ; #endif
                    10166   ; #if OS_ARG_CHK_EN > 0u
                    10167   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10168   ; *perr = OS_ERR_PEVENT_NULL;
                    10169   ; return (pevent);
                    10170   ; }
                    10171   ; #endif
                    10172   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
0000349A  2042      10173          move.l    D2,A0
0000349C  1010      10174          move.b    (A0),D0
0000349E  0C00 0002 10175          cmp.b     #2,D0
000034A2  670C      10176          beq.s     OSQDel_1
                    10177   ; *perr = OS_ERR_EVENT_TYPE;
000034A4  2044      10178          move.l    D4,A0
000034A6  10BC 0001 10179          move.b    #1,(A0)
                    10180   ; return (pevent);
000034AA  2002      10181          move.l    D2,D0
000034AC  6000 0104 10182          bra       OSQDel_3
                    10183   OSQDel_1:
                    10184   ; }
                    10185   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000034B0  1039 0080 10186          move.b    _OSIntNesting.L,D0
000034B4  0246      
000034B6  0C00 0000 10187          cmp.b     #0,D0
000034BA  630C      10188          bls.s     OSQDel_4
                    10189   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
000034BC  2044      10190          move.l    D4,A0
000034BE  10BC 000F 10191          move.b    #15,(A0)
                    10192   ; return (pevent);
000034C2  2002      10193          move.l    D2,D0
000034C4  6000 00EC 10194          bra       OSQDel_3
                    10195   OSQDel_4:
                    10196   ; }
                    10197   ; OS_ENTER_CRITICAL();
000034C8  40E7      10198          dc.w      16615
000034CA  007C      10199          dc.w      124
000034CC  0700      10200          dc.w      1792
                    10201   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on queue        */
000034CE  2042      10202          move.l    D2,A0
000034D0  1028 0008 10203          move.b    8(A0),D0
000034D4  6704      10204          beq.s     OSQDel_6
                    10205   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
000034D6  7C01      10206          moveq     #1,D6
000034D8  6002      10207          bra.s     OSQDel_7
                    10208   OSQDel_6:
                    10209   ; } else {
                    10210   ; tasks_waiting = OS_FALSE;                          /* No                                       */
000034DA  4206      10211          clr.b     D6
                    10212   OSQDel_7:
                    10213   ; }
                    10214   ; switch (opt) {
000034DC  102E 000F 10215          move.b    15(A6),D0
000034E0  C0BC 0000 10216          and.l     #255,D0
000034E4  00FF      
000034E6  0C80 0000 10217          cmp.l     #1,D0
000034EA  0001      
000034EC  6700 0056 10218          beq       OSQDel_11
000034F0  6200 00B4 10219          bhi       OSQDel_8
000034F4  4A80      10220          tst.l     D0
000034F6  6704      10221          beq.s     OSQDel_10
000034F8  6000 00AC 10222          bra       OSQDel_8
                    10223   OSQDel_10:
                    10224   ; case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
                    10225   ; if (tasks_waiting == OS_FALSE) {
000034FC  4A06      10226          tst.b     D6
000034FE  6600 0036 10227          bne       OSQDel_13
                    10228   ; #if OS_EVENT_NAME_EN > 0u
                    10229   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003502  41F9 0000 10230          lea       @ucos_ii_1.L,A0
00003506  5A8E      
00003508  2242      10231          move.l    D2,A1
0000350A  2348 0012 10232          move.l    A0,18(A1)
                    10233   ; #endif
                    10234   ; pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
0000350E  2042      10235          move.l    D2,A0
00003510  2628 0002 10236          move.l    2(A0),D3
                    10237   ; pq->OSQPtr             = OSQFreeList;
00003514  2043      10238          move.l    D3,A0
00003516  2093      10239          move.l    (A3),(A0)
                    10240   ; OSQFreeList            = pq;
00003518  2683      10241          move.l    D3,(A3)
                    10242   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
0000351A  2042      10243          move.l    D2,A0
0000351C  4210      10244          clr.b     (A0)
                    10245   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
0000351E  2042      10246          move.l    D2,A0
00003520  2152 0002 10247          move.l    (A2),2(A0)
                    10248   ; pevent->OSEventCnt     = 0u;
00003524  2042      10249          move.l    D2,A0
00003526  4268 0006 10250          clr.w     6(A0)
                    10251   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
0000352A  2482      10252          move.l    D2,(A2)
                    10253   ; OS_EXIT_CRITICAL();
0000352C  46DF      10254          dc.w      18143
                    10255   ; *perr                  = OS_ERR_NONE;
0000352E  2044      10256          move.l    D4,A0
00003530  4210      10257          clr.b     (A0)
                    10258   ; pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
00003532  4285      10259          clr.l     D5
00003534  600A      10260          bra.s     OSQDel_14
                    10261   OSQDel_13:
                    10262   ; } else {
                    10263   ; OS_EXIT_CRITICAL();
00003536  46DF      10264          dc.w      18143
                    10265   ; *perr                  = OS_ERR_TASK_WAITING;
00003538  2044      10266          move.l    D4,A0
0000353A  10BC 0049 10267          move.b    #73,(A0)
                    10268   ; pevent_return          = pevent;
0000353E  2A02      10269          move.l    D2,D5
                    10270   OSQDel_14:
                    10271   ; }
                    10272   ; break;
00003540  6000 006E 10273          bra       OSQDel_9
                    10274   OSQDel_11:
                    10275   ; case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
                    10276   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for queue        */
                    10277   OSQDel_15:
00003544  2042      10278          move.l    D2,A0
00003546  1028 0008 10279          move.b    8(A0),D0
0000354A  671C      10280          beq.s     OSQDel_17
                    10281   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
0000354C  4878 0002 10282          pea       2
00003550  4878 0004 10283          pea       4
00003554  42A7      10284          clr.l     -(A7)
00003556  2F02      10285          move.l    D2,-(A7)
00003558  4EB8 0E18 10286          jsr       _OS_EventTaskRdy
0000355C  DEFC 0010 10287          add.w     #16,A7
00003560  C0BC 0000 10288          and.l     #255,D0
00003564  00FF      
00003566  60DC      10289          bra       OSQDel_15
                    10290   OSQDel_17:
                    10291   ; }
                    10292   ; #if OS_EVENT_NAME_EN > 0u
                    10293   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003568  41F9 0000 10294          lea       @ucos_ii_1.L,A0
0000356C  5A8E      
0000356E  2242      10295          move.l    D2,A1
00003570  2348 0012 10296          move.l    A0,18(A1)
                    10297   ; #endif
                    10298   ; pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
00003574  2042      10299          move.l    D2,A0
00003576  2628 0002 10300          move.l    2(A0),D3
                    10301   ; pq->OSQPtr             = OSQFreeList;
0000357A  2043      10302          move.l    D3,A0
0000357C  2093      10303          move.l    (A3),(A0)
                    10304   ; OSQFreeList            = pq;
0000357E  2683      10305          move.l    D3,(A3)
                    10306   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003580  2042      10307          move.l    D2,A0
00003582  4210      10308          clr.b     (A0)
                    10309   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00003584  2042      10310          move.l    D2,A0
00003586  2152 0002 10311          move.l    (A2),2(A0)
                    10312   ; pevent->OSEventCnt     = 0u;
0000358A  2042      10313          move.l    D2,A0
0000358C  4268 0006 10314          clr.w     6(A0)
                    10315   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00003590  2482      10316          move.l    D2,(A2)
                    10317   ; OS_EXIT_CRITICAL();
00003592  46DF      10318          dc.w      18143
                    10319   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00003594  0C06 0001 10320          cmp.b     #1,D6
00003598  6604      10321          bne.s     OSQDel_18
                    10322   ; OS_Sched();                               /* Find highest priority task ready to run  */
0000359A  4EB8 13F8 10323          jsr       _OS_Sched
                    10324   OSQDel_18:
                    10325   ; }
                    10326   ; *perr                  = OS_ERR_NONE;
0000359E  2044      10327          move.l    D4,A0
000035A0  4210      10328          clr.b     (A0)
                    10329   ; pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
000035A2  4285      10330          clr.l     D5
                    10331   ; break;
000035A4  600A      10332          bra.s     OSQDel_9
                    10333   OSQDel_8:
                    10334   ; default:
                    10335   ; OS_EXIT_CRITICAL();
000035A6  46DF      10336          dc.w      18143
                    10337   ; *perr                  = OS_ERR_INVALID_OPT;
000035A8  2044      10338          move.l    D4,A0
000035AA  10BC 0007 10339          move.b    #7,(A0)
                    10340   ; pevent_return          = pevent;
000035AE  2A02      10341          move.l    D2,D5
                    10342   ; break;
                    10343   OSQDel_9:
                    10344   ; }
                    10345   ; return (pevent_return);
000035B0  2005      10346          move.l    D5,D0
                    10347   OSQDel_3:
000035B2  4CDF 0C7C 10348          movem.l   (A7)+,D2/D3/D4/D5/D6/A2/A3
000035B6  4E5E      10349          unlk      A6
000035B8  4E75      10350          rts
                    10351   ; }
                    10352   ; #endif
                    10353   ; /*$PAGE*/
                    10354   ; /*
                    10355   ; *********************************************************************************************************
                    10356   ; *                                             FLUSH QUEUE
                    10357   ; *
                    10358   ; * Description : This function is used to flush the contents of the message queue.
                    10359   ; *
                    10360   ; * Arguments   : none
                    10361   ; *
                    10362   ; * Returns     : OS_ERR_NONE         upon success
                    10363   ; *               OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue
                    10364   ; *               OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10365   ; *
                    10366   ; * WARNING     : You should use this function with great care because, when to flush the queue, you LOOSE
                    10367   ; *               the references to what the queue entries are pointing to and thus, you could cause
                    10368   ; *               'memory leaks'.  In other words, the data you are pointing to that's being referenced
                    10369   ; *               by the queue entries should, most likely, need to be de-allocated (i.e. freed).
                    10370   ; *********************************************************************************************************
                    10371   ; */
                    10372   ; #if OS_Q_FLUSH_EN > 0u
                    10373   ; INT8U  OSQFlush (OS_EVENT *pevent)
                    10374   ; {
                    10375   _OSQFlush:
000035BA  4E56 0000 10376          link      A6,#0
000035BE  2F02      10377          move.l    D2,-(A7)
                    10378   ; OS_Q      *pq;
                    10379   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    10380   ; OS_CPU_SR  cpu_sr = 0u;
                    10381   ; #endif
                    10382   ; #if OS_ARG_CHK_EN > 0u
                    10383   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    10384   ; return (OS_ERR_PEVENT_NULL);
                    10385   ; }
                    10386   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
                    10387   ; return (OS_ERR_EVENT_TYPE);
                    10388   ; }
                    10389   ; #endif
                    10390   ; OS_ENTER_CRITICAL();
000035C0  40E7      10391          dc.w      16615
000035C2  007C      10392          dc.w      124
000035C4  0700      10393          dc.w      1792
                    10394   ; pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
000035C6  206E 0008 10395          move.l    8(A6),A0
000035CA  2428 0002 10396          move.l    2(A0),D2
                    10397   ; pq->OSQIn      = pq->OSQStart;
000035CE  2042      10398          move.l    D2,A0
000035D0  2242      10399          move.l    D2,A1
000035D2  2368 0004 10400          move.l    4(A0),12(A1)
000035D6  000C      
                    10401   ; pq->OSQOut     = pq->OSQStart;
000035D8  2042      10402          move.l    D2,A0
000035DA  2242      10403          move.l    D2,A1
000035DC  2368 0004 10404          move.l    4(A0),16(A1)
000035E0  0010      
                    10405   ; pq->OSQEntries = 0u;
000035E2  2042      10406          move.l    D2,A0
000035E4  4268 0016 10407          clr.w     22(A0)
                    10408   ; OS_EXIT_CRITICAL();
000035E8  46DF      10409          dc.w      18143
                    10410   ; return (OS_ERR_NONE);
000035EA  4200      10411          clr.b     D0
000035EC  241F      10412          move.l    (A7)+,D2
000035EE  4E5E      10413          unlk      A6
000035F0  4E75      10414          rts
                    10415   ; }
                    10416   ; #endif
                    10417   ; /*$PAGE*/
                    10418   ; /*
                    10419   ; *********************************************************************************************************
                    10420   ; *                                    PEND ON A QUEUE FOR A MESSAGE
                    10421   ; *
                    10422   ; * Description: This function waits for a message to be sent to a queue
                    10423   ; *
                    10424   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10425   ; *
                    10426   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    10427   ; *                            wait for a message to arrive at the queue up to the amount of time
                    10428   ; *                            specified by this argument.  If you specify 0, however, your task will wait
                    10429   ; *                            forever at the specified queue or, until a message arrives.
                    10430   ; *
                    10431   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10432   ; *                            messages are:
                    10433   ; *
                    10434   ; *                            OS_ERR_NONE         The call was successful and your task received a
                    10435   ; *                                                message.
                    10436   ; *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
                    10437   ; *                            OS_ERR_PEND_ABORT   The wait on the queue was aborted.
                    10438   ; *                            OS_ERR_EVENT_TYPE   You didn't pass a pointer to a queue
                    10439   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
                    10440   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    10441   ; *                                                would lead to a suspension.
                    10442   ; *                            OS_ERR_PEND_LOCKED  If you called this function with the scheduler is locked
                    10443   ; *
                    10444   ; * Returns    : != (void *)0  is a pointer to the message received
                    10445   ; *              == (void *)0  if you received a NULL pointer message or,
                    10446   ; *                            if no message was received or,
                    10447   ; *                            if 'pevent' is a NULL pointer or,
                    10448   ; *                            if you didn't pass a pointer to a queue.
                    10449   ; *
                    10450   ; * Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
                    10451   ; *********************************************************************************************************
                    10452   ; */
                    10453   ; void  *OSQPend (OS_EVENT  *pevent,
                    10454   ; INT32U     timeout,
                    10455   ; INT8U     *perr)
                    10456   ; {
                    10457   _OSQPend:
000035F2  4E56 0000 10458          link      A6,#0
000035F6  48E7 3C20 10459          movem.l   D2/D3/D4/D5/A2,-(A7)
000035FA  45F9 0080 10460          lea       _OSTCBCur.L,A2
000035FE  0360      
00003600  262E 0010 10461          move.l    16(A6),D3
00003604  2A2E 0008 10462          move.l    8(A6),D5
                    10463   ; void      *pmsg;
                    10464   ; OS_Q      *pq;
                    10465   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    10466   ; OS_CPU_SR  cpu_sr = 0u;
                    10467   ; #endif
                    10468   ; #ifdef OS_SAFETY_CRITICAL
                    10469   ; if (perr == (INT8U *)0) {
                    10470   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10471   ; return ((void *)0);
                    10472   ; }
                    10473   ; #endif
                    10474   ; #if OS_ARG_CHK_EN > 0u
                    10475   ; if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
                    10476   ; *perr = OS_ERR_PEVENT_NULL;
                    10477   ; return ((void *)0);
                    10478   ; }
                    10479   ; #endif
                    10480   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
00003608  2045      10481          move.l    D5,A0
0000360A  1010      10482          move.b    (A0),D0
0000360C  0C00 0002 10483          cmp.b     #2,D0
00003610  670C      10484          beq.s     OSQPend_1
                    10485   ; *perr = OS_ERR_EVENT_TYPE;
00003612  2043      10486          move.l    D3,A0
00003614  10BC 0001 10487          move.b    #1,(A0)
                    10488   ; return ((void *)0);
00003618  4280      10489          clr.l     D0
0000361A  6000 0128 10490          bra       OSQPend_3
                    10491   OSQPend_1:
                    10492   ; }
                    10493   ; if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
0000361E  1039 0080 10494          move.b    _OSIntNesting.L,D0
00003622  0246      
00003624  0C00 0000 10495          cmp.b     #0,D0
00003628  630C      10496          bls.s     OSQPend_4
                    10497   ; *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
0000362A  2043      10498          move.l    D3,A0
0000362C  10BC 0002 10499          move.b    #2,(A0)
                    10500   ; return ((void *)0);
00003630  4280      10501          clr.l     D0
00003632  6000 0110 10502          bra       OSQPend_3
                    10503   OSQPend_4:
                    10504   ; }
                    10505   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked ...            */
00003636  1039 0080 10506          move.b    _OSLockNesting.L,D0
0000363A  0248      
0000363C  0C00 0000 10507          cmp.b     #0,D0
00003640  630C      10508          bls.s     OSQPend_6
                    10509   ; *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
00003642  2043      10510          move.l    D3,A0
00003644  10BC 000D 10511          move.b    #13,(A0)
                    10512   ; return ((void *)0);
00003648  4280      10513          clr.l     D0
0000364A  6000 00F8 10514          bra       OSQPend_3
                    10515   OSQPend_6:
                    10516   ; }
                    10517   ; OS_ENTER_CRITICAL();
0000364E  40E7      10518          dc.w      16615
00003650  007C      10519          dc.w      124
00003652  0700      10520          dc.w      1792
                    10521   ; pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
00003654  2045      10522          move.l    D5,A0
00003656  2428 0002 10523          move.l    2(A0),D2
                    10524   ; if (pq->OSQEntries > 0u) {                   /* See if any messages in the queue                   */
0000365A  2042      10525          move.l    D2,A0
0000365C  3028 0016 10526          move.w    22(A0),D0
00003660  0C40 0000 10527          cmp.w     #0,D0
00003664  6300 0042 10528          bls       OSQPend_8
                    10529   ; pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
00003668  2002      10530          move.l    D2,D0
0000366A  0680 0000 10531          add.l     #16,D0
0000366E  0010      
00003670  2040      10532          move.l    D0,A0
00003672  2250      10533          move.l    (A0),A1
00003674  5890      10534          addq.l    #4,(A0)
00003676  2811      10535          move.l    (A1),D4
                    10536   ; pq->OSQEntries--;                        /* Update the number of entries in the queue          */
00003678  2002      10537          move.l    D2,D0
0000367A  0680 0000 10538          add.l     #22,D0
0000367E  0016      
00003680  2040      10539          move.l    D0,A0
00003682  5350      10540          subq.w    #1,(A0)
                    10541   ; if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
00003684  2042      10542          move.l    D2,A0
00003686  2242      10543          move.l    D2,A1
00003688  2028 0010 10544          move.l    16(A0),D0
0000368C  B0A9 0008 10545          cmp.l     8(A1),D0
00003690  660A      10546          bne.s     OSQPend_10
                    10547   ; pq->OSQOut = pq->OSQStart;
00003692  2042      10548          move.l    D2,A0
00003694  2242      10549          move.l    D2,A1
00003696  2368 0004 10550          move.l    4(A0),16(A1)
0000369A  0010      
                    10551   OSQPend_10:
                    10552   ; }
                    10553   ; OS_EXIT_CRITICAL();
0000369C  46DF      10554          dc.w      18143
                    10555   ; *perr = OS_ERR_NONE;
0000369E  2043      10556          move.l    D3,A0
000036A0  4210      10557          clr.b     (A0)
                    10558   ; return (pmsg);                           /* Return message received                            */
000036A2  2004      10559          move.l    D4,D0
000036A4  6000 009E 10560          bra       OSQPend_3
                    10561   OSQPend_8:
                    10562   ; }
                    10563   ; OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
000036A8  2052      10564          move.l    (A2),A0
000036AA  0028 0004 10565          or.b      #4,50(A0)
000036AE  0032      
                    10566   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
000036B0  2052      10567          move.l    (A2),A0
000036B2  4228 0033 10568          clr.b     51(A0)
                    10569   ; OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
000036B6  2052      10570          move.l    (A2),A0
000036B8  216E 000C 10571          move.l    12(A6),46(A0)
000036BC  002E      
                    10572   ; OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
000036BE  2F05      10573          move.l    D5,-(A7)
000036C0  4EB8 0EFC 10574          jsr       _OS_EventTaskWait
000036C4  584F      10575          addq.w    #4,A7
                    10576   ; OS_EXIT_CRITICAL();
000036C6  46DF      10577          dc.w      18143
                    10578   ; OS_Sched();                                  /* Find next highest priority task ready to run       */
000036C8  4EB8 13F8 10579          jsr       _OS_Sched
                    10580   ; OS_ENTER_CRITICAL();
000036CC  40E7      10581          dc.w      16615
000036CE  007C      10582          dc.w      124
000036D0  0700      10583          dc.w      1792
                    10584   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
000036D2  2052      10585          move.l    (A2),A0
000036D4  1028 0033 10586          move.b    51(A0),D0
000036D8  C0BC 0000 10587          and.l     #255,D0
000036DC  00FF      
000036DE  0C80 0000 10588          cmp.l     #1,D0
000036E2  0001      
000036E4  6700 002A 10589          beq       OSQPend_16
000036E8  6206      10590          bhi.s     OSQPend_18
000036EA  4A80      10591          tst.l     D0
000036EC  670C      10592          beq.s     OSQPend_14
000036EE  6020      10593          bra.s     OSQPend_16
                    10594   OSQPend_18:
000036F0  0C80 0000 10595          cmp.l     #2,D0
000036F4  0002      
000036F6  670E      10596          beq.s     OSQPend_15
000036F8  6016      10597          bra.s     OSQPend_16
                    10598   OSQPend_14:
                    10599   ; case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
                    10600   ; pmsg =  OSTCBCur->OSTCBMsg;
000036FA  2052      10601          move.l    (A2),A0
000036FC  2828 0024 10602          move.l    36(A0),D4
                    10603   ; *perr =  OS_ERR_NONE;
00003700  2043      10604          move.l    D3,A0
00003702  4210      10605          clr.b     (A0)
                    10606   ; break;
00003704  601C      10607          bra.s     OSQPend_13
                    10608   OSQPend_15:
                    10609   ; case OS_STAT_PEND_ABORT:
                    10610   ; pmsg = (void *)0;
00003706  4284      10611          clr.l     D4
                    10612   ; *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00003708  2043      10613          move.l    D3,A0
0000370A  10BC 000E 10614          move.b    #14,(A0)
                    10615   ; break;
0000370E  6012      10616          bra.s     OSQPend_13
                    10617   OSQPend_16:
                    10618   ; case OS_STAT_PEND_TO:
                    10619   ; default:
                    10620   ; OS_EventTaskRemove(OSTCBCur, pevent);
00003710  2F05      10621          move.l    D5,-(A7)
00003712  2F12      10622          move.l    (A2),-(A7)
00003714  4EB8 101E 10623          jsr       _OS_EventTaskRemove
00003718  504F      10624          addq.w    #8,A7
                    10625   ; pmsg = (void *)0;
0000371A  4284      10626          clr.l     D4
                    10627   ; *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
0000371C  2043      10628          move.l    D3,A0
0000371E  10BC 000A 10629          move.b    #10,(A0)
                    10630   ; break;
                    10631   OSQPend_13:
                    10632   ; }
                    10633   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00003722  2052      10634          move.l    (A2),A0
00003724  4228 0032 10635          clr.b     50(A0)
                    10636   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00003728  2052      10637          move.l    (A2),A0
0000372A  4228 0033 10638          clr.b     51(A0)
                    10639   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
0000372E  2052      10640          move.l    (A2),A0
00003730  42A8 001C 10641          clr.l     28(A0)
                    10642   ; #if (OS_EVENT_MULTI_EN > 0u)
                    10643   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00003734  2052      10644          move.l    (A2),A0
00003736  42A8 0020 10645          clr.l     32(A0)
                    10646   ; #endif
                    10647   ; OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
0000373A  2052      10648          move.l    (A2),A0
0000373C  42A8 0024 10649          clr.l     36(A0)
                    10650   ; OS_EXIT_CRITICAL();
00003740  46DF      10651          dc.w      18143
                    10652   ; return (pmsg);                                    /* Return received message                       */
00003742  2004      10653          move.l    D4,D0
                    10654   OSQPend_3:
00003744  4CDF 043C 10655          movem.l   (A7)+,D2/D3/D4/D5/A2
00003748  4E5E      10656          unlk      A6
0000374A  4E75      10657          rts
                    10658   ; }
                    10659   ; /*$PAGE*/
                    10660   ; /*
                    10661   ; *********************************************************************************************************
                    10662   ; *                                  ABORT WAITING ON A MESSAGE QUEUE
                    10663   ; *
                    10664   ; * Description: This function aborts & readies any tasks currently waiting on a queue.  This function
                    10665   ; *              should be used to fault-abort the wait on the queue, rather than to normally signal
                    10666   ; *              the queue via OSQPost(), OSQPostFront() or OSQPostOpt().
                    10667   ; *
                    10668   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue.
                    10669   ; *
                    10670   ; *              opt           determines the type of ABORT performed:
                    10671   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    10672   ; *                                                     queue
                    10673   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    10674   ; *                                                     queue
                    10675   ; *
                    10676   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    10677   ; *                            messages are:
                    10678   ; *
                    10679   ; *                            OS_ERR_NONE         No tasks were     waiting on the queue.
                    10680   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the queue was readied
                    10681   ; *                                                and informed of the aborted wait; check return value
                    10682   ; *                                                for the number of tasks whose wait on the queue
                    10683   ; *                                                was aborted.
                    10684   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a queue.
                    10685   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    10686   ; *
                    10687   ; * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
                    10688   ; *              >  0          if one or more tasks waiting on the queue are now readied and informed.
                    10689   ; *********************************************************************************************************
                    10690   ; */
                    10691   ; #if OS_Q_PEND_ABORT_EN > 0u
                    10692   ; INT8U  OSQPendAbort (OS_EVENT  *pevent,
                    10693   ; INT8U      opt,
                    10694   ; INT8U     *perr)
                    10695   ; {
                    10696   _OSQPendAbort:
0000374C  4E56 0000 10697          link      A6,#0
00003750  48E7 3800 10698          movem.l   D2/D3/D4,-(A7)
00003754  242E 0008 10699          move.l    8(A6),D2
00003758  282E 0010 10700          move.l    16(A6),D4
                    10701   ; INT8U      nbr_tasks;
                    10702   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    10703   ; OS_CPU_SR  cpu_sr = 0u;
                    10704   ; #endif
                    10705   ; #ifdef OS_SAFETY_CRITICAL
                    10706   ; if (perr == (INT8U *)0) {
                    10707   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    10708   ; return (0u);
                    10709   ; }
                    10710   ; #endif
                    10711   ; #if OS_ARG_CHK_EN > 0u
                    10712   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    10713   ; *perr = OS_ERR_PEVENT_NULL;
                    10714   ; return (0u);
                    10715   ; }
                    10716   ; #endif
                    10717   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
0000375C  2042      10718          move.l    D2,A0
0000375E  1010      10719          move.b    (A0),D0
00003760  0C00 0002 10720          cmp.b     #2,D0
00003764  670C      10721          beq.s     OSQPendAbort_1
                    10722   ; *perr = OS_ERR_EVENT_TYPE;
00003766  2044      10723          move.l    D4,A0
00003768  10BC 0001 10724          move.b    #1,(A0)
                    10725   ; return (0u);
0000376C  4200      10726          clr.b     D0
0000376E  6000 008C 10727          bra       OSQPendAbort_3
                    10728   OSQPendAbort_1:
                    10729   ; }
                    10730   ; OS_ENTER_CRITICAL();
00003772  40E7      10731          dc.w      16615
00003774  007C      10732          dc.w      124
00003776  0700      10733          dc.w      1792
                    10734   ; if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on queue?        */
00003778  2042      10735          move.l    D2,A0
0000377A  1028 0008 10736          move.b    8(A0),D0
0000377E  6700 0074 10737          beq       OSQPendAbort_4
                    10738   ; nbr_tasks = 0u;
00003782  4203      10739          clr.b     D3
                    10740   ; switch (opt) {
00003784  102E 000F 10741          move.b    15(A6),D0
00003788  C0BC 0000 10742          and.l     #255,D0
0000378C  00FF      
0000378E  0C80 0000 10743          cmp.l     #1,D0
00003792  0001      
00003794  670A      10744          beq.s     OSQPendAbort_8
00003796  6200 0030 10745          bhi       OSQPendAbort_9
0000379A  4A80      10746          tst.l     D0
0000379C  672A      10747          beq.s     OSQPendAbort_9
0000379E  6028      10748          bra.s     OSQPendAbort_9
                    10749   OSQPendAbort_8:
                    10750   ; case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                    10751   ; while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on queue    */
                    10752   OSQPendAbort_11:
000037A0  2042      10753          move.l    D2,A0
000037A2  1028 0008 10754          move.b    8(A0),D0
000037A6  671E      10755          beq.s     OSQPendAbort_13
                    10756   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
000037A8  4878 0002 10757          pea       2
000037AC  4878 0004 10758          pea       4
000037B0  42A7      10759          clr.l     -(A7)
000037B2  2F02      10760          move.l    D2,-(A7)
000037B4  4EB8 0E18 10761          jsr       _OS_EventTaskRdy
000037B8  DEFC 0010 10762          add.w     #16,A7
000037BC  C0BC 0000 10763          and.l     #255,D0
000037C0  00FF      
                    10764   ; nbr_tasks++;
000037C2  5203      10765          addq.b    #1,D3
000037C4  60DA      10766          bra       OSQPendAbort_11
                    10767   OSQPendAbort_13:
                    10768   ; }
                    10769   ; break;
000037C6  601C      10770          bra.s     OSQPendAbort_7
                    10771   OSQPendAbort_9:
                    10772   ; case OS_PEND_OPT_NONE:
                    10773   ; default:                                       /* No,  ready HPT       waiting on queue    */
                    10774   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
000037C8  4878 0002 10775          pea       2
000037CC  4878 0004 10776          pea       4
000037D0  42A7      10777          clr.l     -(A7)
000037D2  2F02      10778          move.l    D2,-(A7)
000037D4  4EB8 0E18 10779          jsr       _OS_EventTaskRdy
000037D8  DEFC 0010 10780          add.w     #16,A7
000037DC  C0BC 0000 10781          and.l     #255,D0
000037E0  00FF      
                    10782   ; nbr_tasks++;
000037E2  5203      10783          addq.b    #1,D3
                    10784   ; break;
                    10785   OSQPendAbort_7:
                    10786   ; }
                    10787   ; OS_EXIT_CRITICAL();
000037E4  46DF      10788          dc.w      18143
                    10789   ; OS_Sched();                                        /* Find HPT ready to run                    */
000037E6  4EB8 13F8 10790          jsr       _OS_Sched
                    10791   ; *perr = OS_ERR_PEND_ABORT;
000037EA  2044      10792          move.l    D4,A0
000037EC  10BC 000E 10793          move.b    #14,(A0)
                    10794   ; return (nbr_tasks);
000037F0  1003      10795          move.b    D3,D0
000037F2  6008      10796          bra.s     OSQPendAbort_3
                    10797   OSQPendAbort_4:
                    10798   ; }
                    10799   ; OS_EXIT_CRITICAL();
000037F4  46DF      10800          dc.w      18143
                    10801   ; *perr = OS_ERR_NONE;
000037F6  2044      10802          move.l    D4,A0
000037F8  4210      10803          clr.b     (A0)
                    10804   ; return (0u);                                           /* No tasks waiting on queue                */
000037FA  4200      10805          clr.b     D0
                    10806   OSQPendAbort_3:
000037FC  4CDF 001C 10807          movem.l   (A7)+,D2/D3/D4
00003800  4E5E      10808          unlk      A6
00003802  4E75      10809          rts
                    10810   ; }
                    10811   ; #endif
                    10812   ; /*$PAGE*/
                    10813   ; /*
                    10814   ; *********************************************************************************************************
                    10815   ; *                                       POST MESSAGE TO A QUEUE
                    10816   ; *
                    10817   ; * Description: This function sends a message to a queue
                    10818   ; *
                    10819   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10820   ; *
                    10821   ; *              pmsg          is a pointer to the message to send.
                    10822   ; *
                    10823   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    10824   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    10825   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    10826   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    10827   ; *
                    10828   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    10829   ; *********************************************************************************************************
                    10830   ; */
                    10831   ; #if OS_Q_POST_EN > 0u
                    10832   ; INT8U  OSQPost (OS_EVENT  *pevent,
                    10833   ; void      *pmsg)
                    10834   ; {
                    10835   _OSQPost:
00003804  4E56 0000 10836          link      A6,#0
00003808  48E7 3000 10837          movem.l   D2/D3,-(A7)
0000380C  262E 0008 10838          move.l    8(A6),D3
                    10839   ; OS_Q      *pq;
                    10840   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    10841   ; OS_CPU_SR  cpu_sr = 0u;
                    10842   ; #endif
                    10843   ; #if OS_ARG_CHK_EN > 0u
                    10844   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    10845   ; return (OS_ERR_PEVENT_NULL);
                    10846   ; }
                    10847   ; #endif
                    10848   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00003810  2043      10849          move.l    D3,A0
00003812  1010      10850          move.b    (A0),D0
00003814  0C00 0002 10851          cmp.b     #2,D0
00003818  6706      10852          beq.s     OSQPost_1
                    10853   ; return (OS_ERR_EVENT_TYPE);
0000381A  7001      10854          moveq     #1,D0
0000381C  6000 008C 10855          bra       OSQPost_3
                    10856   OSQPost_1:
                    10857   ; }
                    10858   ; OS_ENTER_CRITICAL();
00003820  40E7      10859          dc.w      16615
00003822  007C      10860          dc.w      124
00003824  0700      10861          dc.w      1792
                    10862   ; if (pevent->OSEventGrp != 0u) {                    /* See if any task pending on queue             */
00003826  2043      10863          move.l    D3,A0
00003828  1028 0008 10864          move.b    8(A0),D0
0000382C  6726      10865          beq.s     OSQPost_4
                    10866   ; /* Ready highest priority task waiting on event */
                    10867   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
0000382E  42A7      10868          clr.l     -(A7)
00003830  4878 0004 10869          pea       4
00003834  2F2E 000C 10870          move.l    12(A6),-(A7)
00003838  2F03      10871          move.l    D3,-(A7)
0000383A  4EB8 0E18 10872          jsr       _OS_EventTaskRdy
0000383E  DEFC 0010 10873          add.w     #16,A7
00003842  C0BC 0000 10874          and.l     #255,D0
00003846  00FF      
                    10875   ; OS_EXIT_CRITICAL();
00003848  46DF      10876          dc.w      18143
                    10877   ; OS_Sched();                                    /* Find highest priority task ready to run      */
0000384A  4EB8 13F8 10878          jsr       _OS_Sched
                    10879   ; return (OS_ERR_NONE);
0000384E  4200      10880          clr.b     D0
00003850  6000 0058 10881          bra       OSQPost_3
                    10882   OSQPost_4:
                    10883   ; }
                    10884   ; pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
00003854  2043      10885          move.l    D3,A0
00003856  2428 0002 10886          move.l    2(A0),D2
                    10887   ; if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
0000385A  2042      10888          move.l    D2,A0
0000385C  2242      10889          move.l    D2,A1
0000385E  3028 0016 10890          move.w    22(A0),D0
00003862  B069 0014 10891          cmp.w     20(A1),D0
00003866  6508      10892          blo.s     OSQPost_6
                    10893   ; OS_EXIT_CRITICAL();
00003868  46DF      10894          dc.w      18143
                    10895   ; return (OS_ERR_Q_FULL);
0000386A  701E      10896          moveq     #30,D0
0000386C  6000 003C 10897          bra       OSQPost_3
                    10898   OSQPost_6:
                    10899   ; }
                    10900   ; *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
00003870  2002      10901          move.l    D2,D0
00003872  0680 0000 10902          add.l     #12,D0
00003876  000C      
00003878  2040      10903          move.l    D0,A0
0000387A  2250      10904          move.l    (A0),A1
0000387C  5890      10905          addq.l    #4,(A0)
0000387E  22AE 000C 10906          move.l    12(A6),(A1)
                    10907   ; pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
00003882  2002      10908          move.l    D2,D0
00003884  0680 0000 10909          add.l     #22,D0
00003888  0016      
0000388A  2040      10910          move.l    D0,A0
0000388C  5250      10911          addq.w    #1,(A0)
                    10912   ; if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
0000388E  2042      10913          move.l    D2,A0
00003890  2242      10914          move.l    D2,A1
00003892  2028 000C 10915          move.l    12(A0),D0
00003896  B0A9 0008 10916          cmp.l     8(A1),D0
0000389A  660A      10917          bne.s     OSQPost_8
                    10918   ; pq->OSQIn = pq->OSQStart;
0000389C  2042      10919          move.l    D2,A0
0000389E  2242      10920          move.l    D2,A1
000038A0  2368 0004 10921          move.l    4(A0),12(A1)
000038A4  000C      
                    10922   OSQPost_8:
                    10923   ; }
                    10924   ; OS_EXIT_CRITICAL();
000038A6  46DF      10925          dc.w      18143
                    10926   ; return (OS_ERR_NONE);
000038A8  4200      10927          clr.b     D0
                    10928   OSQPost_3:
000038AA  4CDF 000C 10929          movem.l   (A7)+,D2/D3
000038AE  4E5E      10930          unlk      A6
000038B0  4E75      10931          rts
                    10932   ; }
                    10933   ; #endif
                    10934   ; /*$PAGE*/
                    10935   ; /*
                    10936   ; *********************************************************************************************************
                    10937   ; *                                POST MESSAGE TO THE FRONT OF A QUEUE
                    10938   ; *
                    10939   ; * Description: This function sends a message to a queue but unlike OSQPost(), the message is posted at
                    10940   ; *              the front instead of the end of the queue.  Using OSQPostFront() allows you to send
                    10941   ; *              'priority' messages.
                    10942   ; *
                    10943   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    10944   ; *
                    10945   ; *              pmsg          is a pointer to the message to send.
                    10946   ; *
                    10947   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    10948   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    10949   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    10950   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    10951   ; *
                    10952   ; * Note(s)    : As of V2.60, this function allows you to send NULL pointer messages.
                    10953   ; *********************************************************************************************************
                    10954   ; */
                    10955   ; #if OS_Q_POST_FRONT_EN > 0u
                    10956   ; INT8U  OSQPostFront (OS_EVENT  *pevent,
                    10957   ; void      *pmsg)
                    10958   ; {
                    10959   _OSQPostFront:
000038B2  4E56 0000 10960          link      A6,#0
000038B6  48E7 3000 10961          movem.l   D2/D3,-(A7)
000038BA  262E 0008 10962          move.l    8(A6),D3
                    10963   ; OS_Q      *pq;
                    10964   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    10965   ; OS_CPU_SR  cpu_sr = 0u;
                    10966   ; #endif
                    10967   ; #if OS_ARG_CHK_EN > 0u
                    10968   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    10969   ; return (OS_ERR_PEVENT_NULL);
                    10970   ; }
                    10971   ; #endif
                    10972   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
000038BE  2043      10973          move.l    D3,A0
000038C0  1010      10974          move.b    (A0),D0
000038C2  0C00 0002 10975          cmp.b     #2,D0
000038C6  6706      10976          beq.s     OSQPostFront_1
                    10977   ; return (OS_ERR_EVENT_TYPE);
000038C8  7001      10978          moveq     #1,D0
000038CA  6000 0090 10979          bra       OSQPostFront_3
                    10980   OSQPostFront_1:
                    10981   ; }
                    10982   ; OS_ENTER_CRITICAL();
000038CE  40E7      10983          dc.w      16615
000038D0  007C      10984          dc.w      124
000038D2  0700      10985          dc.w      1792
                    10986   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on queue              */
000038D4  2043      10987          move.l    D3,A0
000038D6  1028 0008 10988          move.b    8(A0),D0
000038DA  6726      10989          beq.s     OSQPostFront_4
                    10990   ; /* Ready highest priority task waiting on event  */
                    10991   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
000038DC  42A7      10992          clr.l     -(A7)
000038DE  4878 0004 10993          pea       4
000038E2  2F2E 000C 10994          move.l    12(A6),-(A7)
000038E6  2F03      10995          move.l    D3,-(A7)
000038E8  4EB8 0E18 10996          jsr       _OS_EventTaskRdy
000038EC  DEFC 0010 10997          add.w     #16,A7
000038F0  C0BC 0000 10998          and.l     #255,D0
000038F4  00FF      
                    10999   ; OS_EXIT_CRITICAL();
000038F6  46DF      11000          dc.w      18143
                    11001   ; OS_Sched();                                   /* Find highest priority task ready to run       */
000038F8  4EB8 13F8 11002          jsr       _OS_Sched
                    11003   ; return (OS_ERR_NONE);
000038FC  4200      11004          clr.b     D0
000038FE  6000 005C 11005          bra       OSQPostFront_3
                    11006   OSQPostFront_4:
                    11007   ; }
                    11008   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
00003902  2043      11009          move.l    D3,A0
00003904  2428 0002 11010          move.l    2(A0),D2
                    11011   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
00003908  2042      11012          move.l    D2,A0
0000390A  2242      11013          move.l    D2,A1
0000390C  3028 0016 11014          move.w    22(A0),D0
00003910  B069 0014 11015          cmp.w     20(A1),D0
00003914  6508      11016          blo.s     OSQPostFront_6
                    11017   ; OS_EXIT_CRITICAL();
00003916  46DF      11018          dc.w      18143
                    11019   ; return (OS_ERR_Q_FULL);
00003918  701E      11020          moveq     #30,D0
0000391A  6000 0040 11021          bra       OSQPostFront_3
                    11022   OSQPostFront_6:
                    11023   ; }
                    11024   ; if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
0000391E  2042      11025          move.l    D2,A0
00003920  2242      11026          move.l    D2,A1
00003922  2028 0010 11027          move.l    16(A0),D0
00003926  B0A9 0004 11028          cmp.l     4(A1),D0
0000392A  660A      11029          bne.s     OSQPostFront_8
                    11030   ; pq->OSQOut = pq->OSQEnd;
0000392C  2042      11031          move.l    D2,A0
0000392E  2242      11032          move.l    D2,A1
00003930  2368 0008 11033          move.l    8(A0),16(A1)
00003934  0010      
                    11034   OSQPostFront_8:
                    11035   ; }
                    11036   ; pq->OSQOut--;
00003936  2002      11037          move.l    D2,D0
00003938  0680 0000 11038          add.l     #16,D0
0000393C  0010      
0000393E  2040      11039          move.l    D0,A0
00003940  5990      11040          subq.l    #4,(A0)
                    11041   ; *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
00003942  2042      11042          move.l    D2,A0
00003944  2068 0010 11043          move.l    16(A0),A0
00003948  20AE 000C 11044          move.l    12(A6),(A0)
                    11045   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
0000394C  2002      11046          move.l    D2,D0
0000394E  0680 0000 11047          add.l     #22,D0
00003952  0016      
00003954  2040      11048          move.l    D0,A0
00003956  5250      11049          addq.w    #1,(A0)
                    11050   ; OS_EXIT_CRITICAL();
00003958  46DF      11051          dc.w      18143
                    11052   ; return (OS_ERR_NONE);
0000395A  4200      11053          clr.b     D0
                    11054   OSQPostFront_3:
0000395C  4CDF 000C 11055          movem.l   (A7)+,D2/D3
00003960  4E5E      11056          unlk      A6
00003962  4E75      11057          rts
                    11058   ; }
                    11059   ; #endif
                    11060   ; /*$PAGE*/
                    11061   ; /*
                    11062   ; *********************************************************************************************************
                    11063   ; *                                       POST MESSAGE TO A QUEUE
                    11064   ; *
                    11065   ; * Description: This function sends a message to a queue.  This call has been added to reduce code size
                    11066   ; *              since it can replace both OSQPost() and OSQPostFront().  Also, this function adds the
                    11067   ; *              capability to broadcast a message to ALL tasks waiting on the message queue.
                    11068   ; *
                    11069   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11070   ; *
                    11071   ; *              pmsg          is a pointer to the message to send.
                    11072   ; *
                    11073   ; *              opt           determines the type of POST performed:
                    11074   ; *                            OS_POST_OPT_NONE         POST to a single waiting task
                    11075   ; *                                                     (Identical to OSQPost())
                    11076   ; *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the queue
                    11077   ; *                            OS_POST_OPT_FRONT        POST as LIFO (Simulates OSQPostFront())
                    11078   ; *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
                    11079   ; *
                    11080   ; * Returns    : OS_ERR_NONE           The call was successful and the message was sent
                    11081   ; *              OS_ERR_Q_FULL         If the queue cannot accept any more messages because it is full.
                    11082   ; *              OS_ERR_EVENT_TYPE     If you didn't pass a pointer to a queue.
                    11083   ; *              OS_ERR_PEVENT_NULL    If 'pevent' is a NULL pointer
                    11084   ; *
                    11085   ; * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
                    11086   ; *              interrupt disable time is proportional to the number of tasks waiting on the queue.
                    11087   ; *********************************************************************************************************
                    11088   ; */
                    11089   ; #if OS_Q_POST_OPT_EN > 0u
                    11090   ; INT8U  OSQPostOpt (OS_EVENT  *pevent,
                    11091   ; void      *pmsg,
                    11092   ; INT8U      opt)
                    11093   ; {
                    11094   _OSQPostOpt:
00003964  4E56 0000 11095          link      A6,#0
00003968  48E7 3C00 11096          movem.l   D2/D3/D4/D5,-(A7)
0000396C  262E 0008 11097          move.l    8(A6),D3
00003970  282E 000C 11098          move.l    12(A6),D4
00003974  1A2E 0013 11099          move.b    19(A6),D5
00003978  CABC 0000 11100          and.l     #255,D5
0000397C  00FF      
                    11101   ; OS_Q      *pq;
                    11102   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11103   ; OS_CPU_SR  cpu_sr = 0u;
                    11104   ; #endif
                    11105   ; #if OS_ARG_CHK_EN > 0u
                    11106   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11107   ; return (OS_ERR_PEVENT_NULL);
                    11108   ; }
                    11109   ; #endif
                    11110   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
0000397E  2043      11111          move.l    D3,A0
00003980  1010      11112          move.b    (A0),D0
00003982  0C00 0002 11113          cmp.b     #2,D0
00003986  6706      11114          beq.s     OSQPostOpt_1
                    11115   ; return (OS_ERR_EVENT_TYPE);
00003988  7001      11116          moveq     #1,D0
0000398A  6000 00F6 11117          bra       OSQPostOpt_3
                    11118   OSQPostOpt_1:
                    11119   ; }
                    11120   ; OS_ENTER_CRITICAL();
0000398E  40E7      11121          dc.w      16615
00003990  007C      11122          dc.w      124
00003992  0700      11123          dc.w      1792
                    11124   ; if (pevent->OSEventGrp != 0x00u) {                /* See if any task pending on queue              */
00003994  2043      11125          move.l    D3,A0
00003996  1028 0008 11126          move.b    8(A0),D0
0000399A  6700 005A 11127          beq       OSQPostOpt_4
                    11128   ; if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
0000399E  1005      11129          move.b    D5,D0
000039A0  C03C 0001 11130          and.b     #1,D0
000039A4  6724      11131          beq.s     OSQPostOpt_6
                    11132   ; while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on queue       */
                    11133   OSQPostOpt_8:
000039A6  2043      11134          move.l    D3,A0
000039A8  1028 0008 11135          move.b    8(A0),D0
000039AC  671A      11136          beq.s     OSQPostOpt_10
                    11137   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
000039AE  42A7      11138          clr.l     -(A7)
000039B0  4878 0004 11139          pea       4
000039B4  2F04      11140          move.l    D4,-(A7)
000039B6  2F03      11141          move.l    D3,-(A7)
000039B8  4EB8 0E18 11142          jsr       _OS_EventTaskRdy
000039BC  DEFC 0010 11143          add.w     #16,A7
000039C0  C0BC 0000 11144          and.l     #255,D0
000039C4  00FF      
000039C6  60DE      11145          bra       OSQPostOpt_8
                    11146   OSQPostOpt_10:
000039C8  6018      11147          bra.s     OSQPostOpt_7
                    11148   OSQPostOpt_6:
                    11149   ; }
                    11150   ; } else {                                      /* No,  Post to HPT waiting on queue             */
                    11151   ; (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
000039CA  42A7      11152          clr.l     -(A7)
000039CC  4878 0004 11153          pea       4
000039D0  2F04      11154          move.l    D4,-(A7)
000039D2  2F03      11155          move.l    D3,-(A7)
000039D4  4EB8 0E18 11156          jsr       _OS_EventTaskRdy
000039D8  DEFC 0010 11157          add.w     #16,A7
000039DC  C0BC 0000 11158          and.l     #255,D0
000039E0  00FF      
                    11159   OSQPostOpt_7:
                    11160   ; }
                    11161   ; OS_EXIT_CRITICAL();
000039E2  46DF      11162          dc.w      18143
                    11163   ; if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
000039E4  1005      11164          move.b    D5,D0
000039E6  C03C 0004 11165          and.b     #4,D0
000039EA  6604      11166          bne.s     OSQPostOpt_11
                    11167   ; OS_Sched();                               /* Find highest priority task ready to run       */
000039EC  4EB8 13F8 11168          jsr       _OS_Sched
                    11169   OSQPostOpt_11:
                    11170   ; }
                    11171   ; return (OS_ERR_NONE);
000039F0  4200      11172          clr.b     D0
000039F2  6000 008E 11173          bra       OSQPostOpt_3
                    11174   OSQPostOpt_4:
                    11175   ; }
                    11176   ; pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
000039F6  2043      11177          move.l    D3,A0
000039F8  2428 0002 11178          move.l    2(A0),D2
                    11179   ; if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
000039FC  2042      11180          move.l    D2,A0
000039FE  2242      11181          move.l    D2,A1
00003A00  3028 0016 11182          move.w    22(A0),D0
00003A04  B069 0014 11183          cmp.w     20(A1),D0
00003A08  6508      11184          blo.s     OSQPostOpt_13
                    11185   ; OS_EXIT_CRITICAL();
00003A0A  46DF      11186          dc.w      18143
                    11187   ; return (OS_ERR_Q_FULL);
00003A0C  701E      11188          moveq     #30,D0
00003A0E  6000 0072 11189          bra       OSQPostOpt_3
                    11190   OSQPostOpt_13:
                    11191   ; }
                    11192   ; if ((opt & OS_POST_OPT_FRONT) != 0x00u) {         /* Do we post to the FRONT of the queue?         */
00003A12  1005      11193          move.b    D5,D0
00003A14  C03C 0002 11194          and.b     #2,D0
00003A18  6700 0030 11195          beq       OSQPostOpt_15
                    11196   ; if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
00003A1C  2042      11197          move.l    D2,A0
00003A1E  2242      11198          move.l    D2,A1
00003A20  2028 0010 11199          move.l    16(A0),D0
00003A24  B0A9 0004 11200          cmp.l     4(A1),D0
00003A28  660A      11201          bne.s     OSQPostOpt_17
                    11202   ; pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
00003A2A  2042      11203          move.l    D2,A0
00003A2C  2242      11204          move.l    D2,A1
00003A2E  2368 0008 11205          move.l    8(A0),16(A1)
00003A32  0010      
                    11206   OSQPostOpt_17:
                    11207   ; }
                    11208   ; pq->OSQOut--;
00003A34  2002      11209          move.l    D2,D0
00003A36  0680 0000 11210          add.l     #16,D0
00003A3A  0010      
00003A3C  2040      11211          move.l    D0,A0
00003A3E  5990      11212          subq.l    #4,(A0)
                    11213   ; *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
00003A40  2042      11214          move.l    D2,A0
00003A42  2068 0010 11215          move.l    16(A0),A0
00003A46  2084      11216          move.l    D4,(A0)
00003A48  6028      11217          bra.s     OSQPostOpt_19
                    11218   OSQPostOpt_15:
                    11219   ; } else {                                          /* No,  Post as FIFO                             */
                    11220   ; *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
00003A4A  2002      11221          move.l    D2,D0
00003A4C  0680 0000 11222          add.l     #12,D0
00003A50  000C      
00003A52  2040      11223          move.l    D0,A0
00003A54  2250      11224          move.l    (A0),A1
00003A56  5890      11225          addq.l    #4,(A0)
00003A58  2284      11226          move.l    D4,(A1)
                    11227   ; if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
00003A5A  2042      11228          move.l    D2,A0
00003A5C  2242      11229          move.l    D2,A1
00003A5E  2028 000C 11230          move.l    12(A0),D0
00003A62  B0A9 0008 11231          cmp.l     8(A1),D0
00003A66  660A      11232          bne.s     OSQPostOpt_19
                    11233   ; pq->OSQIn = pq->OSQStart;
00003A68  2042      11234          move.l    D2,A0
00003A6A  2242      11235          move.l    D2,A1
00003A6C  2368 0004 11236          move.l    4(A0),12(A1)
00003A70  000C      
                    11237   OSQPostOpt_19:
                    11238   ; }
                    11239   ; }
                    11240   ; pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
00003A72  2002      11241          move.l    D2,D0
00003A74  0680 0000 11242          add.l     #22,D0
00003A78  0016      
00003A7A  2040      11243          move.l    D0,A0
00003A7C  5250      11244          addq.w    #1,(A0)
                    11245   ; OS_EXIT_CRITICAL();
00003A7E  46DF      11246          dc.w      18143
                    11247   ; return (OS_ERR_NONE);
00003A80  4200      11248          clr.b     D0
                    11249   OSQPostOpt_3:
00003A82  4CDF 003C 11250          movem.l   (A7)+,D2/D3/D4/D5
00003A86  4E5E      11251          unlk      A6
00003A88  4E75      11252          rts
                    11253   ; }
                    11254   ; #endif
                    11255   ; /*$PAGE*/
                    11256   ; /*
                    11257   ; *********************************************************************************************************
                    11258   ; *                                        QUERY A MESSAGE QUEUE
                    11259   ; *
                    11260   ; * Description: This function obtains information about a message queue.
                    11261   ; *
                    11262   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired queue
                    11263   ; *
                    11264   ; *              p_q_data      is a pointer to a structure that will contain information about the message
                    11265   ; *                            queue.
                    11266   ; *
                    11267   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    11268   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non queue.
                    11269   ; *              OS_ERR_PEVENT_NULL  If 'pevent'   is a NULL pointer
                    11270   ; *              OS_ERR_PDATA_NULL   If 'p_q_data' is a NULL pointer
                    11271   ; *********************************************************************************************************
                    11272   ; */
                    11273   ; #if OS_Q_QUERY_EN > 0u
                    11274   ; INT8U  OSQQuery (OS_EVENT  *pevent,
                    11275   ; OS_Q_DATA *p_q_data)
                    11276   ; {
                    11277   _OSQQuery:
00003A8A  4E56 FFF8 11278          link      A6,#-8
00003A8E  48E7 3C00 11279          movem.l   D2/D3/D4/D5,-(A7)
00003A92  242E 000C 11280          move.l    12(A6),D2
00003A96  282E 0008 11281          move.l    8(A6),D4
                    11282   ; OS_Q       *pq;
                    11283   ; INT8U       i;
                    11284   ; OS_PRIO    *psrc;
                    11285   ; OS_PRIO    *pdest;
                    11286   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    11287   ; OS_CPU_SR   cpu_sr = 0u;
                    11288   ; #endif
                    11289   ; #if OS_ARG_CHK_EN > 0u
                    11290   ; if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                    11291   ; return (OS_ERR_PEVENT_NULL);
                    11292   ; }
                    11293   ; if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
                    11294   ; return (OS_ERR_PDATA_NULL);
                    11295   ; }
                    11296   ; #endif
                    11297   ; if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
00003A9A  2044      11298          move.l    D4,A0
00003A9C  1010      11299          move.b    (A0),D0
00003A9E  0C00 0002 11300          cmp.b     #2,D0
00003AA2  6706      11301          beq.s     OSQQuery_1
                    11302   ; return (OS_ERR_EVENT_TYPE);
00003AA4  7001      11303          moveq     #1,D0
00003AA6  6000 007A 11304          bra       OSQQuery_3
                    11305   OSQQuery_1:
                    11306   ; }
                    11307   ; OS_ENTER_CRITICAL();
00003AAA  40E7      11308          dc.w      16615
00003AAC  007C      11309          dc.w      124
00003AAE  0700      11310          dc.w      1792
                    11311   ; p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
00003AB0  2044      11312          move.l    D4,A0
00003AB2  2242      11313          move.l    D2,A1
00003AB4  1368 0008 11314          move.b    8(A0),16(A1)
00003AB8  0010      
                    11315   ; psrc                 = &pevent->OSEventTbl[0];
00003ABA  700A      11316          moveq     #10,D0
00003ABC  D084      11317          add.l     D4,D0
00003ABE  2D40 FFF8 11318          move.l    D0,-8(A6)
                    11319   ; pdest                = &p_q_data->OSEventTbl[0];
00003AC2  7008      11320          moveq     #8,D0
00003AC4  D082      11321          add.l     D2,D0
00003AC6  2D40 FFFC 11322          move.l    D0,-4(A6)
                    11323   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00003ACA  4205      11324          clr.b     D5
                    11325   OSQQuery_4:
00003ACC  0C05 0008 11326          cmp.b     #8,D5
00003AD0  6416      11327          bhs.s     OSQQuery_6
                    11328   ; *pdest++ = *psrc++;
00003AD2  206E FFF8 11329          move.l    -8(A6),A0
00003AD6  52AE FFF8 11330          addq.l    #1,-8(A6)
00003ADA  226E FFFC 11331          move.l    -4(A6),A1
00003ADE  52AE FFFC 11332          addq.l    #1,-4(A6)
00003AE2  1290      11333          move.b    (A0),(A1)
00003AE4  5205      11334          addq.b    #1,D5
00003AE6  60E4      11335          bra       OSQQuery_4
                    11336   OSQQuery_6:
                    11337   ; }
                    11338   ; pq = (OS_Q *)pevent->OSEventPtr;
00003AE8  2044      11339          move.l    D4,A0
00003AEA  2628 0002 11340          move.l    2(A0),D3
                    11341   ; if (pq->OSQEntries > 0u) {
00003AEE  2043      11342          move.l    D3,A0
00003AF0  3028 0016 11343          move.w    22(A0),D0
00003AF4  0C40 0000 11344          cmp.w     #0,D0
00003AF8  630C      11345          bls.s     OSQQuery_7
                    11346   ; p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
00003AFA  2043      11347          move.l    D3,A0
00003AFC  2068 0010 11348          move.l    16(A0),A0
00003B00  2242      11349          move.l    D2,A1
00003B02  2290      11350          move.l    (A0),(A1)
00003B04  6004      11351          bra.s     OSQQuery_8
                    11352   OSQQuery_7:
                    11353   ; } else {
                    11354   ; p_q_data->OSMsg = (void *)0;
00003B06  2042      11355          move.l    D2,A0
00003B08  4290      11356          clr.l     (A0)
                    11357   OSQQuery_8:
                    11358   ; }
                    11359   ; p_q_data->OSNMsgs = pq->OSQEntries;
00003B0A  2043      11360          move.l    D3,A0
00003B0C  2242      11361          move.l    D2,A1
00003B0E  3368 0016 11362          move.w    22(A0),4(A1)
00003B12  0004      
                    11363   ; p_q_data->OSQSize = pq->OSQSize;
00003B14  2043      11364          move.l    D3,A0
00003B16  2242      11365          move.l    D2,A1
00003B18  3368 0014 11366          move.w    20(A0),6(A1)
00003B1C  0006      
                    11367   ; OS_EXIT_CRITICAL();
00003B1E  46DF      11368          dc.w      18143
                    11369   ; return (OS_ERR_NONE);
00003B20  4200      11370          clr.b     D0
                    11371   OSQQuery_3:
00003B22  4CDF 003C 11372          movem.l   (A7)+,D2/D3/D4/D5
00003B26  4E5E      11373          unlk      A6
00003B28  4E75      11374          rts
                    11375   ; }
                    11376   ; #endif                                                 /* OS_Q_QUERY_EN                                */
                    11377   ; /*$PAGE*/
                    11378   ; /*
                    11379   ; *********************************************************************************************************
                    11380   ; *                                     QUEUE MODULE INITIALIZATION
                    11381   ; *
                    11382   ; * Description : This function is called by uC/OS-II to initialize the message queue module.  Your
                    11383   ; *               application MUST NOT call this function.
                    11384   ; *
                    11385   ; * Arguments   :  none
                    11386   ; *
                    11387   ; * Returns     : none
                    11388   ; *
                    11389   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    11390   ; *********************************************************************************************************
                    11391   ; */
                    11392   ; void  OS_QInit (void)
                    11393   ; {
                    11394   _OS_QInit:
00003B2A  4E56 FFF8 11395          link      A6,#-8
00003B2E  48E7 3020 11396          movem.l   D2/D3/A2,-(A7)
00003B32  45F9 0080 11397          lea       _OSQTbl.L,A2
00003B36  0C54      
                    11398   ; #if OS_MAX_QS == 1u
                    11399   ; OSQFreeList         = &OSQTbl[0];                /* Only ONE queue!                                */
                    11400   ; OSQFreeList->OSQPtr = (OS_Q *)0;
                    11401   ; #endif
                    11402   ; #if OS_MAX_QS >= 2u
                    11403   ; INT16U   ix;
                    11404   ; INT16U   ix_next;
                    11405   ; OS_Q    *pq1;
                    11406   ; OS_Q    *pq2;
                    11407   ; OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
00003B38  4878 0060 11408          pea       96
00003B3C  2F0A      11409          move.l    A2,-(A7)
00003B3E  4EB8 13AC 11410          jsr       _OS_MemClr
00003B42  504F      11411          addq.w    #8,A7
                    11412   ; for (ix = 0u; ix < (OS_MAX_QS - 1u); ix++) {     /* Init. list of free QUEUE control blocks        */
00003B44  4242      11413          clr.w     D2
                    11414   OS_QInit_1:
00003B46  0C42 0003 11415          cmp.w     #3,D2
00003B4A  6400 003C 11416          bhs       OS_QInit_3
                    11417   ; ix_next = ix + 1u;
00003B4E  3002      11418          move.w    D2,D0
00003B50  5240      11419          addq.w    #1,D0
00003B52  3D40 FFFA 11420          move.w    D0,-6(A6)
                    11421   ; pq1 = &OSQTbl[ix];
00003B56  200A      11422          move.l    A2,D0
00003B58  C4BC 0000 11423          and.l     #65535,D2
00003B5C  FFFF      
00003B5E  2202      11424          move.l    D2,D1
00003B60  C3FC 0018 11425          muls      #24,D1
00003B64  D081      11426          add.l     D1,D0
00003B66  2600      11427          move.l    D0,D3
                    11428   ; pq2 = &OSQTbl[ix_next];
00003B68  200A      11429          move.l    A2,D0
00003B6A  322E FFFA 11430          move.w    -6(A6),D1
00003B6E  C2BC 0000 11431          and.l     #65535,D1
00003B72  FFFF      
00003B74  C3FC 0018 11432          muls      #24,D1
00003B78  D081      11433          add.l     D1,D0
00003B7A  2D40 FFFC 11434          move.l    D0,-4(A6)
                    11435   ; pq1->OSQPtr = pq2;
00003B7E  2043      11436          move.l    D3,A0
00003B80  20AE FFFC 11437          move.l    -4(A6),(A0)
00003B84  5242      11438          addq.w    #1,D2
00003B86  60BE      11439          bra       OS_QInit_1
                    11440   OS_QInit_3:
                    11441   ; }
                    11442   ; pq1         = &OSQTbl[ix];
00003B88  200A      11443          move.l    A2,D0
00003B8A  C4BC 0000 11444          and.l     #65535,D2
00003B8E  FFFF      
00003B90  2202      11445          move.l    D2,D1
00003B92  C3FC 0018 11446          muls      #24,D1
00003B96  D081      11447          add.l     D1,D0
00003B98  2600      11448          move.l    D0,D3
                    11449   ; pq1->OSQPtr = (OS_Q *)0;
00003B9A  2043      11450          move.l    D3,A0
00003B9C  4290      11451          clr.l     (A0)
                    11452   ; OSQFreeList = &OSQTbl[0];
00003B9E  23CA 0080 11453          move.l    A2,_OSQFreeList.L
00003BA2  0C50      
00003BA4  4CDF 040C 11454          movem.l   (A7)+,D2/D3/A2
00003BA8  4E5E      11455          unlk      A6
00003BAA  4E75      11456          rts
                    11457   ; /*
                    11458   ; *********************************************************************************************************
                    11459   ; *                                                uC/OS-II
                    11460   ; *                                          The Real-Time Kernel
                    11461   ; *                                          SEMAPHORE MANAGEMENT
                    11462   ; *
                    11463   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    11464   ; *                                           All Rights Reserved
                    11465   ; *
                    11466   ; * File    : OS_SEM.C
                    11467   ; * By      : Jean J. Labrosse
                    11468   ; * Version : V2.92.07
                    11469   ; *
                    11470   ; * LICENSING TERMS:
                    11471   ; * ---------------
                    11472   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    11473   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    11474   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    11475   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    11476   ; * licensing fee.
                    11477   ; *********************************************************************************************************
                    11478   ; */
                    11479   ; #define  MICRIUM_SOURCE
                    11480   ; #ifndef  OS_MASTER_FILE
                    11481   ; #include <ucos_ii.h>
                    11482   ; #endif
                    11483   ; #if OS_SEM_EN > 0u
                    11484   ; /*$PAGE*/
                    11485   ; /*
                    11486   ; *********************************************************************************************************
                    11487   ; *                                          ACCEPT SEMAPHORE
                    11488   ; *
                    11489   ; * Description: This function checks the semaphore to see if a resource is available or, if an event
                    11490   ; *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
                    11491   ; *              resource is not available or the event did not occur.
                    11492   ; *
                    11493   ; * Arguments  : pevent     is a pointer to the event control block
                    11494   ; *
                    11495   ; * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
                    11496   ; *                         decremented to obtain the resource.
                    11497   ; *              == 0       if the resource is not available or the event did not occur or,
                    11498   ; *                         if 'pevent' is a NULL pointer or,
                    11499   ; *                         if you didn't pass a pointer to a semaphore
                    11500   ; *********************************************************************************************************
                    11501   ; */
                    11502   ; #if OS_SEM_ACCEPT_EN > 0u
                    11503   ; INT16U  OSSemAccept (OS_EVENT *pevent)
                    11504   ; {
                    11505   _OSSemAccept:
00003BAC  4E56 0000 11506          link      A6,#0
00003BB0  48E7 3000 11507          movem.l   D2/D3,-(A7)
00003BB4  262E 0008 11508          move.l    8(A6),D3
                    11509   ; INT16U     cnt;
                    11510   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11511   ; OS_CPU_SR  cpu_sr = 0u;
                    11512   ; #endif
                    11513   ; #if OS_ARG_CHK_EN > 0u
                    11514   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11515   ; return (0u);
                    11516   ; }
                    11517   ; #endif
                    11518   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00003BB8  2043      11519          move.l    D3,A0
00003BBA  1010      11520          move.b    (A0),D0
00003BBC  0C00 0003 11521          cmp.b     #3,D0
00003BC0  6704      11522          beq.s     OSSemAccept_1
                    11523   ; return (0u);
00003BC2  4240      11524          clr.w     D0
00003BC4  601E      11525          bra.s     OSSemAccept_3
                    11526   OSSemAccept_1:
                    11527   ; }
                    11528   ; OS_ENTER_CRITICAL();
00003BC6  40E7      11529          dc.w      16615
00003BC8  007C      11530          dc.w      124
00003BCA  0700      11531          dc.w      1792
                    11532   ; cnt = pevent->OSEventCnt;
00003BCC  2043      11533          move.l    D3,A0
00003BCE  3428 0006 11534          move.w    6(A0),D2
                    11535   ; if (cnt > 0u) {                                   /* See if resource is available                  */
00003BD2  0C42 0000 11536          cmp.w     #0,D2
00003BD6  6308      11537          bls.s     OSSemAccept_4
                    11538   ; pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
00003BD8  2003      11539          move.l    D3,D0
00003BDA  5C80      11540          addq.l    #6,D0
00003BDC  2040      11541          move.l    D0,A0
00003BDE  5350      11542          subq.w    #1,(A0)
                    11543   OSSemAccept_4:
                    11544   ; }
                    11545   ; OS_EXIT_CRITICAL();
00003BE0  46DF      11546          dc.w      18143
                    11547   ; return (cnt);                                     /* Return semaphore count                        */
00003BE2  3002      11548          move.w    D2,D0
                    11549   OSSemAccept_3:
00003BE4  4CDF 000C 11550          movem.l   (A7)+,D2/D3
00003BE8  4E5E      11551          unlk      A6
00003BEA  4E75      11552          rts
                    11553   ; }
                    11554   ; #endif
                    11555   ; /*$PAGE*/
                    11556   ; /*
                    11557   ; *********************************************************************************************************
                    11558   ; *                                         CREATE A SEMAPHORE
                    11559   ; *
                    11560   ; * Description: This function creates a semaphore.
                    11561   ; *
                    11562   ; * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
                    11563   ; *                            available (or no event has occurred).  You initialize the semaphore to a
                    11564   ; *                            non-zero value to specify how many resources are available (e.g. if you have
                    11565   ; *                            10 resources, you would initialize the semaphore to 10).
                    11566   ; *
                    11567   ; * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
                    11568   ; *                            created semaphore
                    11569   ; *              == (void *)0  if no event control blocks were available
                    11570   ; *********************************************************************************************************
                    11571   ; */
                    11572   ; OS_EVENT  *OSSemCreate (INT16U cnt)
                    11573   ; {
                    11574   _OSSemCreate:
00003BEC  4E56 0000 11575          link      A6,#0
00003BF0  48E7 2020 11576          movem.l   D2/A2,-(A7)
00003BF4  45F9 0080 11577          lea       _OSEventFreeList.L,A2
00003BF8  001A      
                    11578   ; OS_EVENT  *pevent;
                    11579   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11580   ; OS_CPU_SR  cpu_sr = 0u;
                    11581   ; #endif
                    11582   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    11583   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    11584   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11585   ; return ((OS_EVENT *)0);
                    11586   ; }
                    11587   ; #endif
                    11588   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003BFA  1039 0080 11589          move.b    _OSIntNesting.L,D0
00003BFE  0246      
00003C00  0C00 0000 11590          cmp.b     #0,D0
00003C04  6306      11591          bls.s     OSSemCreate_1
                    11592   ; return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00003C06  4280      11593          clr.l     D0
00003C08  6000 0044 11594          bra       OSSemCreate_3
                    11595   OSSemCreate_1:
                    11596   ; }
                    11597   ; OS_ENTER_CRITICAL();
00003C0C  40E7      11598          dc.w      16615
00003C0E  007C      11599          dc.w      124
00003C10  0700      11600          dc.w      1792
                    11601   ; pevent = OSEventFreeList;                              /* Get next free event control block        */
00003C12  2412      11602          move.l    (A2),D2
                    11603   ; if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
00003C14  2012      11604          move.l    (A2),D0
00003C16  6706      11605          beq.s     OSSemCreate_4
                    11606   ; OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
00003C18  2052      11607          move.l    (A2),A0
00003C1A  24A8 0002 11608          move.l    2(A0),(A2)
                    11609   OSSemCreate_4:
                    11610   ; }
                    11611   ; OS_EXIT_CRITICAL();
00003C1E  46DF      11612          dc.w      18143
                    11613   ; if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
00003C20  4A82      11614          tst.l     D2
00003C22  6728      11615          beq.s     OSSemCreate_6
                    11616   ; pevent->OSEventType    = OS_EVENT_TYPE_SEM;
00003C24  2042      11617          move.l    D2,A0
00003C26  10BC 0003 11618          move.b    #3,(A0)
                    11619   ; pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
00003C2A  2042      11620          move.l    D2,A0
00003C2C  316E 000A 11621          move.w    10(A6),6(A0)
00003C30  0006      
                    11622   ; pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
00003C32  2042      11623          move.l    D2,A0
00003C34  42A8 0002 11624          clr.l     2(A0)
                    11625   ; #if OS_EVENT_NAME_EN > 0u
                    11626   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003C38  41F9 0000 11627          lea       @ucos_ii_1.L,A0
00003C3C  5A8E      
00003C3E  2242      11628          move.l    D2,A1
00003C40  2348 0012 11629          move.l    A0,18(A1)
                    11630   ; #endif
                    11631   ; OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
00003C44  2F02      11632          move.l    D2,-(A7)
00003C46  4EB8 10E0 11633          jsr       _OS_EventWaitListInit
00003C4A  584F      11634          addq.w    #4,A7
                    11635   OSSemCreate_6:
                    11636   ; }
                    11637   ; return (pevent);
00003C4C  2002      11638          move.l    D2,D0
                    11639   OSSemCreate_3:
00003C4E  4CDF 0404 11640          movem.l   (A7)+,D2/A2
00003C52  4E5E      11641          unlk      A6
00003C54  4E75      11642          rts
                    11643   ; }
                    11644   ; /*$PAGE*/
                    11645   ; /*
                    11646   ; *********************************************************************************************************
                    11647   ; *                                         DELETE A SEMAPHORE
                    11648   ; *
                    11649   ; * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
                    11650   ; *
                    11651   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    11652   ; *                            semaphore.
                    11653   ; *
                    11654   ; *              opt           determines delete options as follows:
                    11655   ; *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
                    11656   ; *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
                    11657   ; *                                                    In this case, all the tasks pending will be readied.
                    11658   ; *
                    11659   ; *              perr          is a pointer to an error code that can contain one of the following values:
                    11660   ; *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
                    11661   ; *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
                    11662   ; *                            OS_ERR_INVALID_OPT      An invalid option was specified
                    11663   ; *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
                    11664   ; *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
                    11665   ; *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
                    11666   ; *
                    11667   ; * Returns    : pevent        upon error
                    11668   ; *              (OS_EVENT *)0 if the semaphore was successfully deleted.
                    11669   ; *
                    11670   ; * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
                    11671   ; *                 the semaphore MUST check the return code of OSSemPend().
                    11672   ; *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
                    11673   ; *                 they check 'pevent' to see that it's a NULL pointer.
                    11674   ; *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
                    11675   ; *                 time is directly proportional to the number of tasks waiting on the semaphore.
                    11676   ; *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
                    11677   ; *                 applications where the semaphore is used for mutual exclusion because the resource(s)
                    11678   ; *                 will no longer be guarded by the semaphore.
                    11679   ; *              5) All tasks that were waiting for the semaphore will be readied and returned an 
                    11680   ; *                 OS_ERR_PEND_ABORT if OSSemDel() was called with OS_DEL_ALWAYS
                    11681   ; *********************************************************************************************************
                    11682   ; */
                    11683   ; #if OS_SEM_DEL_EN > 0u
                    11684   ; OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
                    11685   ; INT8U      opt,
                    11686   ; INT8U     *perr)
                    11687   ; {
                    11688   _OSSemDel:
00003C56  4E56 0000 11689          link      A6,#0
00003C5A  48E7 3C20 11690          movem.l   D2/D3/D4/D5/A2,-(A7)
00003C5E  242E 0008 11691          move.l    8(A6),D2
00003C62  262E 0010 11692          move.l    16(A6),D3
00003C66  45F9 0080 11693          lea       _OSEventFreeList.L,A2
00003C6A  001A      
                    11694   ; BOOLEAN    tasks_waiting;
                    11695   ; OS_EVENT  *pevent_return;
                    11696   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    11697   ; OS_CPU_SR  cpu_sr = 0u;
                    11698   ; #endif
                    11699   ; #ifdef OS_SAFETY_CRITICAL
                    11700   ; if (perr == (INT8U *)0) {
                    11701   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11702   ; return ((OS_EVENT *)0);
                    11703   ; }
                    11704   ; #endif
                    11705   ; #if OS_ARG_CHK_EN > 0u
                    11706   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    11707   ; *perr = OS_ERR_PEVENT_NULL;
                    11708   ; return (pevent);
                    11709   ; }
                    11710   ; #endif
                    11711   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00003C6C  2042      11712          move.l    D2,A0
00003C6E  1010      11713          move.b    (A0),D0
00003C70  0C00 0003 11714          cmp.b     #3,D0
00003C74  670C      11715          beq.s     OSSemDel_1
                    11716   ; *perr = OS_ERR_EVENT_TYPE;
00003C76  2043      11717          move.l    D3,A0
00003C78  10BC 0001 11718          move.b    #1,(A0)
                    11719   ; return (pevent);
00003C7C  2002      11720          move.l    D2,D0
00003C7E  6000 00EA 11721          bra       OSSemDel_3
                    11722   OSSemDel_1:
                    11723   ; }
                    11724   ; if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
00003C82  1039 0080 11725          move.b    _OSIntNesting.L,D0
00003C86  0246      
00003C88  0C00 0000 11726          cmp.b     #0,D0
00003C8C  630C      11727          bls.s     OSSemDel_4
                    11728   ; *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
00003C8E  2043      11729          move.l    D3,A0
00003C90  10BC 000F 11730          move.b    #15,(A0)
                    11731   ; return (pevent);
00003C94  2002      11732          move.l    D2,D0
00003C96  6000 00D2 11733          bra       OSSemDel_3
                    11734   OSSemDel_4:
                    11735   ; }
                    11736   ; OS_ENTER_CRITICAL();
00003C9A  40E7      11737          dc.w      16615
00003C9C  007C      11738          dc.w      124
00003C9E  0700      11739          dc.w      1792
                    11740   ; if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
00003CA0  2042      11741          move.l    D2,A0
00003CA2  1028 0008 11742          move.b    8(A0),D0
00003CA6  6704      11743          beq.s     OSSemDel_6
                    11744   ; tasks_waiting = OS_TRUE;                           /* Yes                                      */
00003CA8  7A01      11745          moveq     #1,D5
00003CAA  6002      11746          bra.s     OSSemDel_7
                    11747   OSSemDel_6:
                    11748   ; } else {
                    11749   ; tasks_waiting = OS_FALSE;                          /* No                                       */
00003CAC  4205      11750          clr.b     D5
                    11751   OSSemDel_7:
                    11752   ; }
                    11753   ; switch (opt) {
00003CAE  102E 000F 11754          move.b    15(A6),D0
00003CB2  C0BC 0000 11755          and.l     #255,D0
00003CB6  00FF      
00003CB8  0C80 0000 11756          cmp.l     #1,D0
00003CBC  0001      
00003CBE  6700 0048 11757          beq       OSSemDel_11
00003CC2  6200 009A 11758          bhi       OSSemDel_8
00003CC6  4A80      11759          tst.l     D0
00003CC8  6704      11760          beq.s     OSSemDel_10
00003CCA  6000 0092 11761          bra       OSSemDel_8
                    11762   OSSemDel_10:
                    11763   ; case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
                    11764   ; if (tasks_waiting == OS_FALSE) {
00003CCE  4A05      11765          tst.b     D5
00003CD0  6628      11766          bne.s     OSSemDel_13
                    11767   ; #if OS_EVENT_NAME_EN > 0u
                    11768   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003CD2  41F9 0000 11769          lea       @ucos_ii_1.L,A0
00003CD6  5A8E      
00003CD8  2242      11770          move.l    D2,A1
00003CDA  2348 0012 11771          move.l    A0,18(A1)
                    11772   ; #endif
                    11773   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003CDE  2042      11774          move.l    D2,A0
00003CE0  4210      11775          clr.b     (A0)
                    11776   ; pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
00003CE2  2042      11777          move.l    D2,A0
00003CE4  2152 0002 11778          move.l    (A2),2(A0)
                    11779   ; pevent->OSEventCnt     = 0u;
00003CE8  2042      11780          move.l    D2,A0
00003CEA  4268 0006 11781          clr.w     6(A0)
                    11782   ; OSEventFreeList        = pevent;          /* Get next free event control block        */
00003CEE  2482      11783          move.l    D2,(A2)
                    11784   ; OS_EXIT_CRITICAL();
00003CF0  46DF      11785          dc.w      18143
                    11786   ; *perr                  = OS_ERR_NONE;
00003CF2  2043      11787          move.l    D3,A0
00003CF4  4210      11788          clr.b     (A0)
                    11789   ; pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
00003CF6  4284      11790          clr.l     D4
00003CF8  600A      11791          bra.s     OSSemDel_14
                    11792   OSSemDel_13:
                    11793   ; } else {
                    11794   ; OS_EXIT_CRITICAL();
00003CFA  46DF      11795          dc.w      18143
                    11796   ; *perr                  = OS_ERR_TASK_WAITING;
00003CFC  2043      11797          move.l    D3,A0
00003CFE  10BC 0049 11798          move.b    #73,(A0)
                    11799   ; pevent_return          = pevent;
00003D02  2802      11800          move.l    D2,D4
                    11801   OSSemDel_14:
                    11802   ; }
                    11803   ; break;
00003D04  6000 0062 11804          bra       OSSemDel_9
                    11805   OSSemDel_11:
                    11806   ; case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
                    11807   ; while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
                    11808   OSSemDel_15:
00003D08  2042      11809          move.l    D2,A0
00003D0A  1028 0008 11810          move.b    8(A0),D0
00003D0E  671C      11811          beq.s     OSSemDel_17
                    11812   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00003D10  4878 0002 11813          pea       2
00003D14  4878 0001 11814          pea       1
00003D18  42A7      11815          clr.l     -(A7)
00003D1A  2F02      11816          move.l    D2,-(A7)
00003D1C  4EB8 0E18 11817          jsr       _OS_EventTaskRdy
00003D20  DEFC 0010 11818          add.w     #16,A7
00003D24  C0BC 0000 11819          and.l     #255,D0
00003D28  00FF      
00003D2A  60DC      11820          bra       OSSemDel_15
                    11821   OSSemDel_17:
                    11822   ; }
                    11823   ; #if OS_EVENT_NAME_EN > 0u
                    11824   ; pevent->OSEventName    = (INT8U *)(void *)"?";
00003D2C  41F9 0000 11825          lea       @ucos_ii_1.L,A0
00003D30  5A8E      
00003D32  2242      11826          move.l    D2,A1
00003D34  2348 0012 11827          move.l    A0,18(A1)
                    11828   ; #endif
                    11829   ; pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
00003D38  2042      11830          move.l    D2,A0
00003D3A  4210      11831          clr.b     (A0)
                    11832   ; pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
00003D3C  2042      11833          move.l    D2,A0
00003D3E  2152 0002 11834          move.l    (A2),2(A0)
                    11835   ; pevent->OSEventCnt     = 0u;
00003D42  2042      11836          move.l    D2,A0
00003D44  4268 0006 11837          clr.w     6(A0)
                    11838   ; OSEventFreeList        = pevent;              /* Get next free event control block        */
00003D48  2482      11839          move.l    D2,(A2)
                    11840   ; OS_EXIT_CRITICAL();
00003D4A  46DF      11841          dc.w      18143
                    11842   ; if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
00003D4C  0C05 0001 11843          cmp.b     #1,D5
00003D50  6604      11844          bne.s     OSSemDel_18
                    11845   ; OS_Sched();                               /* Find highest priority task ready to run  */
00003D52  4EB8 13F8 11846          jsr       _OS_Sched
                    11847   OSSemDel_18:
                    11848   ; }
                    11849   ; *perr                  = OS_ERR_NONE;
00003D56  2043      11850          move.l    D3,A0
00003D58  4210      11851          clr.b     (A0)
                    11852   ; pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
00003D5A  4284      11853          clr.l     D4
                    11854   ; break;
00003D5C  600A      11855          bra.s     OSSemDel_9
                    11856   OSSemDel_8:
                    11857   ; default:
                    11858   ; OS_EXIT_CRITICAL();
00003D5E  46DF      11859          dc.w      18143
                    11860   ; *perr                  = OS_ERR_INVALID_OPT;
00003D60  2043      11861          move.l    D3,A0
00003D62  10BC 0007 11862          move.b    #7,(A0)
                    11863   ; pevent_return          = pevent;
00003D66  2802      11864          move.l    D2,D4
                    11865   ; break;
                    11866   OSSemDel_9:
                    11867   ; }
                    11868   ; return (pevent_return);
00003D68  2004      11869          move.l    D4,D0
                    11870   OSSemDel_3:
00003D6A  4CDF 043C 11871          movem.l   (A7)+,D2/D3/D4/D5/A2
00003D6E  4E5E      11872          unlk      A6
00003D70  4E75      11873          rts
                    11874   ; }
                    11875   ; #endif
                    11876   ; /*$PAGE*/
                    11877   ; /*
                    11878   ; *********************************************************************************************************
                    11879   ; *                                          PEND ON SEMAPHORE
                    11880   ; *
                    11881   ; * Description: This function waits for a semaphore.
                    11882   ; *
                    11883   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    11884   ; *                            semaphore.
                    11885   ; *
                    11886   ; *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
                    11887   ; *                            wait for the resource up to the amount of time specified by this argument.
                    11888   ; *                            If you specify 0, however, your task will wait forever at the specified
                    11889   ; *                            semaphore or, until the resource becomes available (or the event occurs).
                    11890   ; *
                    11891   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    11892   ; *                            messages are:
                    11893   ; *
                    11894   ; *                            OS_ERR_NONE         The call was successful and your task owns the resource
                    11895   ; *                                                or, the event you are waiting for occurred.
                    11896   ; *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
                    11897   ; *                                                'timeout'.
                    11898   ; *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
                    11899   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    11900   ; *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
                    11901   ; *                                                would lead to a suspension.
                    11902   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    11903   ; *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
                    11904   ; *
                    11905   ; * Returns    : none
                    11906   ; *********************************************************************************************************
                    11907   ; */
                    11908   ; /*$PAGE*/
                    11909   ; void  OSSemPend (OS_EVENT  *pevent,
                    11910   ; INT32U     timeout,
                    11911   ; INT8U     *perr)
                    11912   ; {
                    11913   _OSSemPend:
00003D72  4E56 0000 11914          link      A6,#0
00003D76  48E7 3020 11915          movem.l   D2/D3/A2,-(A7)
00003D7A  45F9 0080 11916          lea       _OSTCBCur.L,A2
00003D7E  0360      
00003D80  242E 0010 11917          move.l    16(A6),D2
00003D84  262E 0008 11918          move.l    8(A6),D3
                    11919   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    11920   ; OS_CPU_SR  cpu_sr = 0u;
                    11921   ; #endif
                    11922   ; #ifdef OS_SAFETY_CRITICAL
                    11923   ; if (perr == (INT8U *)0) {
                    11924   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    11925   ; return;
                    11926   ; }
                    11927   ; #endif
                    11928   ; #if OS_ARG_CHK_EN > 0u
                    11929   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    11930   ; *perr = OS_ERR_PEVENT_NULL;
                    11931   ; return;
                    11932   ; }
                    11933   ; #endif
                    11934   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00003D88  2043      11935          move.l    D3,A0
00003D8A  1010      11936          move.b    (A0),D0
00003D8C  0C00 0003 11937          cmp.b     #3,D0
00003D90  670A      11938          beq.s     OSSemPend_1
                    11939   ; *perr = OS_ERR_EVENT_TYPE;
00003D92  2042      11940          move.l    D2,A0
00003D94  10BC 0001 11941          move.b    #1,(A0)
                    11942   ; return;
00003D98  6000 00DA 11943          bra       OSSemPend_3
                    11944   OSSemPend_1:
                    11945   ; }
                    11946   ; if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
00003D9C  1039 0080 11947          move.b    _OSIntNesting.L,D0
00003DA0  0246      
00003DA2  0C00 0000 11948          cmp.b     #0,D0
00003DA6  630A      11949          bls.s     OSSemPend_4
                    11950   ; *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
00003DA8  2042      11951          move.l    D2,A0
00003DAA  10BC 0002 11952          move.b    #2,(A0)
                    11953   ; return;
00003DAE  6000 00C4 11954          bra       OSSemPend_3
                    11955   OSSemPend_4:
                    11956   ; }
                    11957   ; if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
00003DB2  1039 0080 11958          move.b    _OSLockNesting.L,D0
00003DB6  0248      
00003DB8  0C00 0000 11959          cmp.b     #0,D0
00003DBC  630A      11960          bls.s     OSSemPend_6
                    11961   ; *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
00003DBE  2042      11962          move.l    D2,A0
00003DC0  10BC 000D 11963          move.b    #13,(A0)
                    11964   ; return;
00003DC4  6000 00AE 11965          bra       OSSemPend_3
                    11966   OSSemPend_6:
                    11967   ; }
                    11968   ; OS_ENTER_CRITICAL();
00003DC8  40E7      11969          dc.w      16615
00003DCA  007C      11970          dc.w      124
00003DCC  0700      11971          dc.w      1792
                    11972   ; if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
00003DCE  2043      11973          move.l    D3,A0
00003DD0  3028 0006 11974          move.w    6(A0),D0
00003DD4  0C40 0000 11975          cmp.w     #0,D0
00003DD8  6312      11976          bls.s     OSSemPend_8
                    11977   ; pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
00003DDA  2003      11978          move.l    D3,D0
00003DDC  5C80      11979          addq.l    #6,D0
00003DDE  2040      11980          move.l    D0,A0
00003DE0  5350      11981          subq.w    #1,(A0)
                    11982   ; OS_EXIT_CRITICAL();
00003DE2  46DF      11983          dc.w      18143
                    11984   ; *perr = OS_ERR_NONE;
00003DE4  2042      11985          move.l    D2,A0
00003DE6  4210      11986          clr.b     (A0)
                    11987   ; return;
00003DE8  6000 008A 11988          bra       OSSemPend_3
                    11989   OSSemPend_8:
                    11990   ; }
                    11991   ; /* Otherwise, must wait until event occurs       */
                    11992   ; OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
00003DEC  2052      11993          move.l    (A2),A0
00003DEE  0028 0001 11994          or.b      #1,50(A0)
00003DF2  0032      
                    11995   ; OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
00003DF4  2052      11996          move.l    (A2),A0
00003DF6  4228 0033 11997          clr.b     51(A0)
                    11998   ; OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
00003DFA  2052      11999          move.l    (A2),A0
00003DFC  216E 000C 12000          move.l    12(A6),46(A0)
00003E00  002E      
                    12001   ; OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
00003E02  2F03      12002          move.l    D3,-(A7)
00003E04  4EB8 0EFC 12003          jsr       _OS_EventTaskWait
00003E08  584F      12004          addq.w    #4,A7
                    12005   ; OS_EXIT_CRITICAL();
00003E0A  46DF      12006          dc.w      18143
                    12007   ; OS_Sched();                                       /* Find next highest priority task ready         */
00003E0C  4EB8 13F8 12008          jsr       _OS_Sched
                    12009   ; OS_ENTER_CRITICAL();
00003E10  40E7      12010          dc.w      16615
00003E12  007C      12011          dc.w      124
00003E14  0700      12012          dc.w      1792
                    12013   ; switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
00003E16  2052      12014          move.l    (A2),A0
00003E18  1028 0033 12015          move.b    51(A0),D0
00003E1C  C0BC 0000 12016          and.l     #255,D0
00003E20  00FF      
00003E22  0C80 0000 12017          cmp.l     #1,D0
00003E26  0001      
00003E28  6720      12018          beq.s     OSSemPend_14
00003E2A  6206      12019          bhi.s     OSSemPend_16
00003E2C  4A80      12020          tst.l     D0
00003E2E  670C      12021          beq.s     OSSemPend_12
00003E30  6018      12022          bra.s     OSSemPend_14
                    12023   OSSemPend_16:
00003E32  0C80 0000 12024          cmp.l     #2,D0
00003E36  0002      
00003E38  6708      12025          beq.s     OSSemPend_13
00003E3A  600E      12026          bra.s     OSSemPend_14
                    12027   OSSemPend_12:
                    12028   ; case OS_STAT_PEND_OK:
                    12029   ; *perr = OS_ERR_NONE;
00003E3C  2042      12030          move.l    D2,A0
00003E3E  4210      12031          clr.b     (A0)
                    12032   ; break;
00003E40  6018      12033          bra.s     OSSemPend_11
                    12034   OSSemPend_13:
                    12035   ; case OS_STAT_PEND_ABORT:
                    12036   ; *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
00003E42  2042      12037          move.l    D2,A0
00003E44  10BC 000E 12038          move.b    #14,(A0)
                    12039   ; break;
00003E48  6010      12040          bra.s     OSSemPend_11
                    12041   OSSemPend_14:
                    12042   ; case OS_STAT_PEND_TO:
                    12043   ; default:
                    12044   ; OS_EventTaskRemove(OSTCBCur, pevent);
00003E4A  2F03      12045          move.l    D3,-(A7)
00003E4C  2F12      12046          move.l    (A2),-(A7)
00003E4E  4EB8 101E 12047          jsr       _OS_EventTaskRemove
00003E52  504F      12048          addq.w    #8,A7
                    12049   ; *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
00003E54  2042      12050          move.l    D2,A0
00003E56  10BC 000A 12051          move.b    #10,(A0)
                    12052   ; break;
                    12053   OSSemPend_11:
                    12054   ; }
                    12055   ; OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
00003E5A  2052      12056          move.l    (A2),A0
00003E5C  4228 0032 12057          clr.b     50(A0)
                    12058   ; OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
00003E60  2052      12059          move.l    (A2),A0
00003E62  4228 0033 12060          clr.b     51(A0)
                    12061   ; OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
00003E66  2052      12062          move.l    (A2),A0
00003E68  42A8 001C 12063          clr.l     28(A0)
                    12064   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12065   ; OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
00003E6C  2052      12066          move.l    (A2),A0
00003E6E  42A8 0020 12067          clr.l     32(A0)
                    12068   ; #endif
                    12069   ; OS_EXIT_CRITICAL();
00003E72  46DF      12070          dc.w      18143
                    12071   OSSemPend_3:
00003E74  4CDF 040C 12072          movem.l   (A7)+,D2/D3/A2
00003E78  4E5E      12073          unlk      A6
00003E7A  4E75      12074          rts
                    12075   ; }
                    12076   ; /*$PAGE*/
                    12077   ; /*
                    12078   ; *********************************************************************************************************
                    12079   ; *                                    ABORT WAITING ON A SEMAPHORE
                    12080   ; *
                    12081   ; * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
                    12082   ; *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
                    12083   ; *              the semaphore via OSSemPost().
                    12084   ; *
                    12085   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12086   ; *                            semaphore.
                    12087   ; *
                    12088   ; *              opt           determines the type of ABORT performed:
                    12089   ; *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
                    12090   ; *                                                     semaphore
                    12091   ; *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
                    12092   ; *                                                     semaphore
                    12093   ; *
                    12094   ; *              perr          is a pointer to where an error message will be deposited.  Possible error
                    12095   ; *                            messages are:
                    12096   ; *
                    12097   ; *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
                    12098   ; *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
                    12099   ; *                                                and informed of the aborted wait; check return value
                    12100   ; *                                                for the number of tasks whose wait on the semaphore
                    12101   ; *                                                was aborted.
                    12102   ; *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
                    12103   ; *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12104   ; *
                    12105   ; * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
                    12106   ; *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
                    12107   ; *********************************************************************************************************
                    12108   ; */
                    12109   ; #if OS_SEM_PEND_ABORT_EN > 0u
                    12110   ; INT8U  OSSemPendAbort (OS_EVENT  *pevent,
                    12111   ; INT8U      opt,
                    12112   ; INT8U     *perr)
                    12113   ; {
                    12114   _OSSemPendAbort:
00003E7C  4E56 0000 12115          link      A6,#0
00003E80  48E7 3800 12116          movem.l   D2/D3/D4,-(A7)
00003E84  242E 0008 12117          move.l    8(A6),D2
00003E88  282E 0010 12118          move.l    16(A6),D4
                    12119   ; INT8U      nbr_tasks;
                    12120   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12121   ; OS_CPU_SR  cpu_sr = 0u;
                    12122   ; #endif
                    12123   ; #ifdef OS_SAFETY_CRITICAL
                    12124   ; if (perr == (INT8U *)0) {
                    12125   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12126   ; return (0u);
                    12127   ; }
                    12128   ; #endif
                    12129   ; #if OS_ARG_CHK_EN > 0u
                    12130   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12131   ; *perr = OS_ERR_PEVENT_NULL;
                    12132   ; return (0u);
                    12133   ; }
                    12134   ; #endif
                    12135   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00003E8C  2042      12136          move.l    D2,A0
00003E8E  1010      12137          move.b    (A0),D0
00003E90  0C00 0003 12138          cmp.b     #3,D0
00003E94  670C      12139          beq.s     OSSemPendAbort_1
                    12140   ; *perr = OS_ERR_EVENT_TYPE;
00003E96  2044      12141          move.l    D4,A0
00003E98  10BC 0001 12142          move.b    #1,(A0)
                    12143   ; return (0u);
00003E9C  4200      12144          clr.b     D0
00003E9E  6000 008C 12145          bra       OSSemPendAbort_3
                    12146   OSSemPendAbort_1:
                    12147   ; }
                    12148   ; OS_ENTER_CRITICAL();
00003EA2  40E7      12149          dc.w      16615
00003EA4  007C      12150          dc.w      124
00003EA6  0700      12151          dc.w      1792
                    12152   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
00003EA8  2042      12153          move.l    D2,A0
00003EAA  1028 0008 12154          move.b    8(A0),D0
00003EAE  6700 0074 12155          beq       OSSemPendAbort_4
                    12156   ; nbr_tasks = 0u;
00003EB2  4203      12157          clr.b     D3
                    12158   ; switch (opt) {
00003EB4  102E 000F 12159          move.b    15(A6),D0
00003EB8  C0BC 0000 12160          and.l     #255,D0
00003EBC  00FF      
00003EBE  0C80 0000 12161          cmp.l     #1,D0
00003EC2  0001      
00003EC4  670A      12162          beq.s     OSSemPendAbort_8
00003EC6  6200 0030 12163          bhi       OSSemPendAbort_9
00003ECA  4A80      12164          tst.l     D0
00003ECC  672A      12165          beq.s     OSSemPendAbort_9
00003ECE  6028      12166          bra.s     OSSemPendAbort_9
                    12167   OSSemPendAbort_8:
                    12168   ; case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                    12169   ; while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
                    12170   OSSemPendAbort_11:
00003ED0  2042      12171          move.l    D2,A0
00003ED2  1028 0008 12172          move.b    8(A0),D0
00003ED6  671E      12173          beq.s     OSSemPendAbort_13
                    12174   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00003ED8  4878 0002 12175          pea       2
00003EDC  4878 0001 12176          pea       1
00003EE0  42A7      12177          clr.l     -(A7)
00003EE2  2F02      12178          move.l    D2,-(A7)
00003EE4  4EB8 0E18 12179          jsr       _OS_EventTaskRdy
00003EE8  DEFC 0010 12180          add.w     #16,A7
00003EEC  C0BC 0000 12181          and.l     #255,D0
00003EF0  00FF      
                    12182   ; nbr_tasks++;
00003EF2  5203      12183          addq.b    #1,D3
00003EF4  60DA      12184          bra       OSSemPendAbort_11
                    12185   OSSemPendAbort_13:
                    12186   ; }
                    12187   ; break;
00003EF6  601C      12188          bra.s     OSSemPendAbort_7
                    12189   OSSemPendAbort_9:
                    12190   ; case OS_PEND_OPT_NONE:
                    12191   ; default:                                  /* No,  ready HPT       waiting on semaphore     */
                    12192   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00003EF8  4878 0002 12193          pea       2
00003EFC  4878 0001 12194          pea       1
00003F00  42A7      12195          clr.l     -(A7)
00003F02  2F02      12196          move.l    D2,-(A7)
00003F04  4EB8 0E18 12197          jsr       _OS_EventTaskRdy
00003F08  DEFC 0010 12198          add.w     #16,A7
00003F0C  C0BC 0000 12199          and.l     #255,D0
00003F10  00FF      
                    12200   ; nbr_tasks++;
00003F12  5203      12201          addq.b    #1,D3
                    12202   ; break;
                    12203   OSSemPendAbort_7:
                    12204   ; }
                    12205   ; OS_EXIT_CRITICAL();
00003F14  46DF      12206          dc.w      18143
                    12207   ; OS_Sched();                                   /* Find HPT ready to run                         */
00003F16  4EB8 13F8 12208          jsr       _OS_Sched
                    12209   ; *perr = OS_ERR_PEND_ABORT;
00003F1A  2044      12210          move.l    D4,A0
00003F1C  10BC 000E 12211          move.b    #14,(A0)
                    12212   ; return (nbr_tasks);
00003F20  1003      12213          move.b    D3,D0
00003F22  6008      12214          bra.s     OSSemPendAbort_3
                    12215   OSSemPendAbort_4:
                    12216   ; }
                    12217   ; OS_EXIT_CRITICAL();
00003F24  46DF      12218          dc.w      18143
                    12219   ; *perr = OS_ERR_NONE;
00003F26  2044      12220          move.l    D4,A0
00003F28  4210      12221          clr.b     (A0)
                    12222   ; return (0u);                                      /* No tasks waiting on semaphore                 */
00003F2A  4200      12223          clr.b     D0
                    12224   OSSemPendAbort_3:
00003F2C  4CDF 001C 12225          movem.l   (A7)+,D2/D3/D4
00003F30  4E5E      12226          unlk      A6
00003F32  4E75      12227          rts
                    12228   ; }
                    12229   ; #endif
                    12230   ; /*$PAGE*/
                    12231   ; /*
                    12232   ; *********************************************************************************************************
                    12233   ; *                                         POST TO A SEMAPHORE
                    12234   ; *
                    12235   ; * Description: This function signals a semaphore
                    12236   ; *
                    12237   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12238   ; *                            semaphore.
                    12239   ; *
                    12240   ; * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
                    12241   ; *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit. In other words, you have
                    12242   ; *                                  signaled the semaphore more often than you waited on it with either
                    12243   ; *                                  OSSemAccept() or OSSemPend().
                    12244   ; *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
                    12245   ; *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
                    12246   ; *********************************************************************************************************
                    12247   ; */
                    12248   ; INT8U  OSSemPost (OS_EVENT *pevent)
                    12249   ; {
                    12250   _OSSemPost:
00003F34  4E56 0000 12251          link      A6,#0
00003F38  2F02      12252          move.l    D2,-(A7)
00003F3A  242E 0008 12253          move.l    8(A6),D2
                    12254   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12255   ; OS_CPU_SR  cpu_sr = 0u;
                    12256   ; #endif
                    12257   ; #if OS_ARG_CHK_EN > 0u
                    12258   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12259   ; return (OS_ERR_PEVENT_NULL);
                    12260   ; }
                    12261   ; #endif
                    12262   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00003F3E  2042      12263          move.l    D2,A0
00003F40  1010      12264          move.b    (A0),D0
00003F42  0C00 0003 12265          cmp.b     #3,D0
00003F46  6706      12266          beq.s     OSSemPost_1
                    12267   ; return (OS_ERR_EVENT_TYPE);
00003F48  7001      12268          moveq     #1,D0
00003F4A  6000 0050 12269          bra       OSSemPost_3
                    12270   OSSemPost_1:
                    12271   ; }
                    12272   ; OS_ENTER_CRITICAL();
00003F4E  40E7      12273          dc.w      16615
00003F50  007C      12274          dc.w      124
00003F52  0700      12275          dc.w      1792
                    12276   ; if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
00003F54  2042      12277          move.l    D2,A0
00003F56  1028 0008 12278          move.b    8(A0),D0
00003F5A  6722      12279          beq.s     OSSemPost_4
                    12280   ; /* Ready HPT waiting on event                    */
                    12281   ; (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
00003F5C  42A7      12282          clr.l     -(A7)
00003F5E  4878 0001 12283          pea       1
00003F62  42A7      12284          clr.l     -(A7)
00003F64  2F02      12285          move.l    D2,-(A7)
00003F66  4EB8 0E18 12286          jsr       _OS_EventTaskRdy
00003F6A  DEFC 0010 12287          add.w     #16,A7
00003F6E  C0BC 0000 12288          and.l     #255,D0
00003F72  00FF      
                    12289   ; OS_EXIT_CRITICAL();
00003F74  46DF      12290          dc.w      18143
                    12291   ; OS_Sched();                                   /* Find HPT ready to run                         */
00003F76  4EB8 13F8 12292          jsr       _OS_Sched
                    12293   ; return (OS_ERR_NONE);
00003F7A  4200      12294          clr.b     D0
00003F7C  601E      12295          bra.s     OSSemPost_3
                    12296   OSSemPost_4:
                    12297   ; }
                    12298   ; if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
00003F7E  2042      12299          move.l    D2,A0
00003F80  3028 0006 12300          move.w    6(A0),D0
00003F84  0C40 FFFF 12301          cmp.w     #65535,D0
00003F88  640E      12302          bhs.s     OSSemPost_6
                    12303   ; pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
00003F8A  2002      12304          move.l    D2,D0
00003F8C  5C80      12305          addq.l    #6,D0
00003F8E  2040      12306          move.l    D0,A0
00003F90  5250      12307          addq.w    #1,(A0)
                    12308   ; OS_EXIT_CRITICAL();
00003F92  46DF      12309          dc.w      18143
                    12310   ; return (OS_ERR_NONE);
00003F94  4200      12311          clr.b     D0
00003F96  6004      12312          bra.s     OSSemPost_3
                    12313   OSSemPost_6:
                    12314   ; }
                    12315   ; OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
00003F98  46DF      12316          dc.w      18143
                    12317   ; return (OS_ERR_SEM_OVF);
00003F9A  7033      12318          moveq     #51,D0
                    12319   OSSemPost_3:
00003F9C  241F      12320          move.l    (A7)+,D2
00003F9E  4E5E      12321          unlk      A6
00003FA0  4E75      12322          rts
                    12323   ; }
                    12324   ; /*$PAGE*/
                    12325   ; /*
                    12326   ; *********************************************************************************************************
                    12327   ; *                                          QUERY A SEMAPHORE
                    12328   ; *
                    12329   ; * Description: This function obtains information about a semaphore
                    12330   ; *
                    12331   ; * Arguments  : pevent        is a pointer to the event control block associated with the desired
                    12332   ; *                            semaphore
                    12333   ; *
                    12334   ; *              p_sem_data    is a pointer to a structure that will contain information about the
                    12335   ; *                            semaphore.
                    12336   ; *
                    12337   ; * Returns    : OS_ERR_NONE         The call was successful and the message was sent
                    12338   ; *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
                    12339   ; *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
                    12340   ; *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
                    12341   ; *********************************************************************************************************
                    12342   ; */
                    12343   ; #if OS_SEM_QUERY_EN > 0u
                    12344   ; INT8U  OSSemQuery (OS_EVENT     *pevent,
                    12345   ; OS_SEM_DATA  *p_sem_data)
                    12346   ; {
                    12347   _OSSemQuery:
00003FA2  4E56 FFF8 12348          link      A6,#-8
00003FA6  48E7 3800 12349          movem.l   D2/D3/D4,-(A7)
00003FAA  242E 0008 12350          move.l    8(A6),D2
00003FAE  282E 000C 12351          move.l    12(A6),D4
                    12352   ; INT8U       i;
                    12353   ; OS_PRIO    *psrc;
                    12354   ; OS_PRIO    *pdest;
                    12355   ; #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
                    12356   ; OS_CPU_SR   cpu_sr = 0u;
                    12357   ; #endif
                    12358   ; #if OS_ARG_CHK_EN > 0u
                    12359   ; if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                    12360   ; return (OS_ERR_PEVENT_NULL);
                    12361   ; }
                    12362   ; if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
                    12363   ; return (OS_ERR_PDATA_NULL);
                    12364   ; }
                    12365   ; #endif
                    12366   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
00003FB2  2042      12367          move.l    D2,A0
00003FB4  1010      12368          move.b    (A0),D0
00003FB6  0C00 0003 12369          cmp.b     #3,D0
00003FBA  6706      12370          beq.s     OSSemQuery_1
                    12371   ; return (OS_ERR_EVENT_TYPE);
00003FBC  7001      12372          moveq     #1,D0
00003FBE  6000 004C 12373          bra       OSSemQuery_3
                    12374   OSSemQuery_1:
                    12375   ; }
                    12376   ; OS_ENTER_CRITICAL();
00003FC2  40E7      12377          dc.w      16615
00003FC4  007C      12378          dc.w      124
00003FC6  0700      12379          dc.w      1792
                    12380   ; p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
00003FC8  2042      12381          move.l    D2,A0
00003FCA  2244      12382          move.l    D4,A1
00003FCC  1368 0008 12383          move.b    8(A0),10(A1)
00003FD0  000A      
                    12384   ; psrc                   = &pevent->OSEventTbl[0];
00003FD2  700A      12385          moveq     #10,D0
00003FD4  D082      12386          add.l     D2,D0
00003FD6  2D40 FFF8 12387          move.l    D0,-8(A6)
                    12388   ; pdest                  = &p_sem_data->OSEventTbl[0];
00003FDA  7002      12389          moveq     #2,D0
00003FDC  D084      12390          add.l     D4,D0
00003FDE  2D40 FFFC 12391          move.l    D0,-4(A6)
                    12392   ; for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
00003FE2  4203      12393          clr.b     D3
                    12394   OSSemQuery_4:
00003FE4  0C03 0008 12395          cmp.b     #8,D3
00003FE8  6416      12396          bhs.s     OSSemQuery_6
                    12397   ; *pdest++ = *psrc++;
00003FEA  206E FFF8 12398          move.l    -8(A6),A0
00003FEE  52AE FFF8 12399          addq.l    #1,-8(A6)
00003FF2  226E FFFC 12400          move.l    -4(A6),A1
00003FF6  52AE FFFC 12401          addq.l    #1,-4(A6)
00003FFA  1290      12402          move.b    (A0),(A1)
00003FFC  5203      12403          addq.b    #1,D3
00003FFE  60E4      12404          bra       OSSemQuery_4
                    12405   OSSemQuery_6:
                    12406   ; }
                    12407   ; p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
00004000  2042      12408          move.l    D2,A0
00004002  2244      12409          move.l    D4,A1
00004004  32A8 0006 12410          move.w    6(A0),(A1)
                    12411   ; OS_EXIT_CRITICAL();
00004008  46DF      12412          dc.w      18143
                    12413   ; return (OS_ERR_NONE);
0000400A  4200      12414          clr.b     D0
                    12415   OSSemQuery_3:
0000400C  4CDF 001C 12416          movem.l   (A7)+,D2/D3/D4
00004010  4E5E      12417          unlk      A6
00004012  4E75      12418          rts
                    12419   ; }
                    12420   ; #endif                                                     /* OS_SEM_QUERY_EN                          */
                    12421   ; /*$PAGE*/
                    12422   ; /*
                    12423   ; *********************************************************************************************************
                    12424   ; *                                            SET SEMAPHORE
                    12425   ; *
                    12426   ; * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
                    12427   ; *              this value would be 0.
                    12428   ; *
                    12429   ; *              You would typically use this function when a semaphore is used as a signaling mechanism
                    12430   ; *              and, you want to reset the count value.
                    12431   ; *
                    12432   ; * Arguments  : pevent     is a pointer to the event control block
                    12433   ; *
                    12434   ; *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
                    12435   ; *                         semaphore count.
                    12436   ; *
                    12437   ; *              perr       is a pointer to an error code returned by the function as follows:
                    12438   ; *
                    12439   ; *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
                    12440   ; *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
                    12441   ; *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
                    12442   ; *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
                    12443   ; *********************************************************************************************************
                    12444   ; */
                    12445   ; #if OS_SEM_SET_EN > 0u
                    12446   ; void  OSSemSet (OS_EVENT  *pevent,
                    12447   ; INT16U     cnt,
                    12448   ; INT8U     *perr)
                    12449   ; {
                    12450   _OSSemSet:
00004014  4E56 0000 12451          link      A6,#0
00004018  48E7 3000 12452          movem.l   D2/D3,-(A7)
0000401C  242E 0008 12453          move.l    8(A6),D2
00004020  262E 0010 12454          move.l    16(A6),D3
                    12455   ; #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
                    12456   ; OS_CPU_SR  cpu_sr = 0u;
                    12457   ; #endif
                    12458   ; #ifdef OS_SAFETY_CRITICAL
                    12459   ; if (perr == (INT8U *)0) {
                    12460   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12461   ; return;
                    12462   ; }
                    12463   ; #endif
                    12464   ; #if OS_ARG_CHK_EN > 0u
                    12465   ; if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                    12466   ; *perr = OS_ERR_PEVENT_NULL;
                    12467   ; return;
                    12468   ; }
                    12469   ; #endif
                    12470   ; if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00004024  2042      12471          move.l    D2,A0
00004026  1010      12472          move.b    (A0),D0
00004028  0C00 0003 12473          cmp.b     #3,D0
0000402C  670A      12474          beq.s     OSSemSet_1
                    12475   ; *perr = OS_ERR_EVENT_TYPE;
0000402E  2043      12476          move.l    D3,A0
00004030  10BC 0001 12477          move.b    #1,(A0)
                    12478   ; return;
00004034  6000 003C 12479          bra       OSSemSet_3
                    12480   OSSemSet_1:
                    12481   ; }
                    12482   ; OS_ENTER_CRITICAL();
00004038  40E7      12483          dc.w      16615
0000403A  007C      12484          dc.w      124
0000403C  0700      12485          dc.w      1792
                    12486   ; *perr = OS_ERR_NONE;
0000403E  2043      12487          move.l    D3,A0
00004040  4210      12488          clr.b     (A0)
                    12489   ; if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
00004042  2042      12490          move.l    D2,A0
00004044  3028 0006 12491          move.w    6(A0),D0
00004048  0C40 0000 12492          cmp.w     #0,D0
0000404C  630A      12493          bls.s     OSSemSet_4
                    12494   ; pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
0000404E  2042      12495          move.l    D2,A0
00004050  316E 000E 12496          move.w    14(A6),6(A0)
00004054  0006      
00004056  6018      12497          bra.s     OSSemSet_7
                    12498   OSSemSet_4:
                    12499   ; } else {                                          /* No                                            */
                    12500   ; if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
00004058  2042      12501          move.l    D2,A0
0000405A  1028 0008 12502          move.b    8(A0),D0
0000405E  660A      12503          bne.s     OSSemSet_6
                    12504   ; pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
00004060  2042      12505          move.l    D2,A0
00004062  316E 000E 12506          move.w    14(A6),6(A0)
00004066  0006      
00004068  6006      12507          bra.s     OSSemSet_7
                    12508   OSSemSet_6:
                    12509   ; } else {
                    12510   ; *perr              = OS_ERR_TASK_WAITING;
0000406A  2043      12511          move.l    D3,A0
0000406C  10BC 0049 12512          move.b    #73,(A0)
                    12513   OSSemSet_7:
                    12514   ; }
                    12515   ; }
                    12516   ; OS_EXIT_CRITICAL();
00004070  46DF      12517          dc.w      18143
                    12518   OSSemSet_3:
00004072  4CDF 000C 12519          movem.l   (A7)+,D2/D3
00004076  4E5E      12520          unlk      A6
00004078  4E75      12521          rts
                    12522   ; /*
                    12523   ; *********************************************************************************************************
                    12524   ; *                                                uC/OS-II
                    12525   ; *                                          The Real-Time Kernel
                    12526   ; *                                            TASK MANAGEMENT
                    12527   ; *
                    12528   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    12529   ; *                                           All Rights Reserved
                    12530   ; *
                    12531   ; * File    : OS_TASK.C
                    12532   ; * By      : Jean J. Labrosse
                    12533   ; * Version : V2.92.07
                    12534   ; *
                    12535   ; * LICENSING TERMS:
                    12536   ; * ---------------
                    12537   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    12538   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    12539   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    12540   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    12541   ; * licensing fee.
                    12542   ; *********************************************************************************************************
                    12543   ; */
                    12544   ; #define  MICRIUM_SOURCE
                    12545   ; #ifndef  OS_MASTER_FILE
                    12546   ; #include <ucos_ii.h>
                    12547   ; #endif
                    12548   ; /*$PAGE*/
                    12549   ; /*
                    12550   ; *********************************************************************************************************
                    12551   ; *                                      CHANGE PRIORITY OF A TASK
                    12552   ; *
                    12553   ; * Description: This function allows you to change the priority of a task dynamically.  Note that the new
                    12554   ; *              priority MUST be available.
                    12555   ; *
                    12556   ; * Arguments  : oldp     is the old priority
                    12557   ; *
                    12558   ; *              newp     is the new priority
                    12559   ; *
                    12560   ; * Returns    : OS_ERR_NONE            is the call was successful
                    12561   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    12562   ; *                                     (i.e. >= OS_LOWEST_PRIO)
                    12563   ; *              OS_ERR_PRIO_EXIST      if the new priority already exist.
                    12564   ; *              OS_ERR_PRIO            there is no task with the specified OLD priority (i.e. the OLD task does
                    12565   ; *                                     not exist.
                    12566   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP.
                    12567   ; *********************************************************************************************************
                    12568   ; */
                    12569   ; #if OS_TASK_CHANGE_PRIO_EN > 0u
                    12570   ; INT8U  OSTaskChangePrio (INT8U  oldprio,
                    12571   ; INT8U  newprio)
                    12572   ; {
                    12573   _OSTaskChangePrio:
0000407A  4E56 FFFC 12574          link      A6,#-4
0000407E  48E7 3F38 12575          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4,-(A7)
00004082  47F9 0080 12576          lea       _OSRdyTbl.L,A3
00004086  0250      
00004088  49F9 0080 12577          lea       _OSTCBPrioTbl.L,A4
0000408C  0370      
                    12578   ; #if (OS_EVENT_EN)
                    12579   ; OS_EVENT  *pevent;
                    12580   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12581   ; OS_EVENT **pevents;
                    12582   ; #endif
                    12583   ; #endif
                    12584   ; OS_TCB    *ptcb;
                    12585   ; INT8U      y_new;
                    12586   ; INT8U      x_new;
                    12587   ; INT8U      y_old;
                    12588   ; OS_PRIO    bity_new;
                    12589   ; OS_PRIO    bitx_new;
                    12590   ; OS_PRIO    bity_old;
                    12591   ; OS_PRIO    bitx_old;
                    12592   ; #if OS_CRITICAL_METHOD == 3u
                    12593   ; OS_CPU_SR  cpu_sr = 0u;                                 /* Storage for CPU status register         */
                    12594   ; #endif
                    12595   ; /*$PAGE*/
                    12596   ; #if OS_ARG_CHK_EN > 0u
                    12597   ; if (oldprio >= OS_LOWEST_PRIO) {
                    12598   ; if (oldprio != OS_PRIO_SELF) {
                    12599   ; return (OS_ERR_PRIO_INVALID);
                    12600   ; }
                    12601   ; }
                    12602   ; if (newprio >= OS_LOWEST_PRIO) {
                    12603   ; return (OS_ERR_PRIO_INVALID);
                    12604   ; }
                    12605   ; #endif
                    12606   ; OS_ENTER_CRITICAL();
0000408E  40E7      12607          dc.w      16615
00004090  007C      12608          dc.w      124
00004092  0700      12609          dc.w      1792
                    12610   ; if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
00004094  102E 000F 12611          move.b    15(A6),D0
00004098  C0BC 0000 12612          and.l     #255,D0
0000409C  00FF      
0000409E  E588      12613          lsl.l     #2,D0
000040A0  2034 0800 12614          move.l    0(A4,D0.L),D0
000040A4  6708      12615          beq.s     OSTaskChangePrio_1
                    12616   ; OS_EXIT_CRITICAL();
000040A6  46DF      12617          dc.w      18143
                    12618   ; return (OS_ERR_PRIO_EXIST);
000040A8  7028      12619          moveq     #40,D0
000040AA  6000 01E0 12620          bra       OSTaskChangePrio_3
                    12621   OSTaskChangePrio_1:
                    12622   ; }
                    12623   ; if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
000040AE  102E 000B 12624          move.b    11(A6),D0
000040B2  0C00 00FF 12625          cmp.b     #255,D0
000040B6  660C      12626          bne.s     OSTaskChangePrio_4
                    12627   ; oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
000040B8  2079 0080 12628          move.l    _OSTCBCur.L,A0
000040BC  0360      
000040BE  1D68 0034 12629          move.b    52(A0),11(A6)
000040C2  000B      
                    12630   OSTaskChangePrio_4:
                    12631   ; }
                    12632   ; ptcb = OSTCBPrioTbl[oldprio];
000040C4  102E 000B 12633          move.b    11(A6),D0
000040C8  C0BC 0000 12634          and.l     #255,D0
000040CC  00FF      
000040CE  E588      12635          lsl.l     #2,D0
000040D0  2634 0800 12636          move.l    0(A4,D0.L),D3
                    12637   ; if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
000040D4  4A83      12638          tst.l     D3
000040D6  6608      12639          bne.s     OSTaskChangePrio_6
                    12640   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
000040D8  46DF      12641          dc.w      18143
                    12642   ; return (OS_ERR_PRIO);
000040DA  7029      12643          moveq     #41,D0
000040DC  6000 01AE 12644          bra       OSTaskChangePrio_3
                    12645   OSTaskChangePrio_6:
                    12646   ; }
                    12647   ; if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
000040E0  0C83 0000 12648          cmp.l     #1,D3
000040E4  0001      
000040E6  6608      12649          bne.s     OSTaskChangePrio_8
                    12650   ; OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
000040E8  46DF      12651          dc.w      18143
                    12652   ; return (OS_ERR_TASK_NOT_EXIST);
000040EA  7043      12653          moveq     #67,D0
000040EC  6000 019E 12654          bra       OSTaskChangePrio_3
                    12655   OSTaskChangePrio_8:
                    12656   ; }
                    12657   ; #if OS_LOWEST_PRIO <= 63u
                    12658   ; y_new                 = (INT8U)(newprio >> 3u);         /* Yes, compute new TCB fields             */
000040F0  102E 000F 12659          move.b    15(A6),D0
000040F4  E608      12660          lsr.b     #3,D0
000040F6  1A00      12661          move.b    D0,D5
                    12662   ; x_new                 = (INT8U)(newprio & 0x07u);
000040F8  102E 000F 12663          move.b    15(A6),D0
000040FC  C03C 0007 12664          and.b     #7,D0
00004100  1D40 FFFD 12665          move.b    D0,-3(A6)
                    12666   ; #else
                    12667   ; y_new                 = (INT8U)((INT8U)(newprio >> 4u) & 0x0Fu);
                    12668   ; x_new                 = (INT8U)(newprio & 0x0Fu);
                    12669   ; #endif
                    12670   ; bity_new              = (OS_PRIO)(1uL << y_new);
00004104  7001      12671          moveq     #1,D0
00004106  CABC 0000 12672          and.l     #255,D5
0000410A  00FF      
0000410C  EBA8      12673          lsl.l     D5,D0
0000410E  1D40 FFFE 12674          move.b    D0,-2(A6)
                    12675   ; bitx_new              = (OS_PRIO)(1uL << x_new);
00004112  7001      12676          moveq     #1,D0
00004114  122E FFFD 12677          move.b    -3(A6),D1
00004118  C2BC 0000 12678          and.l     #255,D1
0000411C  00FF      
0000411E  E3A8      12679          lsl.l     D1,D0
00004120  1E00      12680          move.b    D0,D7
                    12681   ; OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
00004122  102E 000B 12682          move.b    11(A6),D0
00004126  C0BC 0000 12683          and.l     #255,D0
0000412A  00FF      
0000412C  E588      12684          lsl.l     #2,D0
0000412E  42B4 0800 12685          clr.l     0(A4,D0.L)
                    12686   ; OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
00004132  102E 000F 12687          move.b    15(A6),D0
00004136  C0BC 0000 12688          and.l     #255,D0
0000413A  00FF      
0000413C  E588      12689          lsl.l     #2,D0
0000413E  2983 0800 12690          move.l    D3,0(A4,D0.L)
                    12691   ; y_old                 =  ptcb->OSTCBY;
00004142  2043      12692          move.l    D3,A0
00004144  1828 0036 12693          move.b    54(A0),D4
                    12694   ; bity_old              =  ptcb->OSTCBBitY;
00004148  2043      12695          move.l    D3,A0
0000414A  1D68 0038 12696          move.b    56(A0),-1(A6)
0000414E  FFFF      
                    12697   ; bitx_old              =  ptcb->OSTCBBitX;
00004150  2043      12698          move.l    D3,A0
00004152  1C28 0037 12699          move.b    55(A0),D6
                    12700   ; if ((OSRdyTbl[y_old] &   bitx_old) != 0u) {             /* If task is ready make it not            */
00004156  C8BC 0000 12701          and.l     #255,D4
0000415A  00FF      
0000415C  1033 4800 12702          move.b    0(A3,D4.L),D0
00004160  C006      12703          and.b     D6,D0
00004162  673A      12704          beq.s     OSTaskChangePrio_10
                    12705   ; OSRdyTbl[y_old] &= (OS_PRIO)~bitx_old;
00004164  C8BC 0000 12706          and.l     #255,D4
00004168  00FF      
0000416A  1006      12707          move.b    D6,D0
0000416C  4600      12708          not.b     D0
0000416E  C133 4800 12709          and.b     D0,0(A3,D4.L)
                    12710   ; if (OSRdyTbl[y_old] == 0u) {
00004172  C8BC 0000 12711          and.l     #255,D4
00004176  00FF      
00004178  1033 4800 12712          move.b    0(A3,D4.L),D0
0000417C  660C      12713          bne.s     OSTaskChangePrio_12
                    12714   ; OSRdyGrp &= (OS_PRIO)~bity_old;
0000417E  102E FFFF 12715          move.b    -1(A6),D0
00004182  4600      12716          not.b     D0
00004184  C139 0080 12717          and.b     D0,_OSRdyGrp.L
00004188  024E      
                    12718   OSTaskChangePrio_12:
                    12719   ; }
                    12720   ; OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
0000418A  102E FFFE 12721          move.b    -2(A6),D0
0000418E  8139 0080 12722          or.b      D0,_OSRdyGrp.L
00004192  024E      
                    12723   ; OSRdyTbl[y_new] |= bitx_new;
00004194  CABC 0000 12724          and.l     #255,D5
00004198  00FF      
0000419A  8F33 5800 12725          or.b      D7,0(A3,D5.L)
                    12726   OSTaskChangePrio_10:
                    12727   ; }
                    12728   ; #if (OS_EVENT_EN)
                    12729   ; pevent = ptcb->OSTCBEventPtr;
0000419E  2043      12730          move.l    D3,A0
000041A0  2428 001C 12731          move.l    28(A0),D2
                    12732   ; if (pevent != (OS_EVENT *)0) {
000041A4  4A82      12733          tst.l     D2
000041A6  6700 0048 12734          beq       OSTaskChangePrio_14
                    12735   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;    /* Remove old task prio from wait list     */
000041AA  2042      12736          move.l    D2,A0
000041AC  C8BC 0000 12737          and.l     #255,D4
000041B0  00FF      
000041B2  D1C4      12738          add.l     D4,A0
000041B4  1006      12739          move.b    D6,D0
000041B6  4600      12740          not.b     D0
000041B8  C128 000A 12741          and.b     D0,10(A0)
                    12742   ; if (pevent->OSEventTbl[y_old] == 0u) {
000041BC  2042      12743          move.l    D2,A0
000041BE  C8BC 0000 12744          and.l     #255,D4
000041C2  00FF      
000041C4  D1C4      12745          add.l     D4,A0
000041C6  1028 000A 12746          move.b    10(A0),D0
000041CA  660C      12747          bne.s     OSTaskChangePrio_16
                    12748   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
000041CC  2042      12749          move.l    D2,A0
000041CE  102E FFFF 12750          move.b    -1(A6),D0
000041D2  4600      12751          not.b     D0
000041D4  C128 0008 12752          and.b     D0,8(A0)
                    12753   OSTaskChangePrio_16:
                    12754   ; }
                    12755   ; pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
000041D8  2042      12756          move.l    D2,A0
000041DA  102E FFFE 12757          move.b    -2(A6),D0
000041DE  8128 0008 12758          or.b      D0,8(A0)
                    12759   ; pevent->OSEventTbl[y_new] |= bitx_new;
000041E2  2042      12760          move.l    D2,A0
000041E4  CABC 0000 12761          and.l     #255,D5
000041E8  00FF      
000041EA  D1C5      12762          add.l     D5,A0
000041EC  8F28 000A 12763          or.b      D7,10(A0)
                    12764   OSTaskChangePrio_14:
                    12765   ; }
                    12766   ; #if (OS_EVENT_MULTI_EN > 0u)
                    12767   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
000041F0  2043      12768          move.l    D3,A0
000041F2  2028 0020 12769          move.l    32(A0),D0
000041F6  6700 005C 12770          beq       OSTaskChangePrio_22
                    12771   ; pevents =  ptcb->OSTCBEventMultiPtr;
000041FA  2043      12772          move.l    D3,A0
000041FC  2468 0020 12773          move.l    32(A0),A2
                    12774   ; pevent  = *pevents;
00004200  2412      12775          move.l    (A2),D2
                    12776   ; while (pevent != (OS_EVENT *)0) {
                    12777   OSTaskChangePrio_20:
00004202  4A82      12778          tst.l     D2
00004204  6700 004E 12779          beq       OSTaskChangePrio_22
                    12780   ; pevent->OSEventTbl[y_old] &= (OS_PRIO)~bitx_old;   /* Remove old task prio from wait lists */
00004208  2042      12781          move.l    D2,A0
0000420A  C8BC 0000 12782          and.l     #255,D4
0000420E  00FF      
00004210  D1C4      12783          add.l     D4,A0
00004212  1006      12784          move.b    D6,D0
00004214  4600      12785          not.b     D0
00004216  C128 000A 12786          and.b     D0,10(A0)
                    12787   ; if (pevent->OSEventTbl[y_old] == 0u) {
0000421A  2042      12788          move.l    D2,A0
0000421C  C8BC 0000 12789          and.l     #255,D4
00004220  00FF      
00004222  D1C4      12790          add.l     D4,A0
00004224  1028 000A 12791          move.b    10(A0),D0
00004228  660C      12792          bne.s     OSTaskChangePrio_23
                    12793   ; pevent->OSEventGrp    &= (OS_PRIO)~bity_old;
0000422A  2042      12794          move.l    D2,A0
0000422C  102E FFFF 12795          move.b    -1(A6),D0
00004230  4600      12796          not.b     D0
00004232  C128 0008 12797          and.b     D0,8(A0)
                    12798   OSTaskChangePrio_23:
                    12799   ; }
                    12800   ; pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
00004236  2042      12801          move.l    D2,A0
00004238  102E FFFE 12802          move.b    -2(A6),D0
0000423C  8128 0008 12803          or.b      D0,8(A0)
                    12804   ; pevent->OSEventTbl[y_new] |= bitx_new;
00004240  2042      12805          move.l    D2,A0
00004242  CABC 0000 12806          and.l     #255,D5
00004246  00FF      
00004248  D1C5      12807          add.l     D5,A0
0000424A  8F28 000A 12808          or.b      D7,10(A0)
                    12809   ; pevents++;
0000424E  584A      12810          addq.w    #4,A2
                    12811   ; pevent                     = *pevents;
00004250  2412      12812          move.l    (A2),D2
00004252  60AE      12813          bra       OSTaskChangePrio_20
                    12814   OSTaskChangePrio_22:
                    12815   ; }
                    12816   ; }
                    12817   ; #endif
                    12818   ; #endif
                    12819   ; ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
00004254  2043      12820          move.l    D3,A0
00004256  116E 000F 12821          move.b    15(A6),52(A0)
0000425A  0034      
                    12822   ; ptcb->OSTCBY    = y_new;
0000425C  2043      12823          move.l    D3,A0
0000425E  1145 0036 12824          move.b    D5,54(A0)
                    12825   ; ptcb->OSTCBX    = x_new;
00004262  2043      12826          move.l    D3,A0
00004264  116E FFFD 12827          move.b    -3(A6),53(A0)
00004268  0035      
                    12828   ; ptcb->OSTCBBitY = bity_new;
0000426A  2043      12829          move.l    D3,A0
0000426C  116E FFFE 12830          move.b    -2(A6),56(A0)
00004270  0038      
                    12831   ; ptcb->OSTCBBitX = bitx_new;
00004272  2043      12832          move.l    D3,A0
00004274  1147 0037 12833          move.b    D7,55(A0)
                    12834   ; OS_EXIT_CRITICAL();
00004278  46DF      12835          dc.w      18143
                    12836   ; if (OSRunning == OS_TRUE) {
0000427A  1039 0080 12837          move.b    _OSRunning.L,D0
0000427E  0258      
00004280  0C00 0001 12838          cmp.b     #1,D0
00004284  6604      12839          bne.s     OSTaskChangePrio_25
                    12840   ; OS_Sched();                                         /* Find new highest priority task          */
00004286  4EB8 13F8 12841          jsr       _OS_Sched
                    12842   OSTaskChangePrio_25:
                    12843   ; }
                    12844   ; return (OS_ERR_NONE);
0000428A  4200      12845          clr.b     D0
                    12846   OSTaskChangePrio_3:
0000428C  4CDF 1CFC 12847          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4
00004290  4E5E      12848          unlk      A6
00004292  4E75      12849          rts
                    12850   ; }
                    12851   ; #endif
                    12852   ; /*$PAGE*/
                    12853   ; /*
                    12854   ; *********************************************************************************************************
                    12855   ; *                                            CREATE A TASK
                    12856   ; *
                    12857   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    12858   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    12859   ; *              created by an ISR.
                    12860   ; *
                    12861   ; * Arguments  : task     is a pointer to the task's code
                    12862   ; *
                    12863   ; *              p_arg    is a pointer to an optional data area which can be used to pass parameters to
                    12864   ; *                       the task when the task first executes.  Where the task is concerned it thinks
                    12865   ; *                       it was invoked and passed the argument 'p_arg' as follows:
                    12866   ; *
                    12867   ; *                           void Task (void *p_arg)
                    12868   ; *                           {
                    12869   ; *                               for (;;) {
                    12870   ; *                                   Task code;
                    12871   ; *                               }
                    12872   ; *                           }
                    12873   ; *
                    12874   ; *              ptos     is a pointer to the task's top of stack.  If the configuration constant
                    12875   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    12876   ; *                       memory to low memory).  'pstk' will thus point to the highest (valid) memory
                    12877   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pstk' will point to the
                    12878   ; *                       lowest memory location of the stack and the stack will grow with increasing
                    12879   ; *                       memory locations.
                    12880   ; *
                    12881   ; *              prio     is the task's priority.  A unique priority MUST be assigned to each task and the
                    12882   ; *                       lower the number, the higher the priority.
                    12883   ; *
                    12884   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    12885   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    12886   ; *                                               (each task MUST have a unique priority).
                    12887   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    12888   ; *                                               allowed (i.e. >= OS_LOWEST_PRIO)
                    12889   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    12890   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    12891   ; *                                               operation started.
                    12892   ; *********************************************************************************************************
                    12893   ; */
                    12894   ; #if OS_TASK_CREATE_EN > 0u
                    12895   ; INT8U  OSTaskCreate (void   (*task)(void *p_arg),
                    12896   ; void    *p_arg,
                    12897   ; OS_STK  *ptos,
                    12898   ; INT8U    prio)
                    12899   ; {
                    12900   _OSTaskCreate:
00004294  4E56 FFFC 12901          link      A6,#-4
00004298  48E7 3020 12902          movem.l   D2/D3/A2,-(A7)
0000429C  142E 0017 12903          move.b    23(A6),D2
000042A0  C4BC 0000 12904          and.l     #255,D2
000042A4  00FF      
000042A6  45F9 0080 12905          lea       _OSTCBPrioTbl.L,A2
000042AA  0370      
                    12906   ; OS_STK     *psp;
                    12907   ; INT8U       err;
                    12908   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    12909   ; OS_CPU_SR   cpu_sr = 0u;
                    12910   ; #endif
                    12911   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    12912   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    12913   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    12914   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    12915   ; }
                    12916   ; #endif
                    12917   ; #if OS_ARG_CHK_EN > 0u
                    12918   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    12919   ; return (OS_ERR_PRIO_INVALID);
                    12920   ; }
                    12921   ; #endif
                    12922   ; OS_ENTER_CRITICAL();
000042AC  40E7      12923          dc.w      16615
000042AE  007C      12924          dc.w      124
000042B0  0700      12925          dc.w      1792
                    12926   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
000042B2  1039 0080 12927          move.b    _OSIntNesting.L,D0
000042B6  0246      
000042B8  0C00 0000 12928          cmp.b     #0,D0
000042BC  6308      12929          bls.s     OSTaskCreate_1
                    12930   ; OS_EXIT_CRITICAL();
000042BE  46DF      12931          dc.w      18143
                    12932   ; return (OS_ERR_TASK_CREATE_ISR);
000042C0  703C      12933          moveq     #60,D0
000042C2  6000 0096 12934          bra       OSTaskCreate_3
                    12935   OSTaskCreate_1:
                    12936   ; }
                    12937   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
000042C6  C4BC 0000 12938          and.l     #255,D2
000042CA  00FF      
000042CC  2002      12939          move.l    D2,D0
000042CE  E588      12940          lsl.l     #2,D0
000042D0  2032 0800 12941          move.l    0(A2,D0.L),D0
000042D4  6600 0080 12942          bne       OSTaskCreate_4
                    12943   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
000042D8  C4BC 0000 12944          and.l     #255,D2
000042DC  00FF      
000042DE  2002      12945          move.l    D2,D0
000042E0  E588      12946          lsl.l     #2,D0
000042E2  25BC 0000 12947          move.l    #1,0(A2,D0.L)
000042E6  0001 0800 
                    12948   ; /* ... the same thing until task is created.              */
                    12949   ; OS_EXIT_CRITICAL();
000042EA  46DF      12950          dc.w      18143
                    12951   ; psp = OSTaskStkInit(task, p_arg, ptos, 0u);             /* Initialize the task's stack         */
000042EC  42A7      12952          clr.l     -(A7)
000042EE  2F2E 0010 12953          move.l    16(A6),-(A7)
000042F2  2F2E 000C 12954          move.l    12(A6),-(A7)
000042F6  2F2E 0008 12955          move.l    8(A6),-(A7)
000042FA  4EB8 05A0 12956          jsr       _OSTaskStkInit
000042FE  DEFC 0010 12957          add.w     #16,A7
00004302  2D40 FFFC 12958          move.l    D0,-4(A6)
                    12959   ; err = OS_TCBInit(prio, psp, (OS_STK *)0, 0u, 0u, (void *)0, 0u);
00004306  42A7      12960          clr.l     -(A7)
00004308  42A7      12961          clr.l     -(A7)
0000430A  42A7      12962          clr.l     -(A7)
0000430C  42A7      12963          clr.l     -(A7)
0000430E  42A7      12964          clr.l     -(A7)
00004310  2F2E FFFC 12965          move.l    -4(A6),-(A7)
00004314  C4BC 0000 12966          and.l     #255,D2
00004318  00FF      
0000431A  2F02      12967          move.l    D2,-(A7)
0000431C  4EB8 1612 12968          jsr       _OS_TCBInit
00004320  DEFC 001C 12969          add.w     #28,A7
00004324  1600      12970          move.b    D0,D3
                    12971   ; if (err == OS_ERR_NONE) {
00004326  4A03      12972          tst.b     D3
00004328  6612      12973          bne.s     OSTaskCreate_6
                    12974   ; if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
0000432A  1039 0080 12975          move.b    _OSRunning.L,D0
0000432E  0258      
00004330  0C00 0001 12976          cmp.b     #1,D0
00004334  6604      12977          bne.s     OSTaskCreate_8
                    12978   ; OS_Sched();
00004336  4EB8 13F8 12979          jsr       _OS_Sched
                    12980   OSTaskCreate_8:
0000433A  6016      12981          bra.s     OSTaskCreate_7
                    12982   OSTaskCreate_6:
                    12983   ; }
                    12984   ; } else {
                    12985   ; OS_ENTER_CRITICAL();
0000433C  40E7      12986          dc.w      16615
0000433E  007C      12987          dc.w      124
00004340  0700      12988          dc.w      1792
                    12989   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
00004342  C4BC 0000 12990          and.l     #255,D2
00004346  00FF      
00004348  2002      12991          move.l    D2,D0
0000434A  E588      12992          lsl.l     #2,D0
0000434C  42B2 0800 12993          clr.l     0(A2,D0.L)
                    12994   ; OS_EXIT_CRITICAL();
00004350  46DF      12995          dc.w      18143
                    12996   OSTaskCreate_7:
                    12997   ; }
                    12998   ; return (err);
00004352  1003      12999          move.b    D3,D0
00004354  6004      13000          bra.s     OSTaskCreate_3
                    13001   OSTaskCreate_4:
                    13002   ; }
                    13003   ; OS_EXIT_CRITICAL();
00004356  46DF      13004          dc.w      18143
                    13005   ; return (OS_ERR_PRIO_EXIST);
00004358  7028      13006          moveq     #40,D0
                    13007   OSTaskCreate_3:
0000435A  4CDF 040C 13008          movem.l   (A7)+,D2/D3/A2
0000435E  4E5E      13009          unlk      A6
00004360  4E75      13010          rts
                    13011   ; }
                    13012   ; #endif
                    13013   ; /*$PAGE*/
                    13014   ; /*
                    13015   ; *********************************************************************************************************
                    13016   ; *                                  CREATE A TASK (Extended Version)
                    13017   ; *
                    13018   ; * Description: This function is used to have uC/OS-II manage the execution of a task.  Tasks can either
                    13019   ; *              be created prior to the start of multitasking or by a running task.  A task cannot be
                    13020   ; *              created by an ISR.  This function is similar to OSTaskCreate() except that it allows
                    13021   ; *              additional information about a task to be specified.
                    13022   ; *
                    13023   ; * Arguments  : task      is a pointer to the task's code
                    13024   ; *
                    13025   ; *              p_arg     is a pointer to an optional data area which can be used to pass parameters to
                    13026   ; *                        the task when the task first executes.  Where the task is concerned it thinks
                    13027   ; *                        it was invoked and passed the argument 'p_arg' as follows:
                    13028   ; *
                    13029   ; *                            void Task (void *p_arg)
                    13030   ; *                            {
                    13031   ; *                                for (;;) {
                    13032   ; *                                    Task code;
                    13033   ; *                                }
                    13034   ; *                            }
                    13035   ; *
                    13036   ; *              ptos      is a pointer to the task's top of stack.  If the configuration constant
                    13037   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13038   ; *                        memory to low memory).  'ptos' will thus point to the highest (valid) memory
                    13039   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'ptos' will point to the
                    13040   ; *                        lowest memory location of the stack and the stack will grow with increasing
                    13041   ; *                        memory locations.  'ptos' MUST point to a valid 'free' data item.
                    13042   ; *
                    13043   ; *              prio      is the task's priority.  A unique priority MUST be assigned to each task and the
                    13044   ; *                        lower the number, the higher the priority.
                    13045   ; *
                    13046   ; *              id        is the task's ID (0..65535)
                    13047   ; *
                    13048   ; *              pbos      is a pointer to the task's bottom of stack.  If the configuration constant
                    13049   ; *                        OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    13050   ; *                        memory to low memory).  'pbos' will thus point to the LOWEST (valid) memory
                    13051   ; *                        location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    13052   ; *                        HIGHEST memory location of the stack and the stack will grow with increasing
                    13053   ; *                        memory locations.  'pbos' MUST point to a valid 'free' data item.
                    13054   ; *
                    13055   ; *              stk_size  is the size of the stack in number of elements.  If OS_STK is set to INT8U,
                    13056   ; *                        'stk_size' corresponds to the number of bytes available.  If OS_STK is set to
                    13057   ; *                        INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
                    13058   ; *                        OS_STK is set to INT32U, 'stk_size' contains the number of 32-bit entries
                    13059   ; *                        available on the stack.
                    13060   ; *
                    13061   ; *              pext      is a pointer to a user supplied memory location which is used as a TCB extension.
                    13062   ; *                        For example, this user memory can hold the contents of floating-point registers
                    13063   ; *                        during a context switch, the time each task takes to execute, the number of times
                    13064   ; *                        the task has been switched-in, etc.
                    13065   ; *
                    13066   ; *              opt       contains additional information (or options) about the behavior of the task.  The
                    13067   ; *                        LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    13068   ; *                        specific.  See OS_TASK_OPT_??? in uCOS-II.H.  Current choices are:
                    13069   ; *
                    13070   ; *                        OS_TASK_OPT_STK_CHK      Stack checking to be allowed for the task
                    13071   ; *                        OS_TASK_OPT_STK_CLR      Clear the stack when the task is created
                    13072   ; *                        OS_TASK_OPT_SAVE_FP      If the CPU has floating-point registers, save them
                    13073   ; *                                                 during a context switch.
                    13074   ; *
                    13075   ; * Returns    : OS_ERR_NONE                      if the function was successful.
                    13076   ; *              OS_ERR_PRIO_EXIST                if the task priority already exist
                    13077   ; *                                               (each task MUST have a unique priority).
                    13078   ; *              OS_ERR_PRIO_INVALID              if the priority you specify is higher that the maximum
                    13079   ; *                                               allowed (i.e. > OS_LOWEST_PRIO)
                    13080   ; *              OS_ERR_TASK_CREATE_ISR           if you tried to create a task from an ISR.
                    13081   ; *              OS_ERR_ILLEGAL_CREATE_RUN_TIME   if you tried to create a task after safety critical
                    13082   ; *                                               operation started.
                    13083   ; *********************************************************************************************************
                    13084   ; */
                    13085   ; /*$PAGE*/
                    13086   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    13087   ; INT8U  OSTaskCreateExt (void   (*task)(void *p_arg),
                    13088   ; void    *p_arg,
                    13089   ; OS_STK  *ptos,
                    13090   ; INT8U    prio,
                    13091   ; INT16U   id,
                    13092   ; OS_STK  *pbos,
                    13093   ; INT32U   stk_size,
                    13094   ; void    *pext,
                    13095   ; INT16U   opt)
                    13096   ; {
                    13097   _OSTaskCreateExt:
00004362  4E56 FFFC 13098          link      A6,#-4
00004366  48E7 3820 13099          movem.l   D2/D3/D4/A2,-(A7)
0000436A  142E 0017 13100          move.b    23(A6),D2
0000436E  C4BC 0000 13101          and.l     #255,D2
00004372  00FF      
00004374  382E 002A 13102          move.w    42(A6),D4
00004378  C8BC 0000 13103          and.l     #65535,D4
0000437C  FFFF      
0000437E  45F9 0080 13104          lea       _OSTCBPrioTbl.L,A2
00004382  0370      
                    13105   ; OS_STK     *psp;
                    13106   ; INT8U       err;
                    13107   ; #if OS_CRITICAL_METHOD == 3u                 /* Allocate storage for CPU status register               */
                    13108   ; OS_CPU_SR   cpu_sr = 0u;
                    13109   ; #endif
                    13110   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    13111   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    13112   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13113   ; return (OS_ERR_ILLEGAL_CREATE_RUN_TIME);
                    13114   ; }
                    13115   ; #endif
                    13116   ; #if OS_ARG_CHK_EN > 0u
                    13117   ; if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
                    13118   ; return (OS_ERR_PRIO_INVALID);
                    13119   ; }
                    13120   ; #endif
                    13121   ; OS_ENTER_CRITICAL();
00004384  40E7      13122          dc.w      16615
00004386  007C      13123          dc.w      124
00004388  0700      13124          dc.w      1792
                    13125   ; if (OSIntNesting > 0u) {                 /* Make sure we don't create the task from within an ISR  */
0000438A  1039 0080 13126          move.b    _OSIntNesting.L,D0
0000438E  0246      
00004390  0C00 0000 13127          cmp.b     #0,D0
00004394  6308      13128          bls.s     OSTaskCreateExt_1
                    13129   ; OS_EXIT_CRITICAL();
00004396  46DF      13130          dc.w      18143
                    13131   ; return (OS_ERR_TASK_CREATE_ISR);
00004398  703C      13132          moveq     #60,D0
0000439A  6000 00CC 13133          bra       OSTaskCreateExt_3
                    13134   OSTaskCreateExt_1:
                    13135   ; }
                    13136   ; if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
0000439E  C4BC 0000 13137          and.l     #255,D2
000043A2  00FF      
000043A4  2002      13138          move.l    D2,D0
000043A6  E588      13139          lsl.l     #2,D0
000043A8  2032 0800 13140          move.l    0(A2,D0.L),D0
000043AC  6600 00B6 13141          bne       OSTaskCreateExt_4
                    13142   ; OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
000043B0  C4BC 0000 13143          and.l     #255,D2
000043B4  00FF      
000043B6  2002      13144          move.l    D2,D0
000043B8  E588      13145          lsl.l     #2,D0
000043BA  25BC 0000 13146          move.l    #1,0(A2,D0.L)
000043BE  0001 0800 
                    13147   ; /* ... the same thing until task is created.              */
                    13148   ; OS_EXIT_CRITICAL();
000043C2  46DF      13149          dc.w      18143
                    13150   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u)
                    13151   ; OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
000043C4  C8BC 0000 13152          and.l     #65535,D4
000043C8  FFFF      
000043CA  2F04      13153          move.l    D4,-(A7)
000043CC  2F2E 0020 13154          move.l    32(A6),-(A7)
000043D0  2F2E 001C 13155          move.l    28(A6),-(A7)
000043D4  4EB9 0000 13156          jsr       _OS_TaskStkClr
000043D8  4BBC      
000043DA  DEFC 000C 13157          add.w     #12,A7
                    13158   ; #endif
                    13159   ; psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
000043DE  C8BC 0000 13160          and.l     #65535,D4
000043E2  FFFF      
000043E4  2F04      13161          move.l    D4,-(A7)
000043E6  2F2E 0010 13162          move.l    16(A6),-(A7)
000043EA  2F2E 000C 13163          move.l    12(A6),-(A7)
000043EE  2F2E 0008 13164          move.l    8(A6),-(A7)
000043F2  4EB8 05A0 13165          jsr       _OSTaskStkInit
000043F6  DEFC 0010 13166          add.w     #16,A7
000043FA  2D40 FFFC 13167          move.l    D0,-4(A6)
                    13168   ; err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
000043FE  C8BC 0000 13169          and.l     #65535,D4
00004402  FFFF      
00004404  2F04      13170          move.l    D4,-(A7)
00004406  2F2E 0024 13171          move.l    36(A6),-(A7)
0000440A  2F2E 0020 13172          move.l    32(A6),-(A7)
0000440E  322E 001A 13173          move.w    26(A6),D1
00004412  C2BC 0000 13174          and.l     #65535,D1
00004416  FFFF      
00004418  2F01      13175          move.l    D1,-(A7)
0000441A  2F2E 001C 13176          move.l    28(A6),-(A7)
0000441E  2F2E FFFC 13177          move.l    -4(A6),-(A7)
00004422  C4BC 0000 13178          and.l     #255,D2
00004426  00FF      
00004428  2F02      13179          move.l    D2,-(A7)
0000442A  4EB8 1612 13180          jsr       _OS_TCBInit
0000442E  DEFC 001C 13181          add.w     #28,A7
00004432  1600      13182          move.b    D0,D3
                    13183   ; if (err == OS_ERR_NONE) {
00004434  4A03      13184          tst.b     D3
00004436  6612      13185          bne.s     OSTaskCreateExt_6
                    13186   ; if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
00004438  1039 0080 13187          move.b    _OSRunning.L,D0
0000443C  0258      
0000443E  0C00 0001 13188          cmp.b     #1,D0
00004442  6604      13189          bne.s     OSTaskCreateExt_8
                    13190   ; OS_Sched();
00004444  4EB8 13F8 13191          jsr       _OS_Sched
                    13192   OSTaskCreateExt_8:
00004448  6016      13193          bra.s     OSTaskCreateExt_7
                    13194   OSTaskCreateExt_6:
                    13195   ; }
                    13196   ; } else {
                    13197   ; OS_ENTER_CRITICAL();
0000444A  40E7      13198          dc.w      16615
0000444C  007C      13199          dc.w      124
0000444E  0700      13200          dc.w      1792
                    13201   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
00004450  C4BC 0000 13202          and.l     #255,D2
00004454  00FF      
00004456  2002      13203          move.l    D2,D0
00004458  E588      13204          lsl.l     #2,D0
0000445A  42B2 0800 13205          clr.l     0(A2,D0.L)
                    13206   ; OS_EXIT_CRITICAL();
0000445E  46DF      13207          dc.w      18143
                    13208   OSTaskCreateExt_7:
                    13209   ; }
                    13210   ; return (err);
00004460  1003      13211          move.b    D3,D0
00004462  6004      13212          bra.s     OSTaskCreateExt_3
                    13213   OSTaskCreateExt_4:
                    13214   ; }
                    13215   ; OS_EXIT_CRITICAL();
00004464  46DF      13216          dc.w      18143
                    13217   ; return (OS_ERR_PRIO_EXIST);
00004466  7028      13218          moveq     #40,D0
                    13219   OSTaskCreateExt_3:
00004468  4CDF 041C 13220          movem.l   (A7)+,D2/D3/D4/A2
0000446C  4E5E      13221          unlk      A6
0000446E  4E75      13222          rts
                    13223   ; }
                    13224   ; #endif
                    13225   ; /*$PAGE*/
                    13226   ; /*
                    13227   ; *********************************************************************************************************
                    13228   ; *                                            DELETE A TASK
                    13229   ; *
                    13230   ; * Description: This function allows you to delete a task.  The calling task can delete itself by
                    13231   ; *              its own priority number.  The deleted task is returned to the dormant state and can be
                    13232   ; *              re-activated by creating the deleted task again.
                    13233   ; *
                    13234   ; * Arguments  : prio    is the priority of the task to delete.  Note that you can explicitly delete
                    13235   ; *                      the current task without knowing its priority level by setting 'prio' to
                    13236   ; *                      OS_PRIO_SELF.
                    13237   ; *
                    13238   ; * Returns    : OS_ERR_NONE             if the call is successful
                    13239   ; *              OS_ERR_TASK_DEL_IDLE    if you attempted to delete uC/OS-II's idle task
                    13240   ; *              OS_ERR_PRIO_INVALID     if the priority you specify is higher that the maximum allowed
                    13241   ; *                                      (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13242   ; *              OS_ERR_TASK_DEL         if the task is assigned to a Mutex PIP.
                    13243   ; *              OS_ERR_TASK_NOT_EXIST   if the task you want to delete does not exist.
                    13244   ; *              OS_ERR_TASK_DEL_ISR     if you tried to delete a task from an ISR
                    13245   ; *
                    13246   ; * Notes      : 1) To reduce interrupt latency, OSTaskDel() 'disables' the task:
                    13247   ; *                    a) by making it not ready
                    13248   ; *                    b) by removing it from any wait lists
                    13249   ; *                    c) by preventing OSTimeTick() from making the task ready to run.
                    13250   ; *                 The task can then be 'unlinked' from the miscellaneous structures in uC/OS-II.
                    13251   ; *              2) The function OS_Dummy() is called after OS_EXIT_CRITICAL() because, on most processors,
                    13252   ; *                 the next instruction following the enable interrupt instruction is ignored.
                    13253   ; *              3) An ISR cannot delete a task.
                    13254   ; *              4) The lock nesting counter is incremented because, for a brief instant, if the current
                    13255   ; *                 task is being deleted, the current task would not be able to be rescheduled because it
                    13256   ; *                 is removed from the ready list.  Incrementing the nesting counter prevents another task
                    13257   ; *                 from being schedule.  This means that an ISR would return to the current task which is
                    13258   ; *                 being deleted.  The rest of the deletion would thus be able to be completed.
                    13259   ; *********************************************************************************************************
                    13260   ; */
                    13261   ; #if OS_TASK_DEL_EN > 0u
                    13262   ; INT8U  OSTaskDel (INT8U prio)
                    13263   ; {
                    13264   _OSTaskDel:
00004470  4E56 0000 13265          link      A6,#0
00004474  48E7 3800 13266          movem.l   D2/D3/D4,-(A7)
00004478  162E 000B 13267          move.b    11(A6),D3
0000447C  C6BC 0000 13268          and.l     #255,D3
00004480  00FF      
                    13269   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13270   ; OS_FLAG_NODE *pnode;
                    13271   ; #endif
                    13272   ; OS_TCB       *ptcb;
                    13273   ; #if OS_CRITICAL_METHOD == 3u                            /* Allocate storage for CPU status register    */
                    13274   ; OS_CPU_SR     cpu_sr = 0u;
                    13275   ; #endif
                    13276   ; if (OSIntNesting > 0u) {                            /* See if trying to delete from ISR            */
00004482  1039 0080 13277          move.b    _OSIntNesting.L,D0
00004486  0246      
00004488  0C00 0000 13278          cmp.b     #0,D0
0000448C  6306      13279          bls.s     OSTaskDel_1
                    13280   ; return (OS_ERR_TASK_DEL_ISR);
0000448E  7040      13281          moveq     #64,D0
00004490  6000 01A4 13282          bra       OSTaskDel_3
                    13283   OSTaskDel_1:
                    13284   ; }
                    13285   ; if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
00004494  0C03 003F 13286          cmp.b     #63,D3
00004498  6606      13287          bne.s     OSTaskDel_4
                    13288   ; return (OS_ERR_TASK_DEL_IDLE);
0000449A  703E      13289          moveq     #62,D0
0000449C  6000 0198 13290          bra       OSTaskDel_3
                    13291   OSTaskDel_4:
                    13292   ; }
                    13293   ; #if OS_ARG_CHK_EN > 0u
                    13294   ; if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
                    13295   ; if (prio != OS_PRIO_SELF) {
                    13296   ; return (OS_ERR_PRIO_INVALID);
                    13297   ; }
                    13298   ; }
                    13299   ; #endif
                    13300   ; /*$PAGE*/
                    13301   ; OS_ENTER_CRITICAL();
000044A0  40E7      13302          dc.w      16615
000044A2  007C      13303          dc.w      124
000044A4  0700      13304          dc.w      1792
                    13305   ; if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
000044A6  0C03 00FF 13306          cmp.b     #255,D3
000044AA  660A      13307          bne.s     OSTaskDel_6
                    13308   ; prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
000044AC  2079 0080 13309          move.l    _OSTCBCur.L,A0
000044B0  0360      
000044B2  1628 0034 13310          move.b    52(A0),D3
                    13311   OSTaskDel_6:
                    13312   ; }
                    13313   ; ptcb = OSTCBPrioTbl[prio];
000044B6  C6BC 0000 13314          and.l     #255,D3
000044BA  00FF      
000044BC  2003      13315          move.l    D3,D0
000044BE  E588      13316          lsl.l     #2,D0
000044C0  41F9 0080 13317          lea       _OSTCBPrioTbl.L,A0
000044C4  0370      
000044C6  2430 0800 13318          move.l    0(A0,D0.L),D2
                    13319   ; if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
000044CA  4A82      13320          tst.l     D2
000044CC  6608      13321          bne.s     OSTaskDel_8
                    13322   ; OS_EXIT_CRITICAL();
000044CE  46DF      13323          dc.w      18143
                    13324   ; return (OS_ERR_TASK_NOT_EXIST);
000044D0  7043      13325          moveq     #67,D0
000044D2  6000 0162 13326          bra       OSTaskDel_3
                    13327   OSTaskDel_8:
                    13328   ; }
                    13329   ; if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
000044D6  0C82 0000 13330          cmp.l     #1,D2
000044DA  0001      
000044DC  6608      13331          bne.s     OSTaskDel_10
                    13332   ; OS_EXIT_CRITICAL();
000044DE  46DF      13333          dc.w      18143
                    13334   ; return (OS_ERR_TASK_DEL);
000044E0  703D      13335          moveq     #61,D0
000044E2  6000 0152 13336          bra       OSTaskDel_3
                    13337   OSTaskDel_10:
                    13338   ; }
                    13339   ; OSRdyTbl[ptcb->OSTCBY] &= (OS_PRIO)~ptcb->OSTCBBitX;
000044E6  2042      13340          move.l    D2,A0
000044E8  1028 0036 13341          move.b    54(A0),D0
000044EC  C0BC 0000 13342          and.l     #255,D0
000044F0  00FF      
000044F2  41F9 0080 13343          lea       _OSRdyTbl.L,A0
000044F6  0250      
000044F8  2242      13344          move.l    D2,A1
000044FA  1229 0037 13345          move.b    55(A1),D1
000044FE  4601      13346          not.b     D1
00004500  C330 0800 13347          and.b     D1,0(A0,D0.L)
                    13348   ; if (OSRdyTbl[ptcb->OSTCBY] == 0u) {                 /* Make task not ready                         */
00004504  2042      13349          move.l    D2,A0
00004506  1028 0036 13350          move.b    54(A0),D0
0000450A  C0BC 0000 13351          and.l     #255,D0
0000450E  00FF      
00004510  41F9 0080 13352          lea       _OSRdyTbl.L,A0
00004514  0250      
00004516  1030 0800 13353          move.b    0(A0,D0.L),D0
0000451A  660E      13354          bne.s     OSTaskDel_12
                    13355   ; OSRdyGrp           &= (OS_PRIO)~ptcb->OSTCBBitY;
0000451C  2042      13356          move.l    D2,A0
0000451E  1028 0038 13357          move.b    56(A0),D0
00004522  4600      13358          not.b     D0
00004524  C139 0080 13359          and.b     D0,_OSRdyGrp.L
00004528  024E      
                    13360   OSTaskDel_12:
                    13361   ; }
                    13362   ; #if (OS_EVENT_EN)
                    13363   ; if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
0000452A  2042      13364          move.l    D2,A0
0000452C  2028 001C 13365          move.l    28(A0),D0
00004530  670E      13366          beq.s     OSTaskDel_14
                    13367   ; OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
00004532  2042      13368          move.l    D2,A0
00004534  2F28 001C 13369          move.l    28(A0),-(A7)
00004538  2F02      13370          move.l    D2,-(A7)
0000453A  4EB8 101E 13371          jsr       _OS_EventTaskRemove
0000453E  504F      13372          addq.w    #8,A7
                    13373   OSTaskDel_14:
                    13374   ; }
                    13375   ; #if (OS_EVENT_MULTI_EN > 0u)
                    13376   ; if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
00004540  2042      13377          move.l    D2,A0
00004542  2028 0020 13378          move.l    32(A0),D0
00004546  670E      13379          beq.s     OSTaskDel_16
                    13380   ; OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
00004548  2042      13381          move.l    D2,A0
0000454A  2F28 0020 13382          move.l    32(A0),-(A7)
0000454E  2F02      13383          move.l    D2,-(A7)
00004550  4EB8 1070 13384          jsr       _OS_EventTaskRemoveMulti
00004554  504F      13385          addq.w    #8,A7
                    13386   OSTaskDel_16:
                    13387   ; }
                    13388   ; #endif
                    13389   ; #endif
                    13390   ; #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
                    13391   ; pnode = ptcb->OSTCBFlagNode;
00004556  2042      13392          move.l    D2,A0
00004558  2828 0028 13393          move.l    40(A0),D4
                    13394   ; if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
0000455C  4A84      13395          tst.l     D4
0000455E  6708      13396          beq.s     OSTaskDel_18
                    13397   ; OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
00004560  2F04      13398          move.l    D4,-(A7)
00004562  4EB8 2228 13399          jsr       _OS_FlagUnlink
00004566  584F      13400          addq.w    #4,A7
                    13401   OSTaskDel_18:
                    13402   ; }
                    13403   ; #endif
                    13404   ; ptcb->OSTCBDly      = 0u;                           /* Prevent OSTimeTick() from updating          */
00004568  2042      13405          move.l    D2,A0
0000456A  42A8 002E 13406          clr.l     46(A0)
                    13407   ; ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
0000456E  2042      13408          move.l    D2,A0
00004570  4228 0032 13409          clr.b     50(A0)
                    13410   ; ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
00004574  2042      13411          move.l    D2,A0
00004576  4228 0033 13412          clr.b     51(A0)
                    13413   ; if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
0000457A  1039 0080 13414          move.b    _OSLockNesting.L,D0
0000457E  0248      
00004580  0C00 00FF 13415          cmp.b     #255,D0
00004584  6406      13416          bhs.s     OSTaskDel_20
                    13417   ; OSLockNesting++;
00004586  5239 0080 13418          addq.b    #1,_OSLockNesting.L
0000458A  0248      
                    13419   OSTaskDel_20:
                    13420   ; }
                    13421   ; OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
0000458C  46DF      13422          dc.w      18143
                    13423   ; OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
0000458E  4EB8 0E16 13424          jsr       _OS_Dummy
                    13425   ; OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
00004592  40E7      13426          dc.w      16615
00004594  007C      13427          dc.w      124
00004596  0700      13428          dc.w      1792
                    13429   ; if (OSLockNesting > 0u) {                           /* Remove context switch lock                  */
00004598  1039 0080 13430          move.b    _OSLockNesting.L,D0
0000459C  0248      
0000459E  0C00 0000 13431          cmp.b     #0,D0
000045A2  6306      13432          bls.s     OSTaskDel_22
                    13433   ; OSLockNesting--;
000045A4  5339 0080 13434          subq.b    #1,_OSLockNesting.L
000045A8  0248      
                    13435   OSTaskDel_22:
                    13436   ; }
                    13437   ; OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
000045AA  2F02      13438          move.l    D2,-(A7)
000045AC  4EB8 06E4 13439          jsr       _OSTaskDelHook
000045B0  584F      13440          addq.w    #4,A7
                    13441   ; OSTaskCtr--;                                        /* One less task being managed                 */
000045B2  5339 0080 13442          subq.b    #1,_OSTaskCtr.L
000045B6  025A      
                    13443   ; OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
000045B8  C6BC 0000 13444          and.l     #255,D3
000045BC  00FF      
000045BE  2003      13445          move.l    D3,D0
000045C0  E588      13446          lsl.l     #2,D0
000045C2  41F9 0080 13447          lea       _OSTCBPrioTbl.L,A0
000045C6  0370      
000045C8  42B0 0800 13448          clr.l     0(A0,D0.L)
                    13449   ; if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
000045CC  2042      13450          move.l    D2,A0
000045CE  2028 0018 13451          move.l    24(A0),D0
000045D2  6616      13452          bne.s     OSTaskDel_24
                    13453   ; ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
000045D4  2042      13454          move.l    D2,A0
000045D6  2068 0014 13455          move.l    20(A0),A0
000045DA  42A8 0018 13456          clr.l     24(A0)
                    13457   ; OSTCBList                  = ptcb->OSTCBNext;
000045DE  2042      13458          move.l    D2,A0
000045E0  23E8 0014 13459          move.l    20(A0),_OSTCBList.L
000045E4  0080 036C 
000045E8  601C      13460          bra.s     OSTaskDel_25
                    13461   OSTaskDel_24:
                    13462   ; } else {
                    13463   ; ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
000045EA  2042      13464          move.l    D2,A0
000045EC  2242      13465          move.l    D2,A1
000045EE  2269 0018 13466          move.l    24(A1),A1
000045F2  2368 0014 13467          move.l    20(A0),20(A1)
000045F6  0014      
                    13468   ; ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
000045F8  2042      13469          move.l    D2,A0
000045FA  2242      13470          move.l    D2,A1
000045FC  2269 0014 13471          move.l    20(A1),A1
00004600  2368 0018 13472          move.l    24(A0),24(A1)
00004604  0018      
                    13473   OSTaskDel_25:
                    13474   ; }
                    13475   ; ptcb->OSTCBNext     = OSTCBFreeList;                /* Return TCB to free TCB list                 */
00004606  2042      13476          move.l    D2,A0
00004608  2179 0080 13477          move.l    _OSTCBFreeList.L,20(A0)
0000460C  0364 0014 
                    13478   ; OSTCBFreeList       = ptcb;
00004610  23C2 0080 13479          move.l    D2,_OSTCBFreeList.L
00004614  0364      
                    13480   ; #if OS_TASK_NAME_EN > 0u
                    13481   ; ptcb->OSTCBTaskName = (INT8U *)(void *)"?";
00004616  41F9 0000 13482          lea       @ucos_ii_1.L,A0
0000461A  5A8E      
0000461C  2242      13483          move.l    D2,A1
0000461E  2348 004E 13484          move.l    A0,78(A1)
                    13485   ; #endif
                    13486   ; OS_EXIT_CRITICAL();
00004622  46DF      13487          dc.w      18143
                    13488   ; if (OSRunning == OS_TRUE) {
00004624  1039 0080 13489          move.b    _OSRunning.L,D0
00004628  0258      
0000462A  0C00 0001 13490          cmp.b     #1,D0
0000462E  6604      13491          bne.s     OSTaskDel_26
                    13492   ; OS_Sched();                                     /* Find new highest priority task              */
00004630  4EB8 13F8 13493          jsr       _OS_Sched
                    13494   OSTaskDel_26:
                    13495   ; }
                    13496   ; return (OS_ERR_NONE);
00004634  4200      13497          clr.b     D0
                    13498   OSTaskDel_3:
00004636  4CDF 001C 13499          movem.l   (A7)+,D2/D3/D4
0000463A  4E5E      13500          unlk      A6
0000463C  4E75      13501          rts
                    13502   ; }
                    13503   ; #endif
                    13504   ; /*$PAGE*/
                    13505   ; /*
                    13506   ; *********************************************************************************************************
                    13507   ; *                                  REQUEST THAT A TASK DELETE ITSELF
                    13508   ; *
                    13509   ; * Description: This function is used to:
                    13510   ; *                   a) notify a task to delete itself.
                    13511   ; *                   b) to see if a task requested that the current task delete itself.
                    13512   ; *              This function is a little tricky to understand.  Basically, you have a task that needs
                    13513   ; *              to be deleted however, this task has resources that it has allocated (memory buffers,
                    13514   ; *              semaphores, mailboxes, queues etc.).  The task cannot be deleted otherwise these
                    13515   ; *              resources would not be freed.  The requesting task calls OSTaskDelReq() to indicate that
                    13516   ; *              the task needs to be deleted.  Deleting of the task is however, deferred to the task to
                    13517   ; *              be deleted.  For example, suppose that task #10 needs to be deleted.  The requesting task
                    13518   ; *              example, task #5, would call OSTaskDelReq(10).  When task #10 gets to execute, it calls
                    13519   ; *              this function by specifying OS_PRIO_SELF and monitors the returned value.  If the return
                    13520   ; *              value is OS_ERR_TASK_DEL_REQ, another task requested a task delete.  Task #10 would look like
                    13521   ; *              this:
                    13522   ; *
                    13523   ; *                   void Task(void *p_arg)
                    13524   ; *                   {
                    13525   ; *                       .
                    13526   ; *                       .
                    13527   ; *                       while (1) {
                    13528   ; *                           OSTimeDly(1);
                    13529   ; *                           if (OSTaskDelReq(OS_PRIO_SELF) == OS_ERR_TASK_DEL_REQ) {
                    13530   ; *                               Release any owned resources;
                    13531   ; *                               De-allocate any dynamic memory;
                    13532   ; *                               OSTaskDel(OS_PRIO_SELF);
                    13533   ; *                           }
                    13534   ; *                       }
                    13535   ; *                   }
                    13536   ; *
                    13537   ; * Arguments  : prio    is the priority of the task to request the delete from
                    13538   ; *
                    13539   ; * Returns    : OS_ERR_NONE            if the task exist and the request has been registered
                    13540   ; *              OS_ERR_TASK_NOT_EXIST  if the task has been deleted.  This allows the caller to know whether
                    13541   ; *                                     the request has been executed.
                    13542   ; *              OS_ERR_TASK_DEL        if the task is assigned to a Mutex.
                    13543   ; *              OS_ERR_TASK_DEL_IDLE   if you requested to delete uC/OS-II's idle task
                    13544   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    13545   ; *                                     (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    13546   ; *              OS_ERR_TASK_DEL_REQ    if a task (possibly another task) requested that the running task be
                    13547   ; *                                     deleted.
                    13548   ; *********************************************************************************************************
                    13549   ; */
                    13550   ; /*$PAGE*/
                    13551   ; #if OS_TASK_DEL_EN > 0u
                    13552   ; INT8U  OSTaskDelReq (INT8U prio)
                    13553   ; {
                    13554   _OSTaskDelReq:
0000463E  4E56 FFFC 13555          link      A6,#-4
00004642  48E7 3000 13556          movem.l   D2/D3,-(A7)
00004646  162E 000B 13557          move.b    11(A6),D3
0000464A  C6BC 0000 13558          and.l     #255,D3
0000464E  00FF      
                    13559   ; INT8U      stat;
                    13560   ; OS_TCB    *ptcb;
                    13561   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    13562   ; OS_CPU_SR  cpu_sr = 0u;
                    13563   ; #endif
                    13564   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
00004650  0C03 003F 13565          cmp.b     #63,D3
00004654  6606      13566          bne.s     OSTaskDelReq_1
                    13567   ; return (OS_ERR_TASK_DEL_IDLE);
00004656  703E      13568          moveq     #62,D0
00004658  6000 0062 13569          bra       OSTaskDelReq_3
                    13570   OSTaskDelReq_1:
                    13571   ; }
                    13572   ; #if OS_ARG_CHK_EN > 0u
                    13573   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    13574   ; if (prio != OS_PRIO_SELF) {
                    13575   ; return (OS_ERR_PRIO_INVALID);
                    13576   ; }
                    13577   ; }
                    13578   ; #endif
                    13579   ; if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
0000465C  0C03 00FF 13580          cmp.b     #255,D3
00004660  661C      13581          bne.s     OSTaskDelReq_4
                    13582   ; OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
00004662  40E7      13583          dc.w      16615
00004664  007C      13584          dc.w      124
00004666  0700      13585          dc.w      1792
                    13586   ; stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
00004668  2079 0080 13587          move.l    _OSTCBCur.L,A0
0000466C  0360      
0000466E  1D68 0039 13588          move.b    57(A0),-1(A6)
00004672  FFFF      
                    13589   ; OS_EXIT_CRITICAL();
00004674  46DF      13590          dc.w      18143
                    13591   ; return (stat);
00004676  102E FFFF 13592          move.b    -1(A6),D0
0000467A  6000 0040 13593          bra       OSTaskDelReq_3
                    13594   OSTaskDelReq_4:
                    13595   ; }
                    13596   ; OS_ENTER_CRITICAL();
0000467E  40E7      13597          dc.w      16615
00004680  007C      13598          dc.w      124
00004682  0700      13599          dc.w      1792
                    13600   ; ptcb = OSTCBPrioTbl[prio];
00004684  C6BC 0000 13601          and.l     #255,D3
00004688  00FF      
0000468A  2003      13602          move.l    D3,D0
0000468C  E588      13603          lsl.l     #2,D0
0000468E  41F9 0080 13604          lea       _OSTCBPrioTbl.L,A0
00004692  0370      
00004694  2430 0800 13605          move.l    0(A0,D0.L),D2
                    13606   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
00004698  4A82      13607          tst.l     D2
0000469A  6606      13608          bne.s     OSTaskDelReq_6
                    13609   ; OS_EXIT_CRITICAL();
0000469C  46DF      13610          dc.w      18143
                    13611   ; return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
0000469E  7043      13612          moveq     #67,D0
000046A0  601A      13613          bra.s     OSTaskDelReq_3
                    13614   OSTaskDelReq_6:
                    13615   ; }
                    13616   ; if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
000046A2  0C82 0000 13617          cmp.l     #1,D2
000046A6  0001      
000046A8  6606      13618          bne.s     OSTaskDelReq_8
                    13619   ; OS_EXIT_CRITICAL();
000046AA  46DF      13620          dc.w      18143
                    13621   ; return (OS_ERR_TASK_DEL);
000046AC  703D      13622          moveq     #61,D0
000046AE  600C      13623          bra.s     OSTaskDelReq_3
                    13624   OSTaskDelReq_8:
                    13625   ; }
                    13626   ; ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
000046B0  2042      13627          move.l    D2,A0
000046B2  117C 003F 13628          move.b    #63,57(A0)
000046B6  0039      
                    13629   ; OS_EXIT_CRITICAL();
000046B8  46DF      13630          dc.w      18143
                    13631   ; return (OS_ERR_NONE);
000046BA  4200      13632          clr.b     D0
                    13633   OSTaskDelReq_3:
000046BC  4CDF 000C 13634          movem.l   (A7)+,D2/D3
000046C0  4E5E      13635          unlk      A6
000046C2  4E75      13636          rts
                    13637   ; }
                    13638   ; #endif
                    13639   ; /*$PAGE*/
                    13640   ; /*
                    13641   ; *********************************************************************************************************
                    13642   ; *                                       GET THE NAME OF A TASK
                    13643   ; *
                    13644   ; * Description: This function is called to obtain the name of a task.
                    13645   ; *
                    13646   ; * Arguments  : prio      is the priority of the task that you want to obtain the name from.
                    13647   ; *
                    13648   ; *              pname     is a pointer to a pointer to an ASCII string that will receive the name of the task.
                    13649   ; *
                    13650   ; *              perr      is a pointer to an error code that can contain one of the following values:
                    13651   ; *
                    13652   ; *                        OS_ERR_NONE                if the requested task is resumed
                    13653   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    13654   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    13655   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    13656   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    13657   ; *                        OS_ERR_NAME_GET_ISR        You called this function from an ISR
                    13658   ; *
                    13659   ; *
                    13660   ; * Returns    : The length of the string or 0 if the task does not exist.
                    13661   ; *********************************************************************************************************
                    13662   ; */
                    13663   ; #if OS_TASK_NAME_EN > 0u
                    13664   ; INT8U  OSTaskNameGet (INT8U    prio,
                    13665   ; INT8U  **pname,
                    13666   ; INT8U   *perr)
                    13667   ; {
                    13668   _OSTaskNameGet:
000046C4  4E56 FFFC 13669          link      A6,#-4
000046C8  48E7 3800 13670          movem.l   D2/D3/D4,-(A7)
000046CC  262E 0010 13671          move.l    16(A6),D3
000046D0  182E 000B 13672          move.b    11(A6),D4
000046D4  C8BC 0000 13673          and.l     #255,D4
000046D8  00FF      
                    13674   ; OS_TCB    *ptcb;
                    13675   ; INT8U      len;
                    13676   ; #if OS_CRITICAL_METHOD == 3u                             /* Allocate storage for CPU status register   */
                    13677   ; OS_CPU_SR  cpu_sr = 0u;
                    13678   ; #endif
                    13679   ; #ifdef OS_SAFETY_CRITICAL
                    13680   ; if (perr == (INT8U *)0) {
                    13681   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13682   ; return (0u);
                    13683   ; }
                    13684   ; #endif
                    13685   ; #if OS_ARG_CHK_EN > 0u
                    13686   ; if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
                    13687   ; if (prio != OS_PRIO_SELF) {
                    13688   ; *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
                    13689   ; return (0u);
                    13690   ; }
                    13691   ; }
                    13692   ; if (pname == (INT8U **)0) {                          /* Is 'pname' a NULL pointer?                 */
                    13693   ; *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
                    13694   ; return (0u);
                    13695   ; }
                    13696   ; #endif
                    13697   ; if (OSIntNesting > 0u) {                              /* See if trying to call from an ISR          */
000046DA  1039 0080 13698          move.b    _OSIntNesting.L,D0
000046DE  0246      
000046E0  0C00 0000 13699          cmp.b     #0,D0
000046E4  630C      13700          bls.s     OSTaskNameGet_1
                    13701   ; *perr = OS_ERR_NAME_GET_ISR;
000046E6  2043      13702          move.l    D3,A0
000046E8  10BC 0011 13703          move.b    #17,(A0)
                    13704   ; return (0u);
000046EC  4200      13705          clr.b     D0
000046EE  6000 0076 13706          bra       OSTaskNameGet_3
                    13707   OSTaskNameGet_1:
                    13708   ; }
                    13709   ; OS_ENTER_CRITICAL();
000046F2  40E7      13710          dc.w      16615
000046F4  007C      13711          dc.w      124
000046F6  0700      13712          dc.w      1792
                    13713   ; if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
000046F8  0C04 00FF 13714          cmp.b     #255,D4
000046FC  660A      13715          bne.s     OSTaskNameGet_4
                    13716   ; prio = OSTCBCur->OSTCBPrio;
000046FE  2079 0080 13717          move.l    _OSTCBCur.L,A0
00004702  0360      
00004704  1828 0034 13718          move.b    52(A0),D4
                    13719   OSTaskNameGet_4:
                    13720   ; }
                    13721   ; ptcb = OSTCBPrioTbl[prio];
00004708  C8BC 0000 13722          and.l     #255,D4
0000470C  00FF      
0000470E  2004      13723          move.l    D4,D0
00004710  E588      13724          lsl.l     #2,D0
00004712  41F9 0080 13725          lea       _OSTCBPrioTbl.L,A0
00004716  0370      
00004718  2430 0800 13726          move.l    0(A0,D0.L),D2
                    13727   ; if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
0000471C  4A82      13728          tst.l     D2
0000471E  660E      13729          bne.s     OSTaskNameGet_6
                    13730   ; OS_EXIT_CRITICAL();                              /* No                                         */
00004720  46DF      13731          dc.w      18143
                    13732   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004722  2043      13733          move.l    D3,A0
00004724  10BC 0043 13734          move.b    #67,(A0)
                    13735   ; return (0u);
00004728  4200      13736          clr.b     D0
0000472A  6000 003A 13737          bra       OSTaskNameGet_3
                    13738   OSTaskNameGet_6:
                    13739   ; }
                    13740   ; if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
0000472E  0C82 0000 13741          cmp.l     #1,D2
00004732  0001      
00004734  660C      13742          bne.s     OSTaskNameGet_8
                    13743   ; OS_EXIT_CRITICAL();                              /* Yes                                        */
00004736  46DF      13744          dc.w      18143
                    13745   ; *perr = OS_ERR_TASK_NOT_EXIST;
00004738  2043      13746          move.l    D3,A0
0000473A  10BC 0043 13747          move.b    #67,(A0)
                    13748   ; return (0u);
0000473E  4200      13749          clr.b     D0
00004740  6024      13750          bra.s     OSTaskNameGet_3
                    13751   OSTaskNameGet_8:
                    13752   ; }
                    13753   ; *pname = ptcb->OSTCBTaskName;
00004742  2042      13754          move.l    D2,A0
00004744  226E 000C 13755          move.l    12(A6),A1
00004748  22A8 004E 13756          move.l    78(A0),(A1)
                    13757   ; len    = OS_StrLen(*pname);
0000474C  206E 000C 13758          move.l    12(A6),A0
00004750  2F10      13759          move.l    (A0),-(A7)
00004752  4EB8 14A2 13760          jsr       _OS_StrLen
00004756  584F      13761          addq.w    #4,A7
00004758  1D40 FFFF 13762          move.b    D0,-1(A6)
                    13763   ; OS_EXIT_CRITICAL();
0000475C  46DF      13764          dc.w      18143
                    13765   ; *perr  = OS_ERR_NONE;
0000475E  2043      13766          move.l    D3,A0
00004760  4210      13767          clr.b     (A0)
                    13768   ; return (len);
00004762  102E FFFF 13769          move.b    -1(A6),D0
                    13770   OSTaskNameGet_3:
00004766  4CDF 001C 13771          movem.l   (A7)+,D2/D3/D4
0000476A  4E5E      13772          unlk      A6
0000476C  4E75      13773          rts
                    13774   ; }
                    13775   ; #endif
                    13776   ; /*$PAGE*/
                    13777   ; /*
                    13778   ; *********************************************************************************************************
                    13779   ; *                                       ASSIGN A NAME TO A TASK
                    13780   ; *
                    13781   ; * Description: This function is used to set the name of a task.
                    13782   ; *
                    13783   ; * Arguments  : prio      is the priority of the task that you want the assign a name to.
                    13784   ; *
                    13785   ; *              pname     is a pointer to an ASCII string that contains the name of the task.
                    13786   ; *
                    13787   ; *              perr       is a pointer to an error code that can contain one of the following values:
                    13788   ; *
                    13789   ; *                        OS_ERR_NONE                if the requested task is resumed
                    13790   ; *                        OS_ERR_TASK_NOT_EXIST      if the task has not been created or is assigned to a Mutex
                    13791   ; *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
                    13792   ; *                        OS_ERR_PRIO_INVALID        if you specified an invalid priority:
                    13793   ; *                                                   A higher value than the idle task or not OS_PRIO_SELF.
                    13794   ; *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
                    13795   ; *
                    13796   ; * Returns    : None
                    13797   ; *********************************************************************************************************
                    13798   ; */
                    13799   ; #if OS_TASK_NAME_EN > 0u
                    13800   ; void  OSTaskNameSet (INT8U   prio,
                    13801   ; INT8U  *pname,
                    13802   ; INT8U  *perr)
                    13803   ; {
                    13804   _OSTaskNameSet:
0000476E  4E56 0000 13805          link      A6,#0
00004772  48E7 3800 13806          movem.l   D2/D3/D4,-(A7)
00004776  262E 0010 13807          move.l    16(A6),D3
0000477A  182E 000B 13808          move.b    11(A6),D4
0000477E  C8BC 0000 13809          and.l     #255,D4
00004782  00FF      
                    13810   ; OS_TCB    *ptcb;
                    13811   ; #if OS_CRITICAL_METHOD == 3u                         /* Allocate storage for CPU status register       */
                    13812   ; OS_CPU_SR  cpu_sr = 0u;
                    13813   ; #endif
                    13814   ; #ifdef OS_SAFETY_CRITICAL
                    13815   ; if (perr == (INT8U *)0) {
                    13816   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    13817   ; return;
                    13818   ; }
                    13819   ; #endif
                    13820   ; #if OS_ARG_CHK_EN > 0u
                    13821   ; if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
                    13822   ; if (prio != OS_PRIO_SELF) {
                    13823   ; *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
                    13824   ; return;
                    13825   ; }
                    13826   ; }
                    13827   ; if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
                    13828   ; *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
                    13829   ; return;
                    13830   ; }
                    13831   ; #endif
                    13832   ; if (OSIntNesting > 0u) {                         /* See if trying to call from an ISR              */
00004784  1039 0080 13833          move.b    _OSIntNesting.L,D0
00004788  0246      
0000478A  0C00 0000 13834          cmp.b     #0,D0
0000478E  630A      13835          bls.s     OSTaskNameSet_1
                    13836   ; *perr = OS_ERR_NAME_SET_ISR;
00004790  2043      13837          move.l    D3,A0
00004792  10BC 0012 13838          move.b    #18,(A0)
                    13839   ; return;
00004796  6000 005A 13840          bra       OSTaskNameSet_3
                    13841   OSTaskNameSet_1:
                    13842   ; }
                    13843   ; OS_ENTER_CRITICAL();
0000479A  40E7      13844          dc.w      16615
0000479C  007C      13845          dc.w      124
0000479E  0700      13846          dc.w      1792
                    13847   ; if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
000047A0  0C04 00FF 13848          cmp.b     #255,D4
000047A4  660A      13849          bne.s     OSTaskNameSet_4
                    13850   ; prio = OSTCBCur->OSTCBPrio;
000047A6  2079 0080 13851          move.l    _OSTCBCur.L,A0
000047AA  0360      
000047AC  1828 0034 13852          move.b    52(A0),D4
                    13853   OSTaskNameSet_4:
                    13854   ; }
                    13855   ; ptcb = OSTCBPrioTbl[prio];
000047B0  C8BC 0000 13856          and.l     #255,D4
000047B4  00FF      
000047B6  2004      13857          move.l    D4,D0
000047B8  E588      13858          lsl.l     #2,D0
000047BA  41F9 0080 13859          lea       _OSTCBPrioTbl.L,A0
000047BE  0370      
000047C0  2430 0800 13860          move.l    0(A0,D0.L),D2
                    13861   ; if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
000047C4  4A82      13862          tst.l     D2
000047C6  660A      13863          bne.s     OSTaskNameSet_6
                    13864   ; OS_EXIT_CRITICAL();                          /* No                                             */
000047C8  46DF      13865          dc.w      18143
                    13866   ; *perr = OS_ERR_TASK_NOT_EXIST;
000047CA  2043      13867          move.l    D3,A0
000047CC  10BC 0043 13868          move.b    #67,(A0)
                    13869   ; return;
000047D0  6020      13870          bra.s     OSTaskNameSet_3
                    13871   OSTaskNameSet_6:
                    13872   ; }
                    13873   ; if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
000047D2  0C82 0000 13874          cmp.l     #1,D2
000047D6  0001      
000047D8  660A      13875          bne.s     OSTaskNameSet_8
                    13876   ; OS_EXIT_CRITICAL();                          /* Yes                                            */
000047DA  46DF      13877          dc.w      18143
                    13878   ; *perr = OS_ERR_TASK_NOT_EXIST;
000047DC  2043      13879          move.l    D3,A0
000047DE  10BC 0043 13880          move.b    #67,(A0)
                    13881   ; return;
000047E2  600E      13882          bra.s     OSTaskNameSet_3
                    13883   OSTaskNameSet_8:
                    13884   ; }
                    13885   ; ptcb->OSTCBTaskName = pname;
000047E4  2042      13886          move.l    D2,A0
000047E6  216E 000C 13887          move.l    12(A6),78(A0)
000047EA  004E      
                    13888   ; OS_EXIT_CRITICAL();
000047EC  46DF      13889          dc.w      18143
                    13890   ; *perr               = OS_ERR_NONE;
000047EE  2043      13891          move.l    D3,A0
000047F0  4210      13892          clr.b     (A0)
                    13893   OSTaskNameSet_3:
000047F2  4CDF 001C 13894          movem.l   (A7)+,D2/D3/D4
000047F6  4E5E      13895          unlk      A6
000047F8  4E75      13896          rts
                    13897   ; }
                    13898   ; #endif
                    13899   ; /*$PAGE*/
                    13900   ; /*
                    13901   ; *********************************************************************************************************
                    13902   ; *                                       RESUME A SUSPENDED TASK
                    13903   ; *
                    13904   ; * Description: This function is called to resume a previously suspended task.  This is the only call that
                    13905   ; *              will remove an explicit task suspension.
                    13906   ; *
                    13907   ; * Arguments  : prio     is the priority of the task to resume.
                    13908   ; *
                    13909   ; * Returns    : OS_ERR_NONE                if the requested task is resumed
                    13910   ; *              OS_ERR_PRIO_INVALID        if the priority you specify is higher that the maximum allowed
                    13911   ; *                                         (i.e. >= OS_LOWEST_PRIO)
                    13912   ; *              OS_ERR_TASK_RESUME_PRIO    if the task to resume does not exist
                    13913   ; *              OS_ERR_TASK_NOT_EXIST      if the task is assigned to a Mutex PIP
                    13914   ; *              OS_ERR_TASK_NOT_SUSPENDED  if the task to resume has not been suspended
                    13915   ; *********************************************************************************************************
                    13916   ; */
                    13917   ; #if OS_TASK_SUSPEND_EN > 0u
                    13918   ; INT8U  OSTaskResume (INT8U prio)
                    13919   ; {
                    13920   _OSTaskResume:
000047FA  4E56 0000 13921          link      A6,#0
000047FE  2F02      13922          move.l    D2,-(A7)
                    13923   ; OS_TCB    *ptcb;
                    13924   ; #if OS_CRITICAL_METHOD == 3u                                  /* Storage for CPU status register       */
                    13925   ; OS_CPU_SR  cpu_sr = 0u;
                    13926   ; #endif
                    13927   ; #if OS_ARG_CHK_EN > 0u
                    13928   ; if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
                    13929   ; return (OS_ERR_PRIO_INVALID);
                    13930   ; }
                    13931   ; #endif
                    13932   ; OS_ENTER_CRITICAL();
00004800  40E7      13933          dc.w      16615
00004802  007C      13934          dc.w      124
00004804  0700      13935          dc.w      1792
                    13936   ; ptcb = OSTCBPrioTbl[prio];
00004806  102E 000B 13937          move.b    11(A6),D0
0000480A  C0BC 0000 13938          and.l     #255,D0
0000480E  00FF      
00004810  E588      13939          lsl.l     #2,D0
00004812  41F9 0080 13940          lea       _OSTCBPrioTbl.L,A0
00004816  0370      
00004818  2430 0800 13941          move.l    0(A0,D0.L),D2
                    13942   ; if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
0000481C  4A82      13943          tst.l     D2
0000481E  6608      13944          bne.s     OSTaskResume_1
                    13945   ; OS_EXIT_CRITICAL();
00004820  46DF      13946          dc.w      18143
                    13947   ; return (OS_ERR_TASK_RESUME_PRIO);
00004822  7046      13948          moveq     #70,D0
00004824  6000 0088 13949          bra       OSTaskResume_3
                    13950   OSTaskResume_1:
                    13951   ; }
                    13952   ; if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
00004828  0C82 0000 13953          cmp.l     #1,D2
0000482C  0001      
0000482E  6608      13954          bne.s     OSTaskResume_4
                    13955   ; OS_EXIT_CRITICAL();
00004830  46DF      13956          dc.w      18143
                    13957   ; return (OS_ERR_TASK_NOT_EXIST);
00004832  7043      13958          moveq     #67,D0
00004834  6000 0078 13959          bra       OSTaskResume_3
                    13960   OSTaskResume_4:
                    13961   ; }
                    13962   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
00004838  2042      13963          move.l    D2,A0
0000483A  1028 0032 13964          move.b    50(A0),D0
0000483E  C03C 0008 13965          and.b     #8,D0
00004842  6700 0066 13966          beq       OSTaskResume_6
                    13967   ; ptcb->OSTCBStat &= (INT8U)~(INT8U)OS_STAT_SUSPEND;    /* Remove suspension                     */
00004846  2042      13968          move.l    D2,A0
00004848  7008      13969          moveq     #8,D0
0000484A  4600      13970          not.b     D0
0000484C  C128 0032 13971          and.b     D0,50(A0)
                    13972   ; if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
00004850  2042      13973          move.l    D2,A0
00004852  1028 0032 13974          move.b    50(A0),D0
00004856  6600 004C 13975          bne       OSTaskResume_8
                    13976   ; if (ptcb->OSTCBDly == 0u) {
0000485A  2042      13977          move.l    D2,A0
0000485C  2028 002E 13978          move.l    46(A0),D0
00004860  6600 003E 13979          bne       OSTaskResume_10
                    13980   ; OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
00004864  2042      13981          move.l    D2,A0
00004866  1028 0038 13982          move.b    56(A0),D0
0000486A  8139 0080 13983          or.b      D0,_OSRdyGrp.L
0000486E  024E      
                    13984   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00004870  2042      13985          move.l    D2,A0
00004872  1028 0036 13986          move.b    54(A0),D0
00004876  C0BC 0000 13987          and.l     #255,D0
0000487A  00FF      
0000487C  41F9 0080 13988          lea       _OSRdyTbl.L,A0
00004880  0250      
00004882  2242      13989          move.l    D2,A1
00004884  1229 0037 13990          move.b    55(A1),D1
00004888  8330 0800 13991          or.b      D1,0(A0,D0.L)
                    13992   ; OS_EXIT_CRITICAL();
0000488C  46DF      13993          dc.w      18143
                    13994   ; if (OSRunning == OS_TRUE) {
0000488E  1039 0080 13995          move.b    _OSRunning.L,D0
00004892  0258      
00004894  0C00 0001 13996          cmp.b     #1,D0
00004898  6604      13997          bne.s     OSTaskResume_12
                    13998   ; OS_Sched();                               /* Find new highest priority task        */
0000489A  4EB8 13F8 13999          jsr       _OS_Sched
                    14000   OSTaskResume_12:
0000489E  6002      14001          bra.s     OSTaskResume_11
                    14002   OSTaskResume_10:
                    14003   ; }
                    14004   ; } else {
                    14005   ; OS_EXIT_CRITICAL();
000048A0  46DF      14006          dc.w      18143
                    14007   OSTaskResume_11:
000048A2  6002      14008          bra.s     OSTaskResume_9
                    14009   OSTaskResume_8:
                    14010   ; }
                    14011   ; } else {                                              /* Must be pending on event              */
                    14012   ; OS_EXIT_CRITICAL();
000048A4  46DF      14013          dc.w      18143
                    14014   OSTaskResume_9:
                    14015   ; }
                    14016   ; return (OS_ERR_NONE);
000048A6  4200      14017          clr.b     D0
000048A8  6004      14018          bra.s     OSTaskResume_3
                    14019   OSTaskResume_6:
                    14020   ; }
                    14021   ; OS_EXIT_CRITICAL();
000048AA  46DF      14022          dc.w      18143
                    14023   ; return (OS_ERR_TASK_NOT_SUSPENDED);
000048AC  7044      14024          moveq     #68,D0
                    14025   OSTaskResume_3:
000048AE  241F      14026          move.l    (A7)+,D2
000048B0  4E5E      14027          unlk      A6
000048B2  4E75      14028          rts
                    14029   ; }
                    14030   ; #endif
                    14031   ; /*$PAGE*/
                    14032   ; /*
                    14033   ; *********************************************************************************************************
                    14034   ; *                                           STACK CHECKING
                    14035   ; *
                    14036   ; * Description: This function is called to check the amount of free memory left on the specified task's
                    14037   ; *              stack.
                    14038   ; *
                    14039   ; * Arguments  : prio          is the task priority
                    14040   ; *
                    14041   ; *              p_stk_data    is a pointer to a data structure of type OS_STK_DATA.
                    14042   ; *
                    14043   ; * Returns    : OS_ERR_NONE            upon success
                    14044   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14045   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14046   ; *              OS_ERR_TASK_NOT_EXIST  if the desired task has not been created or is assigned to a Mutex PIP
                    14047   ; *              OS_ERR_TASK_OPT        if you did NOT specified OS_TASK_OPT_STK_CHK when the task was created
                    14048   ; *              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
                    14049   ; *********************************************************************************************************
                    14050   ; */
                    14051   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14052   ; INT8U  OSTaskStkChk (INT8U         prio,
                    14053   ; OS_STK_DATA  *p_stk_data)
                    14054   ; {
                    14055   _OSTaskStkChk:
000048B4  4E56 FFF8 14056          link      A6,#-8
000048B8  48E7 3C00 14057          movem.l   D2/D3/D4/D5,-(A7)
000048BC  282E 000C 14058          move.l    12(A6),D4
000048C0  1A2E 000B 14059          move.b    11(A6),D5
000048C4  CABC 0000 14060          and.l     #255,D5
000048C8  00FF      
                    14061   ; OS_TCB    *ptcb;
                    14062   ; OS_STK    *pchk;
                    14063   ; INT32U     nfree;
                    14064   ; INT32U     size;
                    14065   ; #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
                    14066   ; OS_CPU_SR  cpu_sr = 0u;
                    14067   ; #endif
                    14068   ; #if OS_ARG_CHK_EN > 0u
                    14069   ; if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
                    14070   ; if (prio != OS_PRIO_SELF) {
                    14071   ; return (OS_ERR_PRIO_INVALID);
                    14072   ; }
                    14073   ; }
                    14074   ; if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
                    14075   ; return (OS_ERR_PDATA_NULL);
                    14076   ; }
                    14077   ; #endif
                    14078   ; p_stk_data->OSFree = 0u;                           /* Assume failure, set to 0 size                */
000048CA  2044      14079          move.l    D4,A0
000048CC  4290      14080          clr.l     (A0)
                    14081   ; p_stk_data->OSUsed = 0u;
000048CE  2044      14082          move.l    D4,A0
000048D0  42A8 0004 14083          clr.l     4(A0)
                    14084   ; OS_ENTER_CRITICAL();
000048D4  40E7      14085          dc.w      16615
000048D6  007C      14086          dc.w      124
000048D8  0700      14087          dc.w      1792
                    14088   ; if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
000048DA  0C05 00FF 14089          cmp.b     #255,D5
000048DE  660A      14090          bne.s     OSTaskStkChk_1
                    14091   ; prio = OSTCBCur->OSTCBPrio;
000048E0  2079 0080 14092          move.l    _OSTCBCur.L,A0
000048E4  0360      
000048E6  1A28 0034 14093          move.b    52(A0),D5
                    14094   OSTaskStkChk_1:
                    14095   ; }
                    14096   ; ptcb = OSTCBPrioTbl[prio];
000048EA  CABC 0000 14097          and.l     #255,D5
000048EE  00FF      
000048F0  2005      14098          move.l    D5,D0
000048F2  E588      14099          lsl.l     #2,D0
000048F4  41F9 0080 14100          lea       _OSTCBPrioTbl.L,A0
000048F8  0370      
000048FA  2430 0800 14101          move.l    0(A0,D0.L),D2
                    14102   ; if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
000048FE  4A82      14103          tst.l     D2
00004900  6608      14104          bne.s     OSTaskStkChk_3
                    14105   ; OS_EXIT_CRITICAL();
00004902  46DF      14106          dc.w      18143
                    14107   ; return (OS_ERR_TASK_NOT_EXIST);
00004904  7043      14108          moveq     #67,D0
00004906  6000 005C 14109          bra       OSTaskStkChk_5
                    14110   OSTaskStkChk_3:
                    14111   ; }
                    14112   ; if (ptcb == OS_TCB_RESERVED) {
0000490A  0C82 0000 14113          cmp.l     #1,D2
0000490E  0001      
00004910  6608      14114          bne.s     OSTaskStkChk_6
                    14115   ; OS_EXIT_CRITICAL();
00004912  46DF      14116          dc.w      18143
                    14117   ; return (OS_ERR_TASK_NOT_EXIST);
00004914  7043      14118          moveq     #67,D0
00004916  6000 004C 14119          bra       OSTaskStkChk_5
                    14120   OSTaskStkChk_6:
                    14121   ; }
                    14122   ; if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0u) { /* Make sure stack checking option is set      */
0000491A  2042      14123          move.l    D2,A0
0000491C  3028 0010 14124          move.w    16(A0),D0
00004920  C07C 0001 14125          and.w     #1,D0
00004924  6608      14126          bne.s     OSTaskStkChk_8
                    14127   ; OS_EXIT_CRITICAL();
00004926  46DF      14128          dc.w      18143
                    14129   ; return (OS_ERR_TASK_OPT);
00004928  7045      14130          moveq     #69,D0
0000492A  6000 0038 14131          bra       OSTaskStkChk_5
                    14132   OSTaskStkChk_8:
                    14133   ; }
                    14134   ; nfree = 0u;
0000492E  4283      14135          clr.l     D3
                    14136   ; size  = ptcb->OSTCBStkSize;
00004930  2042      14137          move.l    D2,A0
00004932  2D68 000C 14138          move.l    12(A0),-4(A6)
00004936  FFFC      
                    14139   ; pchk  = ptcb->OSTCBStkBottom;
00004938  2042      14140          move.l    D2,A0
0000493A  2D68 0008 14141          move.l    8(A0),-8(A6)
0000493E  FFF8      
                    14142   ; OS_EXIT_CRITICAL();
00004940  46DF      14143          dc.w      18143
                    14144   ; #if OS_STK_GROWTH == 1u
                    14145   ; while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
                    14146   OSTaskStkChk_10:
00004942  206E FFF8 14147          move.l    -8(A6),A0
00004946  54AE FFF8 14148          addq.l    #2,-8(A6)
0000494A  3010      14149          move.w    (A0),D0
0000494C  6604      14150          bne.s     OSTaskStkChk_12
                    14151   ; nfree++;
0000494E  5283      14152          addq.l    #1,D3
00004950  60F0      14153          bra       OSTaskStkChk_10
                    14154   OSTaskStkChk_12:
                    14155   ; }
                    14156   ; #else
                    14157   ; while (*pchk-- == (OS_STK)0) {
                    14158   ; nfree++;
                    14159   ; }
                    14160   ; #endif
                    14161   ; p_stk_data->OSFree = nfree;                       /* Store   number of free entries on the stk     */
00004952  2044      14162          move.l    D4,A0
00004954  2083      14163          move.l    D3,(A0)
                    14164   ; p_stk_data->OSUsed = size - nfree;                /* Compute number of entries used on the stk     */
00004956  202E FFFC 14165          move.l    -4(A6),D0
0000495A  9083      14166          sub.l     D3,D0
0000495C  2044      14167          move.l    D4,A0
0000495E  2140 0004 14168          move.l    D0,4(A0)
                    14169   ; return (OS_ERR_NONE);
00004962  4200      14170          clr.b     D0
                    14171   OSTaskStkChk_5:
00004964  4CDF 003C 14172          movem.l   (A7)+,D2/D3/D4/D5
00004968  4E5E      14173          unlk      A6
0000496A  4E75      14174          rts
                    14175   ; }
                    14176   ; #endif
                    14177   ; /*$PAGE*/
                    14178   ; /*
                    14179   ; *********************************************************************************************************
                    14180   ; *                                           SUSPEND A TASK
                    14181   ; *
                    14182   ; * Description: This function is called to suspend a task.  The task can be the calling task if the
                    14183   ; *              priority passed to OSTaskSuspend() is the priority of the calling task or OS_PRIO_SELF.
                    14184   ; *
                    14185   ; * Arguments  : prio     is the priority of the task to suspend.  If you specify OS_PRIO_SELF, the
                    14186   ; *                       calling task will suspend itself and rescheduling will occur.
                    14187   ; *
                    14188   ; * Returns    : OS_ERR_NONE               if the requested task is suspended
                    14189   ; *              OS_ERR_TASK_SUSPEND_IDLE  if you attempted to suspend the idle task which is not allowed.
                    14190   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    14191   ; *                                        (i.e. >= OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14192   ; *              OS_ERR_TASK_SUSPEND_PRIO  if the task to suspend does not exist
                    14193   ; *              OS_ERR_TASK_NOT_EXITS     if the task is assigned to a Mutex PIP
                    14194   ; *
                    14195   ; * Note       : You should use this function with great care.  If you suspend a task that is waiting for
                    14196   ; *              an event (i.e. a message, a semaphore, a queue ...) you will prevent this task from
                    14197   ; *              running when the event arrives.
                    14198   ; *********************************************************************************************************
                    14199   ; */
                    14200   ; #if OS_TASK_SUSPEND_EN > 0u
                    14201   ; INT8U  OSTaskSuspend (INT8U prio)
                    14202   ; {
                    14203   _OSTaskSuspend:
0000496C  4E56 0000 14204          link      A6,#0
00004970  48E7 3C00 14205          movem.l   D2/D3/D4/D5,-(A7)
00004974  182E 000B 14206          move.b    11(A6),D4
00004978  C8BC 0000 14207          and.l     #255,D4
0000497C  00FF      
                    14208   ; BOOLEAN    self;
                    14209   ; OS_TCB    *ptcb;
                    14210   ; INT8U      y;
                    14211   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14212   ; OS_CPU_SR  cpu_sr = 0u;
                    14213   ; #endif
                    14214   ; #if OS_ARG_CHK_EN > 0u
                    14215   ; if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
                    14216   ; return (OS_ERR_TASK_SUSPEND_IDLE);
                    14217   ; }
                    14218   ; if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
                    14219   ; if (prio != OS_PRIO_SELF) {
                    14220   ; return (OS_ERR_PRIO_INVALID);
                    14221   ; }
                    14222   ; }
                    14223   ; #endif
                    14224   ; OS_ENTER_CRITICAL();
0000497E  40E7      14225          dc.w      16615
00004980  007C      14226          dc.w      124
00004982  0700      14227          dc.w      1792
                    14228   ; if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
00004984  0C04 00FF 14229          cmp.b     #255,D4
00004988  660E      14230          bne.s     OSTaskSuspend_1
                    14231   ; prio = OSTCBCur->OSTCBPrio;
0000498A  2079 0080 14232          move.l    _OSTCBCur.L,A0
0000498E  0360      
00004990  1828 0034 14233          move.b    52(A0),D4
                    14234   ; self = OS_TRUE;
00004994  7601      14235          moveq     #1,D3
00004996  6012      14236          bra.s     OSTaskSuspend_4
                    14237   OSTaskSuspend_1:
                    14238   ; } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
00004998  2079 0080 14239          move.l    _OSTCBCur.L,A0
0000499C  0360      
0000499E  B828 0034 14240          cmp.b     52(A0),D4
000049A2  6604      14241          bne.s     OSTaskSuspend_3
                    14242   ; self = OS_TRUE;
000049A4  7601      14243          moveq     #1,D3
000049A6  6002      14244          bra.s     OSTaskSuspend_4
                    14245   OSTaskSuspend_3:
                    14246   ; } else {
                    14247   ; self = OS_FALSE;                                        /* No suspending another task          */
000049A8  4203      14248          clr.b     D3
                    14249   OSTaskSuspend_4:
                    14250   ; }
                    14251   ; ptcb = OSTCBPrioTbl[prio];
000049AA  C8BC 0000 14252          and.l     #255,D4
000049AE  00FF      
000049B0  2004      14253          move.l    D4,D0
000049B2  E588      14254          lsl.l     #2,D0
000049B4  41F9 0080 14255          lea       _OSTCBPrioTbl.L,A0
000049B8  0370      
000049BA  2430 0800 14256          move.l    0(A0,D0.L),D2
                    14257   ; if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
000049BE  4A82      14258          tst.l     D2
000049C0  6608      14259          bne.s     OSTaskSuspend_5
                    14260   ; OS_EXIT_CRITICAL();
000049C2  46DF      14261          dc.w      18143
                    14262   ; return (OS_ERR_TASK_SUSPEND_PRIO);
000049C4  7048      14263          moveq     #72,D0
000049C6  6000 0066 14264          bra       OSTaskSuspend_7
                    14265   OSTaskSuspend_5:
                    14266   ; }
                    14267   ; if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
000049CA  0C82 0000 14268          cmp.l     #1,D2
000049CE  0001      
000049D0  6608      14269          bne.s     OSTaskSuspend_8
                    14270   ; OS_EXIT_CRITICAL();
000049D2  46DF      14271          dc.w      18143
                    14272   ; return (OS_ERR_TASK_NOT_EXIST);
000049D4  7043      14273          moveq     #67,D0
000049D6  6000 0056 14274          bra       OSTaskSuspend_7
                    14275   OSTaskSuspend_8:
                    14276   ; }
                    14277   ; y            = ptcb->OSTCBY;
000049DA  2042      14278          move.l    D2,A0
000049DC  1A28 0036 14279          move.b    54(A0),D5
                    14280   ; OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;                   /* Make task not ready                 */
000049E0  CABC 0000 14281          and.l     #255,D5
000049E4  00FF      
000049E6  41F9 0080 14282          lea       _OSRdyTbl.L,A0
000049EA  0250      
000049EC  2242      14283          move.l    D2,A1
000049EE  1029 0037 14284          move.b    55(A1),D0
000049F2  4600      14285          not.b     D0
000049F4  C130 5800 14286          and.b     D0,0(A0,D5.L)
                    14287   ; if (OSRdyTbl[y] == 0u) {
000049F8  CABC 0000 14288          and.l     #255,D5
000049FC  00FF      
000049FE  41F9 0080 14289          lea       _OSRdyTbl.L,A0
00004A02  0250      
00004A04  1030 5800 14290          move.b    0(A0,D5.L),D0
00004A08  660E      14291          bne.s     OSTaskSuspend_10
                    14292   ; OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
00004A0A  2042      14293          move.l    D2,A0
00004A0C  1028 0038 14294          move.b    56(A0),D0
00004A10  4600      14295          not.b     D0
00004A12  C139 0080 14296          and.b     D0,_OSRdyGrp.L
00004A16  024E      
                    14297   OSTaskSuspend_10:
                    14298   ; }
                    14299   ; ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
00004A18  2042      14300          move.l    D2,A0
00004A1A  0028 0008 14301          or.b      #8,50(A0)
00004A1E  0032      
                    14302   ; OS_EXIT_CRITICAL();
00004A20  46DF      14303          dc.w      18143
                    14304   ; if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
00004A22  0C03 0001 14305          cmp.b     #1,D3
00004A26  6604      14306          bne.s     OSTaskSuspend_12
                    14307   ; OS_Sched();                                             /* Find new highest priority task      */
00004A28  4EB8 13F8 14308          jsr       _OS_Sched
                    14309   OSTaskSuspend_12:
                    14310   ; }
                    14311   ; return (OS_ERR_NONE);
00004A2C  4200      14312          clr.b     D0
                    14313   OSTaskSuspend_7:
00004A2E  4CDF 003C 14314          movem.l   (A7)+,D2/D3/D4/D5
00004A32  4E5E      14315          unlk      A6
00004A34  4E75      14316          rts
                    14317   ; }
                    14318   ; #endif
                    14319   ; /*$PAGE*/
                    14320   ; /*
                    14321   ; *********************************************************************************************************
                    14322   ; *                                            QUERY A TASK
                    14323   ; *
                    14324   ; * Description: This function is called to obtain a copy of the desired task's TCB.
                    14325   ; *
                    14326   ; * Arguments  : prio         is the priority of the task to obtain information from.
                    14327   ; *
                    14328   ; *              p_task_data  is a pointer to where the desired task's OS_TCB will be stored.
                    14329   ; *
                    14330   ; * Returns    : OS_ERR_NONE            if the requested task is suspended
                    14331   ; *              OS_ERR_PRIO_INVALID    if the priority you specify is higher that the maximum allowed
                    14332   ; *                                     (i.e. > OS_LOWEST_PRIO) or, you have not specified OS_PRIO_SELF.
                    14333   ; *              OS_ERR_PRIO            if the desired task has not been created
                    14334   ; *              OS_ERR_TASK_NOT_EXIST  if the task is assigned to a Mutex PIP
                    14335   ; *              OS_ERR_PDATA_NULL      if 'p_task_data' is a NULL pointer
                    14336   ; *********************************************************************************************************
                    14337   ; */
                    14338   ; #if OS_TASK_QUERY_EN > 0u
                    14339   ; INT8U  OSTaskQuery (INT8U    prio,
                    14340   ; OS_TCB  *p_task_data)
                    14341   ; {
                    14342   _OSTaskQuery:
00004A36  4E56 0000 14343          link      A6,#0
00004A3A  48E7 3000 14344          movem.l   D2/D3,-(A7)
00004A3E  162E 000B 14345          move.b    11(A6),D3
00004A42  C6BC 0000 14346          and.l     #255,D3
00004A46  00FF      
                    14347   ; OS_TCB    *ptcb;
                    14348   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14349   ; OS_CPU_SR  cpu_sr = 0u;
                    14350   ; #endif
                    14351   ; #if OS_ARG_CHK_EN > 0u
                    14352   ; if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
                    14353   ; if (prio != OS_PRIO_SELF) {
                    14354   ; return (OS_ERR_PRIO_INVALID);
                    14355   ; }
                    14356   ; }
                    14357   ; if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
                    14358   ; return (OS_ERR_PDATA_NULL);
                    14359   ; }
                    14360   ; #endif
                    14361   ; OS_ENTER_CRITICAL();
00004A48  40E7      14362          dc.w      16615
00004A4A  007C      14363          dc.w      124
00004A4C  0700      14364          dc.w      1792
                    14365   ; if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
00004A4E  0C03 00FF 14366          cmp.b     #255,D3
00004A52  660A      14367          bne.s     OSTaskQuery_1
                    14368   ; prio = OSTCBCur->OSTCBPrio;
00004A54  2079 0080 14369          move.l    _OSTCBCur.L,A0
00004A58  0360      
00004A5A  1628 0034 14370          move.b    52(A0),D3
                    14371   OSTaskQuery_1:
                    14372   ; }
                    14373   ; ptcb = OSTCBPrioTbl[prio];
00004A5E  C6BC 0000 14374          and.l     #255,D3
00004A62  00FF      
00004A64  2003      14375          move.l    D3,D0
00004A66  E588      14376          lsl.l     #2,D0
00004A68  41F9 0080 14377          lea       _OSTCBPrioTbl.L,A0
00004A6C  0370      
00004A6E  2430 0800 14378          move.l    0(A0,D0.L),D2
                    14379   ; if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
00004A72  4A82      14380          tst.l     D2
00004A74  6606      14381          bne.s     OSTaskQuery_3
                    14382   ; OS_EXIT_CRITICAL();
00004A76  46DF      14383          dc.w      18143
                    14384   ; return (OS_ERR_PRIO);
00004A78  7029      14385          moveq     #41,D0
00004A7A  6024      14386          bra.s     OSTaskQuery_5
                    14387   OSTaskQuery_3:
                    14388   ; }
                    14389   ; if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
00004A7C  0C82 0000 14390          cmp.l     #1,D2
00004A80  0001      
00004A82  6606      14391          bne.s     OSTaskQuery_6
                    14392   ; OS_EXIT_CRITICAL();
00004A84  46DF      14393          dc.w      18143
                    14394   ; return (OS_ERR_TASK_NOT_EXIST);
00004A86  7043      14395          moveq     #67,D0
00004A88  6016      14396          bra.s     OSTaskQuery_5
                    14397   OSTaskQuery_6:
                    14398   ; }
                    14399   ; /* Copy TCB into user storage area                    */
                    14400   ; OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
00004A8A  4878 0056 14401          pea       86
00004A8E  2F02      14402          move.l    D2,-(A7)
00004A90  2F2E 000C 14403          move.l    12(A6),-(A7)
00004A94  4EB8 13CE 14404          jsr       _OS_MemCopy
00004A98  DEFC 000C 14405          add.w     #12,A7
                    14406   ; OS_EXIT_CRITICAL();
00004A9C  46DF      14407          dc.w      18143
                    14408   ; return (OS_ERR_NONE);
00004A9E  4200      14409          clr.b     D0
                    14410   OSTaskQuery_5:
00004AA0  4CDF 000C 14411          movem.l   (A7)+,D2/D3
00004AA4  4E5E      14412          unlk      A6
00004AA6  4E75      14413          rts
                    14414   ; }
                    14415   ; #endif
                    14416   ; /*$PAGE*/
                    14417   ; /*
                    14418   ; *********************************************************************************************************
                    14419   ; *                              GET THE CURRENT VALUE OF A TASK REGISTER
                    14420   ; *
                    14421   ; * Description: This function is called to obtain the current value of a task register.  Task registers
                    14422   ; *              are application specific and can be used to store task specific values such as 'error
                    14423   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14424   ; *
                    14425   ; * Arguments  : prio      is the priority of the task you want to get the task register from.  If you
                    14426   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14427   ; *
                    14428   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14429   ; *                        than OS_TASK_REG_TBL_SIZE
                    14430   ; *
                    14431   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14432   ; *
                    14433   ; *                        OS_ERR_NONE            if the call was successful
                    14434   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14435   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14436   ; *
                    14437   ; * Returns    : The current value of the task's register or 0 if an error is detected.
                    14438   ; *
                    14439   ; * Note(s)    : The maximum number of task variables is 254
                    14440   ; *********************************************************************************************************
                    14441   ; */
                    14442   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14443   ; INT32U  OSTaskRegGet (INT8U   prio,
                    14444   ; INT8U   id,
                    14445   ; INT8U  *perr)
                    14446   ; {
                    14447   _OSTaskRegGet:
00004AA8  4E56 FFFC 14448          link      A6,#-4
00004AAC  2F02      14449          move.l    D2,-(A7)
                    14450   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14451   ; OS_CPU_SR  cpu_sr = 0u;
                    14452   ; #endif
                    14453   ; INT32U     value;
                    14454   ; OS_TCB    *ptcb;
                    14455   ; #ifdef OS_SAFETY_CRITICAL
                    14456   ; if (perr == (INT8U *)0) {
                    14457   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14458   ; return (0u);
                    14459   ; }
                    14460   ; #endif
                    14461   ; #if OS_ARG_CHK_EN > 0u
                    14462   ; if (prio >= OS_LOWEST_PRIO) {
                    14463   ; if (prio != OS_PRIO_SELF) {
                    14464   ; *perr = OS_ERR_PRIO_INVALID;
                    14465   ; return (0u);
                    14466   ; }
                    14467   ; }
                    14468   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14469   ; *perr = OS_ERR_ID_INVALID;
                    14470   ; return (0u);
                    14471   ; }
                    14472   ; #endif
                    14473   ; OS_ENTER_CRITICAL();
00004AAE  40E7      14474          dc.w      16615
00004AB0  007C      14475          dc.w      124
00004AB2  0700      14476          dc.w      1792
                    14477   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
00004AB4  102E 000B 14478          move.b    11(A6),D0
00004AB8  0C00 00FF 14479          cmp.b     #255,D0
00004ABC  6608      14480          bne.s     OSTaskRegGet_1
                    14481   ; ptcb = OSTCBCur;
00004ABE  2439 0080 14482          move.l    _OSTCBCur.L,D2
00004AC2  0360      
00004AC4  6016      14483          bra.s     OSTaskRegGet_2
                    14484   OSTaskRegGet_1:
                    14485   ; } else {
                    14486   ; ptcb = OSTCBPrioTbl[prio];
00004AC6  102E 000B 14487          move.b    11(A6),D0
00004ACA  C0BC 0000 14488          and.l     #255,D0
00004ACE  00FF      
00004AD0  E588      14489          lsl.l     #2,D0
00004AD2  41F9 0080 14490          lea       _OSTCBPrioTbl.L,A0
00004AD6  0370      
00004AD8  2430 0800 14491          move.l    0(A0,D0.L),D2
                    14492   OSTaskRegGet_2:
                    14493   ; }
                    14494   ; value = ptcb->OSTCBRegTbl[id];
00004ADC  2042      14495          move.l    D2,A0
00004ADE  102E 000F 14496          move.b    15(A6),D0
00004AE2  C0BC 0000 14497          and.l     #255,D0
00004AE6  00FF      
00004AE8  E588      14498          lsl.l     #2,D0
00004AEA  D1C0      14499          add.l     D0,A0
00004AEC  2D68 0052 14500          move.l    82(A0),-4(A6)
00004AF0  FFFC      
                    14501   ; OS_EXIT_CRITICAL();
00004AF2  46DF      14502          dc.w      18143
                    14503   ; *perr = OS_ERR_NONE;
00004AF4  206E 0010 14504          move.l    16(A6),A0
00004AF8  4210      14505          clr.b     (A0)
                    14506   ; return (value);
00004AFA  202E FFFC 14507          move.l    -4(A6),D0
00004AFE  241F      14508          move.l    (A7)+,D2
00004B00  4E5E      14509          unlk      A6
00004B02  4E75      14510          rts
                    14511   ; }
                    14512   ; #endif
                    14513   ; /*$PAGE*/
                    14514   ; /*
                    14515   ; ************************************************************************************************************************
                    14516   ; *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
                    14517   ; *
                    14518   ; * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
                    14519   ; *              allocated dynamically instead of statically.
                    14520   ; *
                    14521   ; * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
                    14522   ; *
                    14523   ; *                            OS_ERR_NONE               if the call was successful
                    14524   ; *                            OS_ERR_NO_MORE_ID_AVAIL   if you are attempting to assign more task register IDs than you 
                    14525   ; *                                                           have available through OS_TASK_REG_TBL_SIZE.
                    14526   ; *
                    14527   ; * Returns    : The next available task register 'id' or OS_TASK_REG_TBL_SIZE if an error is detected.
                    14528   ; ************************************************************************************************************************
                    14529   ; */
                    14530   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14531   ; INT8U  OSTaskRegGetID (INT8U  *perr)
                    14532   ; {
                    14533   _OSTaskRegGetID:
00004B04  4E56 FFFC 14534          link      A6,#-4
                    14535   ; #if OS_CRITICAL_METHOD == 3u                                    /* Allocate storage for CPU status register           */
                    14536   ; OS_CPU_SR  cpu_sr = 0u;
                    14537   ; #endif
                    14538   ; INT8U      id;
                    14539   ; #ifdef OS_SAFETY_CRITICAL
                    14540   ; if (perr == (INT8U *)0) {
                    14541   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14542   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
                    14543   ; }
                    14544   ; #endif
                    14545   ; OS_ENTER_CRITICAL();
00004B08  40E7      14546          dc.w      16615
00004B0A  007C      14547          dc.w      124
00004B0C  0700      14548          dc.w      1792
                    14549   ; if (OSTaskRegNextAvailID >= OS_TASK_REG_TBL_SIZE) {         /* See if we exceeded the number of IDs available     */
00004B0E  1039 0080 14550          move.b    _OSTaskRegNextAvailID.L,D0
00004B12  0CB4      
00004B14  0C00 0001 14551          cmp.b     #1,D0
00004B18  650E      14552          blo.s     OSTaskRegGetID_1
                    14553   ; *perr = OS_ERR_NO_MORE_ID_AVAIL;                         /* Yes, cannot allocate more task register IDs        */
00004B1A  206E 0008 14554          move.l    8(A6),A0
00004B1E  10BC 0096 14555          move.b    #150,(A0)
                    14556   ; OS_EXIT_CRITICAL();
00004B22  46DF      14557          dc.w      18143
                    14558   ; return ((INT8U)OS_TASK_REG_TBL_SIZE);
00004B24  7001      14559          moveq     #1,D0
00004B26  601A      14560          bra.s     OSTaskRegGetID_3
                    14561   OSTaskRegGetID_1:
                    14562   ; }
                    14563   ; id   = OSTaskRegNextAvailID;                                /* Assign the next available ID                       */
00004B28  1D79 0080 14564          move.b    _OSTaskRegNextAvailID.L,-1(A6)
00004B2C  0CB4 FFFF 
                    14565   ; OSTaskRegNextAvailID++;                                     /* Increment available ID for next request            */
00004B30  5239 0080 14566          addq.b    #1,_OSTaskRegNextAvailID.L
00004B34  0CB4      
                    14567   ; OS_EXIT_CRITICAL();
00004B36  46DF      14568          dc.w      18143
                    14569   ; *perr = OS_ERR_NONE;
00004B38  206E 0008 14570          move.l    8(A6),A0
00004B3C  4210      14571          clr.b     (A0)
                    14572   ; return (id);
00004B3E  102E FFFF 14573          move.b    -1(A6),D0
                    14574   OSTaskRegGetID_3:
00004B42  4E5E      14575          unlk      A6
00004B44  4E75      14576          rts
                    14577   ; }
                    14578   ; #endif
                    14579   ; /*$PAGE*/
                    14580   ; /*
                    14581   ; *********************************************************************************************************
                    14582   ; *                              SET THE CURRENT VALUE OF A TASK VARIABLE
                    14583   ; *
                    14584   ; * Description: This function is called to change the current value of a task register.  Task registers
                    14585   ; *              are application specific and can be used to store task specific values such as 'error
                    14586   ; *              numbers' (i.e. errno), statistics, etc.  Each task register can hold a 32-bit value.
                    14587   ; *
                    14588   ; * Arguments  : prio      is the priority of the task you want to set the task register for.  If you
                    14589   ; *                        specify OS_PRIO_SELF then the task register of the current task will be obtained.
                    14590   ; *
                    14591   ; *              id        is the 'id' of the desired task register.  Note that the 'id' must be less
                    14592   ; *                        than OS_TASK_REG_TBL_SIZE
                    14593   ; *
                    14594   ; *              value     is the desired value for the task register.
                    14595   ; *
                    14596   ; *              perr      is a pointer to a variable that will hold an error code related to this call.
                    14597   ; *
                    14598   ; *                        OS_ERR_NONE            if the call was successful
                    14599   ; *                        OS_ERR_PRIO_INVALID    if you specified an invalid priority
                    14600   ; *                        OS_ERR_ID_INVALID      if the 'id' is not between 0 and OS_TASK_REG_TBL_SIZE-1
                    14601   ; *
                    14602   ; * Returns    : The current value of the task's variable or 0 if an error is detected.
                    14603   ; *
                    14604   ; * Note(s)    : The maximum number of task variables is 254
                    14605   ; *********************************************************************************************************
                    14606   ; */
                    14607   ; #if OS_TASK_REG_TBL_SIZE > 0u
                    14608   ; void  OSTaskRegSet (INT8U    prio,
                    14609   ; INT8U    id,
                    14610   ; INT32U   value,
                    14611   ; INT8U   *perr)
                    14612   ; {
                    14613   _OSTaskRegSet:
00004B46  4E56 0000 14614          link      A6,#0
00004B4A  2F02      14615          move.l    D2,-(A7)
                    14616   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14617   ; OS_CPU_SR  cpu_sr = 0u;
                    14618   ; #endif
                    14619   ; OS_TCB    *ptcb;
                    14620   ; #ifdef OS_SAFETY_CRITICAL
                    14621   ; if (perr == (INT8U *)0) {
                    14622   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    14623   ; return;
                    14624   ; }
                    14625   ; #endif
                    14626   ; #if OS_ARG_CHK_EN > 0u
                    14627   ; if (prio >= OS_LOWEST_PRIO) {
                    14628   ; if (prio != OS_PRIO_SELF) {
                    14629   ; *perr = OS_ERR_PRIO_INVALID;
                    14630   ; return;
                    14631   ; }
                    14632   ; }
                    14633   ; if (id >= OS_TASK_REG_TBL_SIZE) {
                    14634   ; *perr = OS_ERR_ID_INVALID;
                    14635   ; return;
                    14636   ; }
                    14637   ; #endif
                    14638   ; OS_ENTER_CRITICAL();
00004B4C  40E7      14639          dc.w      16615
00004B4E  007C      14640          dc.w      124
00004B50  0700      14641          dc.w      1792
                    14642   ; if (prio == OS_PRIO_SELF) {                  /* See if need to get register from current task      */
00004B52  102E 000B 14643          move.b    11(A6),D0
00004B56  0C00 00FF 14644          cmp.b     #255,D0
00004B5A  6608      14645          bne.s     OSTaskRegSet_1
                    14646   ; ptcb = OSTCBCur;
00004B5C  2439 0080 14647          move.l    _OSTCBCur.L,D2
00004B60  0360      
00004B62  6016      14648          bra.s     OSTaskRegSet_2
                    14649   OSTaskRegSet_1:
                    14650   ; } else {
                    14651   ; ptcb = OSTCBPrioTbl[prio];
00004B64  102E 000B 14652          move.b    11(A6),D0
00004B68  C0BC 0000 14653          and.l     #255,D0
00004B6C  00FF      
00004B6E  E588      14654          lsl.l     #2,D0
00004B70  41F9 0080 14655          lea       _OSTCBPrioTbl.L,A0
00004B74  0370      
00004B76  2430 0800 14656          move.l    0(A0,D0.L),D2
                    14657   OSTaskRegSet_2:
                    14658   ; }
                    14659   ; ptcb->OSTCBRegTbl[id] = value;
00004B7A  2042      14660          move.l    D2,A0
00004B7C  102E 000F 14661          move.b    15(A6),D0
00004B80  C0BC 0000 14662          and.l     #255,D0
00004B84  00FF      
00004B86  E588      14663          lsl.l     #2,D0
00004B88  D1C0      14664          add.l     D0,A0
00004B8A  216E 0010 14665          move.l    16(A6),82(A0)
00004B8E  0052      
                    14666   ; OS_EXIT_CRITICAL();
00004B90  46DF      14667          dc.w      18143
                    14668   ; *perr                 = OS_ERR_NONE;
00004B92  206E 0014 14669          move.l    20(A6),A0
00004B96  4210      14670          clr.b     (A0)
00004B98  241F      14671          move.l    (A7)+,D2
00004B9A  4E5E      14672          unlk      A6
00004B9C  4E75      14673          rts
                    14674   ; }
                    14675   ; #endif
                    14676   ; /*$PAGE*/
                    14677   ; /*
                    14678   ; *********************************************************************************************************
                    14679   ; *                                    CATCH ACCIDENTAL TASK RETURN
                    14680   ; *
                    14681   ; * Description: This function is called if a task accidentally returns without deleting itself.  In other
                    14682   ; *              words, a task should either be an infinite loop or delete itself if it's done.
                    14683   ; *
                    14684   ; * Arguments  : none
                    14685   ; *
                    14686   ; * Returns    : none
                    14687   ; *
                    14688   ; * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
                    14689   ; *********************************************************************************************************
                    14690   ; */
                    14691   ; void  OS_TaskReturn (void)
                    14692   ; {
                    14693   _OS_TaskReturn:
                    14694   ; OSTaskReturnHook(OSTCBCur);                   /* Call hook to let user decide on what to do        */
00004B9E  2F39 0080 14695          move.l    _OSTCBCur.L,-(A7)
00004BA2  0360      
00004BA4  4EB8 06F0 14696          jsr       _OSTaskReturnHook
00004BA8  584F      14697          addq.w    #4,A7
                    14698   ; #if OS_TASK_DEL_EN > 0u
                    14699   ; (void)OSTaskDel(OS_PRIO_SELF);                /* Delete task if it accidentally returns!           */
00004BAA  4878 00FF 14700          pea       255
00004BAE  4EB8 4470 14701          jsr       _OSTaskDel
00004BB2  584F      14702          addq.w    #4,A7
00004BB4  C0BC 0000 14703          and.l     #255,D0
00004BB8  00FF      
00004BBA  4E75      14704          rts
                    14705   ; #else
                    14706   ; for (;;) {
                    14707   ; OSTimeDly(OS_TICKS_PER_SEC);
                    14708   ; }
                    14709   ; #endif
                    14710   ; }
                    14711   ; /*$PAGE*/
                    14712   ; /*
                    14713   ; *********************************************************************************************************
                    14714   ; *                                          CLEAR TASK STACK
                    14715   ; *
                    14716   ; * Description: This function is used to clear the stack of a task (i.e. write all zeros)
                    14717   ; *
                    14718   ; * Arguments  : pbos     is a pointer to the task's bottom of stack.  If the configuration constant
                    14719   ; *                       OS_STK_GROWTH is set to 1, the stack is assumed to grow downward (i.e. from high
                    14720   ; *                       memory to low memory).  'pbos' will thus point to the lowest (valid) memory
                    14721   ; *                       location of the stack.  If OS_STK_GROWTH is set to 0, 'pbos' will point to the
                    14722   ; *                       highest memory location of the stack and the stack will grow with increasing
                    14723   ; *                       memory locations.  'pbos' MUST point to a valid 'free' data item.
                    14724   ; *
                    14725   ; *              size     is the number of 'stack elements' to clear.
                    14726   ; *
                    14727   ; *              opt      contains additional information (or options) about the behavior of the task.  The
                    14728   ; *                       LOWER 8-bits are reserved by uC/OS-II while the upper 8 bits can be application
                    14729   ; *                       specific.  See OS_TASK_OPT_??? in uCOS-II.H.
                    14730   ; *
                    14731   ; * Returns    : none
                    14732   ; *********************************************************************************************************
                    14733   ; */
                    14734   ; #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
                    14735   ; void  OS_TaskStkClr (OS_STK  *pbos,
                    14736   ; INT32U   size,
                    14737   ; INT16U   opt)
                    14738   ; {
                    14739   _OS_TaskStkClr:
00004BBC  4E56 0000 14740          link      A6,#0
                    14741   ; if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000u) {      /* See if stack checking has been enabled       */
00004BC0  302E 0012 14742          move.w    18(A6),D0
00004BC4  C07C 0001 14743          and.w     #1,D0
00004BC8  6726      14744          beq.s     OS_TaskStkClr_7
                    14745   ; if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000u) {  /* See if stack needs to be cleared             */
00004BCA  302E 0012 14746          move.w    18(A6),D0
00004BCE  C07C 0002 14747          and.w     #2,D0
00004BD2  671C      14748          beq.s     OS_TaskStkClr_7
                    14749   ; #if OS_STK_GROWTH == 1u
                    14750   ; while (size > 0u) {                        /* Stack grows from HIGH to LOW memory          */
                    14751   OS_TaskStkClr_5:
00004BD4  202E 000C 14752          move.l    12(A6),D0
00004BD8  0C80 0000 14753          cmp.l     #0,D0
00004BDC  0000      
00004BDE  6310      14754          bls.s     OS_TaskStkClr_7
                    14755   ; size--;
00004BE0  53AE 000C 14756          subq.l    #1,12(A6)
                    14757   ; *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
00004BE4  206E 0008 14758          move.l    8(A6),A0
00004BE8  54AE 0008 14759          addq.l    #2,8(A6)
00004BEC  4250      14760          clr.w     (A0)
00004BEE  60E4      14761          bra       OS_TaskStkClr_5
                    14762   OS_TaskStkClr_7:
00004BF0  4E5E      14763          unlk      A6
00004BF2  4E75      14764          rts
                    14765   ; /*
                    14766   ; *********************************************************************************************************
                    14767   ; *                                                uC/OS-II
                    14768   ; *                                          The Real-Time Kernel
                    14769   ; *                                             TIME MANAGEMENT
                    14770   ; *
                    14771   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    14772   ; *                                           All Rights Reserved
                    14773   ; *
                    14774   ; * File    : OS_TIME.C
                    14775   ; * By      : Jean J. Labrosse
                    14776   ; * Version : V2.92.07
                    14777   ; *
                    14778   ; * LICENSING TERMS:
                    14779   ; * ---------------
                    14780   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    14781   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    14782   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    14783   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    14784   ; * licensing fee.
                    14785   ; *********************************************************************************************************
                    14786   ; */
                    14787   ; #define  MICRIUM_SOURCE
                    14788   ; #ifndef  OS_MASTER_FILE
                    14789   ; #include <ucos_ii.h>
                    14790   ; #endif
                    14791   ; /*
                    14792   ; *********************************************************************************************************
                    14793   ; *                                        DELAY TASK 'n' TICKS
                    14794   ; *
                    14795   ; * Description: This function is called to delay execution of the currently running task until the
                    14796   ; *              specified number of system ticks expires.  This, of course, directly equates to delaying
                    14797   ; *              the current task for some time to expire.  No delay will result If the specified delay is
                    14798   ; *              0.  If the specified delay is greater than 0 then, a context switch will result.
                    14799   ; *
                    14800   ; * Arguments  : ticks     is the time delay that the task will be suspended in number of clock 'ticks'.
                    14801   ; *                        Note that by specifying 0, the task will not be delayed.
                    14802   ; *
                    14803   ; * Returns    : none
                    14804   ; *********************************************************************************************************
                    14805   ; */
                    14806   ; void  OSTimeDly (INT32U ticks)
                    14807   ; {
                    14808   _OSTimeDly:
00004BF4  4E56 0000 14809          link      A6,#0
00004BF8  48E7 2020 14810          movem.l   D2/A2,-(A7)
00004BFC  45F9 0080 14811          lea       _OSTCBCur.L,A2
00004C00  0360      
                    14812   ; INT8U      y;
                    14813   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    14814   ; OS_CPU_SR  cpu_sr = 0u;
                    14815   ; #endif
                    14816   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00004C02  1039 0080 14817          move.b    _OSIntNesting.L,D0
00004C06  0246      
00004C08  0C00 0000 14818          cmp.b     #0,D0
00004C0C  6304      14819          bls.s     OSTimeDly_1
                    14820   ; return;
00004C0E  6000 0072 14821          bra       OSTimeDly_6
                    14822   OSTimeDly_1:
                    14823   ; }
                    14824   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
00004C12  1039 0080 14825          move.b    _OSLockNesting.L,D0
00004C16  0248      
00004C18  0C00 0000 14826          cmp.b     #0,D0
00004C1C  6304      14827          bls.s     OSTimeDly_4
                    14828   ; return;
00004C1E  6000 0062 14829          bra       OSTimeDly_6
                    14830   OSTimeDly_4:
                    14831   ; }
                    14832   ; if (ticks > 0u) {                            /* 0 means no delay!                                  */
00004C22  202E 0008 14833          move.l    8(A6),D0
00004C26  0C80 0000 14834          cmp.l     #0,D0
00004C2A  0000      
00004C2C  6300 0054 14835          bls       OSTimeDly_6
                    14836   ; OS_ENTER_CRITICAL();
00004C30  40E7      14837          dc.w      16615
00004C32  007C      14838          dc.w      124
00004C34  0700      14839          dc.w      1792
                    14840   ; y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
00004C36  2052      14841          move.l    (A2),A0
00004C38  1428 0036 14842          move.b    54(A0),D2
                    14843   ; OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00004C3C  C4BC 0000 14844          and.l     #255,D2
00004C40  00FF      
00004C42  41F9 0080 14845          lea       _OSRdyTbl.L,A0
00004C46  0250      
00004C48  2252      14846          move.l    (A2),A1
00004C4A  1029 0037 14847          move.b    55(A1),D0
00004C4E  4600      14848          not.b     D0
00004C50  C130 2800 14849          and.b     D0,0(A0,D2.L)
                    14850   ; if (OSRdyTbl[y] == 0u) {
00004C54  C4BC 0000 14851          and.l     #255,D2
00004C58  00FF      
00004C5A  41F9 0080 14852          lea       _OSRdyTbl.L,A0
00004C5E  0250      
00004C60  1030 2800 14853          move.b    0(A0,D2.L),D0
00004C64  660E      14854          bne.s     OSTimeDly_8
                    14855   ; OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
00004C66  2052      14856          move.l    (A2),A0
00004C68  1028 0038 14857          move.b    56(A0),D0
00004C6C  4600      14858          not.b     D0
00004C6E  C139 0080 14859          and.b     D0,_OSRdyGrp.L
00004C72  024E      
                    14860   OSTimeDly_8:
                    14861   ; }
                    14862   ; OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
00004C74  2052      14863          move.l    (A2),A0
00004C76  216E 0008 14864          move.l    8(A6),46(A0)
00004C7A  002E      
                    14865   ; OS_EXIT_CRITICAL();
00004C7C  46DF      14866          dc.w      18143
                    14867   ; OS_Sched();                              /* Find next task to run!                             */
00004C7E  4EB8 13F8 14868          jsr       _OS_Sched
                    14869   OSTimeDly_6:
00004C82  4CDF 0404 14870          movem.l   (A7)+,D2/A2
00004C86  4E5E      14871          unlk      A6
00004C88  4E75      14872          rts
                    14873   ; }
                    14874   ; }
                    14875   ; /*$PAGE*/
                    14876   ; /*
                    14877   ; *********************************************************************************************************
                    14878   ; *                                    DELAY TASK FOR SPECIFIED TIME
                    14879   ; *
                    14880   ; * Description: This function is called to delay execution of the currently running task until some time
                    14881   ; *              expires.  This call allows you to specify the delay time in HOURS, MINUTES, SECONDS and
                    14882   ; *              MILLISECONDS instead of ticks.
                    14883   ; *
                    14884   ; * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 255)
                    14885   ; *              minutes   specifies the number of minutes (max. 59)
                    14886   ; *              seconds   specifies the number of seconds (max. 59)
                    14887   ; *              ms        specifies the number of milliseconds (max. 999)
                    14888   ; *
                    14889   ; * Returns    : OS_ERR_NONE
                    14890   ; *              OS_ERR_TIME_INVALID_MINUTES
                    14891   ; *              OS_ERR_TIME_INVALID_SECONDS
                    14892   ; *              OS_ERR_TIME_INVALID_MS
                    14893   ; *              OS_ERR_TIME_ZERO_DLY
                    14894   ; *              OS_ERR_TIME_DLY_ISR
                    14895   ; *
                    14896   ; * Note(s)    : The resolution on the milliseconds depends on the tick rate.  For example, you can't do
                    14897   ; *              a 10 mS delay if the ticker interrupts every 100 mS.  In this case, the delay would be
                    14898   ; *              set to 0.  The actual delay is rounded to the nearest tick.
                    14899   ; *********************************************************************************************************
                    14900   ; */
                    14901   ; #if OS_TIME_DLY_HMSM_EN > 0u
                    14902   ; INT8U  OSTimeDlyHMSM (INT8U   hours,
                    14903   ; INT8U   minutes,
                    14904   ; INT8U   seconds,
                    14905   ; INT16U  ms)
                    14906   ; {
                    14907   _OSTimeDlyHMSM:
00004C8A  4E56 FFFC 14908          link      A6,#-4
                    14909   ; INT32U ticks;
                    14910   ; if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00004C8E  1039 0080 14911          move.b    _OSIntNesting.L,D0
00004C92  0246      
00004C94  0C00 0000 14912          cmp.b     #0,D0
00004C98  6306      14913          bls.s     OSTimeDlyHMSM_1
                    14914   ; return (OS_ERR_TIME_DLY_ISR);
00004C9A  7055      14915          moveq     #85,D0
00004C9C  6000 00A4 14916          bra       OSTimeDlyHMSM_3
                    14917   OSTimeDlyHMSM_1:
                    14918   ; }
                    14919   ; if (OSLockNesting > 0u) {                    /* See if called with scheduler locked                */
00004CA0  1039 0080 14920          move.b    _OSLockNesting.L,D0
00004CA4  0248      
00004CA6  0C00 0000 14921          cmp.b     #0,D0
00004CAA  6306      14922          bls.s     OSTimeDlyHMSM_4
                    14923   ; return (OS_ERR_SCHED_LOCKED);
00004CAC  7032      14924          moveq     #50,D0
00004CAE  6000 0092 14925          bra       OSTimeDlyHMSM_3
                    14926   OSTimeDlyHMSM_4:
                    14927   ; }
                    14928   ; #if OS_ARG_CHK_EN > 0u
                    14929   ; if (hours == 0u) {
                    14930   ; if (minutes == 0u) {
                    14931   ; if (seconds == 0u) {
                    14932   ; if (ms == 0u) {
                    14933   ; return (OS_ERR_TIME_ZERO_DLY);
                    14934   ; }
                    14935   ; }
                    14936   ; }
                    14937   ; }
                    14938   ; if (minutes > 59u) {
                    14939   ; return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
                    14940   ; }
                    14941   ; if (seconds > 59u) {
                    14942   ; return (OS_ERR_TIME_INVALID_SECONDS);
                    14943   ; }
                    14944   ; if (ms > 999u) {
                    14945   ; return (OS_ERR_TIME_INVALID_MS);
                    14946   ; }
                    14947   ; #endif
                    14948   ; /* Compute the total number of clock ticks required.. */
                    14949   ; /* .. (rounded to the nearest tick)                   */
                    14950   ; ticks = ((INT32U)hours * 3600uL + (INT32U)minutes * 60uL + (INT32U)seconds) * OS_TICKS_PER_SEC
00004CB2  102E 000B 14951          move.b    11(A6),D0
00004CB6  C0BC 0000 14952          and.l     #255,D0
00004CBA  00FF      
00004CBC  2F00      14953          move.l    D0,-(A7)
00004CBE  4878 0E10 14954          pea       3600
00004CC2  4EB9 0000 14955          jsr       ULMUL
00004CC6  5910      
00004CC8  2017      14956          move.l    (A7),D0
00004CCA  504F      14957          addq.w    #8,A7
00004CCC  122E 000F 14958          move.b    15(A6),D1
00004CD0  C2BC 0000 14959          and.l     #255,D1
00004CD4  00FF      
00004CD6  2F01      14960          move.l    D1,-(A7)
00004CD8  4878 003C 14961          pea       60
00004CDC  4EB9 0000 14962          jsr       ULMUL
00004CE0  5910      
00004CE2  2217      14963          move.l    (A7),D1
00004CE4  504F      14964          addq.w    #8,A7
00004CE6  D081      14965          add.l     D1,D0
00004CE8  122E 0013 14966          move.b    19(A6),D1
00004CEC  C2BC 0000 14967          and.l     #255,D1
00004CF0  00FF      
00004CF2  D081      14968          add.l     D1,D0
00004CF4  2F00      14969          move.l    D0,-(A7)
00004CF6  4878 0064 14970          pea       100
00004CFA  4EB9 0000 14971          jsr       ULMUL
00004CFE  5910      
00004D00  2017      14972          move.l    (A7),D0
00004D02  504F      14973          addq.w    #8,A7
00004D04  322E 0016 14974          move.w    22(A6),D1
00004D08  C2BC 0000 14975          and.l     #65535,D1
00004D0C  FFFF      
00004D0E  5A81      14976          addq.l    #5,D1
00004D10  2F01      14977          move.l    D1,-(A7)
00004D12  4878 0064 14978          pea       100
00004D16  4EB9 0000 14979          jsr       ULMUL
00004D1A  5910      
00004D1C  2217      14980          move.l    (A7),D1
00004D1E  504F      14981          addq.w    #8,A7
00004D20  2F01      14982          move.l    D1,-(A7)
00004D22  4878 03E8 14983          pea       1000
00004D26  4EB9 0000 14984          jsr       ULDIV
00004D2A  59B0      
00004D2C  2217      14985          move.l    (A7),D1
00004D2E  504F      14986          addq.w    #8,A7
00004D30  D081      14987          add.l     D1,D0
00004D32  2D40 FFFC 14988          move.l    D0,-4(A6)
                    14989   ; + OS_TICKS_PER_SEC * ((INT32U)ms + 500uL / OS_TICKS_PER_SEC) / 1000uL;
                    14990   ; OSTimeDly(ticks);
00004D36  2F2E FFFC 14991          move.l    -4(A6),-(A7)
00004D3A  4EB8 4BF4 14992          jsr       _OSTimeDly
00004D3E  584F      14993          addq.w    #4,A7
                    14994   ; return (OS_ERR_NONE);
00004D40  4200      14995          clr.b     D0
                    14996   OSTimeDlyHMSM_3:
00004D42  4E5E      14997          unlk      A6
00004D44  4E75      14998          rts
                    14999   ; }
                    15000   ; #endif
                    15001   ; /*$PAGE*/
                    15002   ; /*
                    15003   ; *********************************************************************************************************
                    15004   ; *                                        RESUME A DELAYED TASK
                    15005   ; *
                    15006   ; * Description: This function is used resume a task that has been delayed through a call to either
                    15007   ; *              OSTimeDly() or OSTimeDlyHMSM().  Note that you can call this function to resume a
                    15008   ; *              task that is waiting for an event with timeout.  This would make the task look
                    15009   ; *              like a timeout occurred.
                    15010   ; *
                    15011   ; * Arguments  : prio                      specifies the priority of the task to resume
                    15012   ; *
                    15013   ; * Returns    : OS_ERR_NONE               Task has been resumed
                    15014   ; *              OS_ERR_PRIO_INVALID       if the priority you specify is higher that the maximum allowed
                    15015   ; *                                        (i.e. >= OS_LOWEST_PRIO)
                    15016   ; *              OS_ERR_TIME_NOT_DLY       Task is not waiting for time to expire
                    15017   ; *              OS_ERR_TASK_NOT_EXIST     The desired task has not been created or has been assigned to a Mutex.
                    15018   ; *********************************************************************************************************
                    15019   ; */
                    15020   ; #if OS_TIME_DLY_RESUME_EN > 0u
                    15021   ; INT8U  OSTimeDlyResume (INT8U prio)
                    15022   ; {
                    15023   _OSTimeDlyResume:
00004D46  4E56 0000 15024          link      A6,#0
00004D4A  2F02      15025          move.l    D2,-(A7)
                    15026   ; OS_TCB    *ptcb;
                    15027   ; #if OS_CRITICAL_METHOD == 3u                                   /* Storage for CPU status register      */
                    15028   ; OS_CPU_SR  cpu_sr = 0u;
                    15029   ; #endif
                    15030   ; if (prio >= OS_LOWEST_PRIO) {
00004D4C  102E 000B 15031          move.b    11(A6),D0
00004D50  0C00 003F 15032          cmp.b     #63,D0
00004D54  6506      15033          blo.s     OSTimeDlyResume_1
                    15034   ; return (OS_ERR_PRIO_INVALID);
00004D56  702A      15035          moveq     #42,D0
00004D58  6000 00B4 15036          bra       OSTimeDlyResume_3
                    15037   OSTimeDlyResume_1:
                    15038   ; }
                    15039   ; OS_ENTER_CRITICAL();
00004D5C  40E7      15040          dc.w      16615
00004D5E  007C      15041          dc.w      124
00004D60  0700      15042          dc.w      1792
                    15043   ; ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
00004D62  102E 000B 15044          move.b    11(A6),D0
00004D66  C0BC 0000 15045          and.l     #255,D0
00004D6A  00FF      
00004D6C  E588      15046          lsl.l     #2,D0
00004D6E  41F9 0080 15047          lea       _OSTCBPrioTbl.L,A0
00004D72  0370      
00004D74  2430 0800 15048          move.l    0(A0,D0.L),D2
                    15049   ; if (ptcb == (OS_TCB *)0) {
00004D78  4A82      15050          tst.l     D2
00004D7A  6608      15051          bne.s     OSTimeDlyResume_4
                    15052   ; OS_EXIT_CRITICAL();
00004D7C  46DF      15053          dc.w      18143
                    15054   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
00004D7E  7043      15055          moveq     #67,D0
00004D80  6000 008C 15056          bra       OSTimeDlyResume_3
                    15057   OSTimeDlyResume_4:
                    15058   ; }
                    15059   ; if (ptcb == OS_TCB_RESERVED) {
00004D84  0C82 0000 15060          cmp.l     #1,D2
00004D88  0001      
00004D8A  6608      15061          bne.s     OSTimeDlyResume_6
                    15062   ; OS_EXIT_CRITICAL();
00004D8C  46DF      15063          dc.w      18143
                    15064   ; return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
00004D8E  7043      15065          moveq     #67,D0
00004D90  6000 007C 15066          bra       OSTimeDlyResume_3
                    15067   OSTimeDlyResume_6:
                    15068   ; }
                    15069   ; if (ptcb->OSTCBDly == 0u) {                                /* See if task is delayed               */
00004D94  2042      15070          move.l    D2,A0
00004D96  2028 002E 15071          move.l    46(A0),D0
00004D9A  6608      15072          bne.s     OSTimeDlyResume_8
                    15073   ; OS_EXIT_CRITICAL();
00004D9C  46DF      15074          dc.w      18143
                    15075   ; return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
00004D9E  7050      15076          moveq     #80,D0
00004DA0  6000 006C 15077          bra       OSTimeDlyResume_3
                    15078   OSTimeDlyResume_8:
                    15079   ; }
                    15080   ; ptcb->OSTCBDly = 0u;                                       /* Clear the time delay                 */
00004DA4  2042      15081          move.l    D2,A0
00004DA6  42A8 002E 15082          clr.l     46(A0)
                    15083   ; if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
00004DAA  2042      15084          move.l    D2,A0
00004DAC  1028 0032 15085          move.b    50(A0),D0
00004DB0  C03C 0037 15086          and.b     #55,D0
00004DB4  6712      15087          beq.s     OSTimeDlyResume_10
                    15088   ; ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
00004DB6  2042      15089          move.l    D2,A0
00004DB8  0228 00C8 15090          and.b     #-56,50(A0)
00004DBC  0032      
                    15091   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
00004DBE  2042      15092          move.l    D2,A0
00004DC0  117C 0001 15093          move.b    #1,51(A0)
00004DC4  0033      
00004DC6  6006      15094          bra.s     OSTimeDlyResume_11
                    15095   OSTimeDlyResume_10:
                    15096   ; } else {
                    15097   ; ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
00004DC8  2042      15098          move.l    D2,A0
00004DCA  4228 0033 15099          clr.b     51(A0)
                    15100   OSTimeDlyResume_11:
                    15101   ; }
                    15102   ; if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
00004DCE  2042      15103          move.l    D2,A0
00004DD0  1028 0032 15104          move.b    50(A0),D0
00004DD4  C03C 0008 15105          and.b     #8,D0
00004DD8  6630      15106          bne.s     OSTimeDlyResume_12
                    15107   ; OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
00004DDA  2042      15108          move.l    D2,A0
00004DDC  1028 0038 15109          move.b    56(A0),D0
00004DE0  8139 0080 15110          or.b      D0,_OSRdyGrp.L
00004DE4  024E      
                    15111   ; OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00004DE6  2042      15112          move.l    D2,A0
00004DE8  1028 0036 15113          move.b    54(A0),D0
00004DEC  C0BC 0000 15114          and.l     #255,D0
00004DF0  00FF      
00004DF2  41F9 0080 15115          lea       _OSRdyTbl.L,A0
00004DF6  0250      
00004DF8  2242      15116          move.l    D2,A1
00004DFA  1229 0037 15117          move.b    55(A1),D1
00004DFE  8330 0800 15118          or.b      D1,0(A0,D0.L)
                    15119   ; OS_EXIT_CRITICAL();
00004E02  46DF      15120          dc.w      18143
                    15121   ; OS_Sched();                                            /* See if this is new highest priority  */
00004E04  4EB8 13F8 15122          jsr       _OS_Sched
00004E08  6002      15123          bra.s     OSTimeDlyResume_13
                    15124   OSTimeDlyResume_12:
                    15125   ; } else {
                    15126   ; OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
00004E0A  46DF      15127          dc.w      18143
                    15128   OSTimeDlyResume_13:
                    15129   ; }
                    15130   ; return (OS_ERR_NONE);
00004E0C  4200      15131          clr.b     D0
                    15132   OSTimeDlyResume_3:
00004E0E  241F      15133          move.l    (A7)+,D2
00004E10  4E5E      15134          unlk      A6
00004E12  4E75      15135          rts
                    15136   ; }
                    15137   ; #endif
                    15138   ; /*$PAGE*/
                    15139   ; /*
                    15140   ; *********************************************************************************************************
                    15141   ; *                                       GET CURRENT SYSTEM TIME
                    15142   ; *
                    15143   ; * Description: This function is used by your application to obtain the current value of the 32-bit
                    15144   ; *              counter which keeps track of the number of clock ticks.
                    15145   ; *
                    15146   ; * Arguments  : none
                    15147   ; *
                    15148   ; * Returns    : The current value of OSTime
                    15149   ; *********************************************************************************************************
                    15150   ; */
                    15151   ; #if OS_TIME_GET_SET_EN > 0u
                    15152   ; INT32U  OSTimeGet (void)
                    15153   ; {
                    15154   _OSTimeGet:
00004E14  4E56 FFFC 15155          link      A6,#-4
                    15156   ; INT32U     ticks;
                    15157   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15158   ; OS_CPU_SR  cpu_sr = 0u;
                    15159   ; #endif
                    15160   ; OS_ENTER_CRITICAL();
00004E18  40E7      15161          dc.w      16615
00004E1A  007C      15162          dc.w      124
00004E1C  0700      15163          dc.w      1792
                    15164   ; ticks = OSTime;
00004E1E  2D79 0080 15165          move.l    _OSTime.L,-4(A6)
00004E22  0CB6 FFFC 
                    15166   ; OS_EXIT_CRITICAL();
00004E26  46DF      15167          dc.w      18143
                    15168   ; return (ticks);
00004E28  202E FFFC 15169          move.l    -4(A6),D0
00004E2C  4E5E      15170          unlk      A6
00004E2E  4E75      15171          rts
                    15172   ; }
                    15173   ; #endif
                    15174   ; /*
                    15175   ; *********************************************************************************************************
                    15176   ; *                                          SET SYSTEM CLOCK
                    15177   ; *
                    15178   ; * Description: This function sets the 32-bit counter which keeps track of the number of clock ticks.
                    15179   ; *
                    15180   ; * Arguments  : ticks      specifies the new value that OSTime needs to take.
                    15181   ; *
                    15182   ; * Returns    : none
                    15183   ; *********************************************************************************************************
                    15184   ; */
                    15185   ; #if OS_TIME_GET_SET_EN > 0u
                    15186   ; void  OSTimeSet (INT32U ticks)
                    15187   ; {
                    15188   _OSTimeSet:
00004E30  4E56 0000 15189          link      A6,#0
                    15190   ; #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
                    15191   ; OS_CPU_SR  cpu_sr = 0u;
                    15192   ; #endif
                    15193   ; OS_ENTER_CRITICAL();
00004E34  40E7      15194          dc.w      16615
00004E36  007C      15195          dc.w      124
00004E38  0700      15196          dc.w      1792
                    15197   ; OSTime = ticks;
00004E3A  23EE 0008 15198          move.l    8(A6),_OSTime.L
00004E3E  0080 0CB6 
                    15199   ; OS_EXIT_CRITICAL();
00004E42  46DF      15200          dc.w      18143
00004E44  4E5E      15201          unlk      A6
00004E46  4E75      15202          rts
                    15203   ; /*
                    15204   ; *********************************************************************************************************
                    15205   ; *                                                uC/OS-II
                    15206   ; *                                          The Real-Time Kernel
                    15207   ; *                                            TIMER MANAGEMENT
                    15208   ; *
                    15209   ; *                              (c) Copyright 1992-2012, Micrium, Weston, FL
                    15210   ; *                                           All Rights Reserved
                    15211   ; *
                    15212   ; *
                    15213   ; * File    : OS_TMR.C
                    15214   ; * By      : Jean J. Labrosse
                    15215   ; * Version : V2.92.07
                    15216   ; *
                    15217   ; * LICENSING TERMS:
                    15218   ; * ---------------
                    15219   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
                    15220   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrium to properly license
                    15221   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience
                    15222   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
                    15223   ; * licensing fee.
                    15224   ; *********************************************************************************************************
                    15225   ; */
                    15226   ; #define  MICRIUM_SOURCE
                    15227   ; #ifndef  OS_MASTER_FILE
                    15228   ; #include <ucos_ii.h>
                    15229   ; #endif
                    15230   ; /*
                    15231   ; *********************************************************************************************************
                    15232   ; *                                                        NOTES
                    15233   ; *
                    15234   ; * 1) Your application MUST define the following #define constants:
                    15235   ; *
                    15236   ; *    OS_TASK_TMR_PRIO          The priority of the Timer management task
                    15237   ; *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
                    15238   ; *
                    15239   ; * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
                    15240   ; *********************************************************************************************************
                    15241   ; */
                    15242   ; /*
                    15243   ; *********************************************************************************************************
                    15244   ; *                                              CONSTANTS
                    15245   ; *********************************************************************************************************
                    15246   ; */
                    15247   ; #define  OS_TMR_LINK_DLY       0u
                    15248   ; #define  OS_TMR_LINK_PERIODIC  1u
                    15249   ; /*
                    15250   ; *********************************************************************************************************
                    15251   ; *                                          LOCAL PROTOTYPES
                    15252   ; *********************************************************************************************************
                    15253   ; */
                    15254   ; #if OS_TMR_EN > 0u
                    15255   ; static  OS_TMR  *OSTmr_Alloc         (void);
                    15256   ; static  void     OSTmr_Free          (OS_TMR *ptmr);
                    15257   ; static  void     OSTmr_InitTask      (void);
                    15258   ; static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
                    15259   ; static  void     OSTmr_Unlink        (OS_TMR *ptmr);
                    15260   ; static  void     OSTmr_Task          (void   *p_arg);
                    15261   ; #endif
                    15262   ; /*$PAGE*/
                    15263   ; /*
                    15264   ; *********************************************************************************************************
                    15265   ; *                                           CREATE A TIMER
                    15266   ; *
                    15267   ; * Description: This function is called by your application code to create a timer.
                    15268   ; *
                    15269   ; * Arguments  : dly           Initial delay.
                    15270   ; *                            If the timer is configured for ONE-SHOT mode, this is the timeout used.
                    15271   ; *                            If the timer is configured for PERIODIC mode, this is the first timeout to 
                    15272   ; *                               wait for before the timer starts entering periodic mode.
                    15273   ; *
                    15274   ; *              period        The 'period' being repeated for the timer.
                    15275   ; *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer 
                    15276   ; *                               expires, it will automatically restart with the same period.
                    15277   ; *
                    15278   ; *              opt           Specifies either:
                    15279   ; *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
                    15280   ; *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
                    15281   ; *
                    15282   ; *              callback      Is a pointer to a callback function that will be called when the timer expires. 
                    15283   ; *                               The callback function must be declared as follows:
                    15284   ; *
                    15285   ; *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
                    15286   ; *
                    15287   ; *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
                    15288   ; *
                    15289   ; *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are 
                    15290   ; *                               useful for debugging.
                    15291   ; *
                    15292   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15293   ; *                               OS_ERR_NONE
                    15294   ; *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
                    15295   ; *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
                    15296   ; *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
                    15297   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    15298   ; *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
                    15299   ; *
                    15300   ; * Returns    : A pointer to an OS_TMR data structure.
                    15301   ; *              This is the 'handle' that your application will use to reference the timer created.
                    15302   ; *********************************************************************************************************
                    15303   ; */
                    15304   ; #if OS_TMR_EN > 0u
                    15305   ; OS_TMR  *OSTmrCreate (INT32U           dly,
                    15306   ; INT32U           period,
                    15307   ; INT8U            opt,
                    15308   ; OS_TMR_CALLBACK  callback,
                    15309   ; void            *callback_arg,
                    15310   ; INT8U           *pname,
                    15311   ; INT8U           *perr)
                    15312   ; {
                    15313   _OSTmrCreate:
00004E48  4E56 0000 15314          link      A6,#0
00004E4C  48E7 3000 15315          movem.l   D2/D3,-(A7)
00004E50  262E 0020 15316          move.l    32(A6),D3
                    15317   ; OS_TMR   *ptmr;
                    15318   ; #ifdef OS_SAFETY_CRITICAL
                    15319   ; if (perr == (INT8U *)0) {
                    15320   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15321   ; return ((OS_TMR *)0);
                    15322   ; }
                    15323   ; #endif
                    15324   ; #ifdef OS_SAFETY_CRITICAL_IEC61508
                    15325   ; if (OSSafetyCriticalStartFlag == OS_TRUE) {
                    15326   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15327   ; return ((OS_TMR *)0);
                    15328   ; }
                    15329   ; #endif
                    15330   ; #if OS_ARG_CHK_EN > 0u
                    15331   ; switch (opt) {                                          /* Validate arguments                                     */
                    15332   ; case OS_TMR_OPT_PERIODIC:
                    15333   ; if (period == 0u) {
                    15334   ; *perr = OS_ERR_TMR_INVALID_PERIOD;
                    15335   ; return ((OS_TMR *)0);
                    15336   ; }
                    15337   ; break;
                    15338   ; case OS_TMR_OPT_ONE_SHOT:
                    15339   ; if (dly == 0u) {
                    15340   ; *perr = OS_ERR_TMR_INVALID_DLY;
                    15341   ; return ((OS_TMR *)0);
                    15342   ; }
                    15343   ; break;
                    15344   ; default:
                    15345   ; *perr = OS_ERR_TMR_INVALID_OPT;
                    15346   ; return ((OS_TMR *)0);
                    15347   ; }
                    15348   ; #endif
                    15349   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
00004E54  1039 0080 15350          move.b    _OSIntNesting.L,D0
00004E58  0246      
00004E5A  0C00 0000 15351          cmp.b     #0,D0
00004E5E  630C      15352          bls.s     OSTmrCreate_1
                    15353   ; *perr  = OS_ERR_TMR_ISR;
00004E60  2043      15354          move.l    D3,A0
00004E62  10BC 008B 15355          move.b    #139,(A0)
                    15356   ; return ((OS_TMR *)0);
00004E66  4280      15357          clr.l     D0
00004E68  6000 0078 15358          bra       OSTmrCreate_3
                    15359   OSTmrCreate_1:
                    15360   ; }
                    15361   ; OSSchedLock();
00004E6C  4EB8 0C48 15362          jsr       _OSSchedLock
                    15363   ; ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
00004E70  4EB9 0000 15364          jsr       @ucos_ii_OSTmr_Alloc
00004E74  53E0      
00004E76  2400      15365          move.l    D0,D2
                    15366   ; if (ptmr == (OS_TMR *)0) {
00004E78  4A82      15367          tst.l     D2
00004E7A  6610      15368          bne.s     OSTmrCreate_4
                    15369   ; OSSchedUnlock();
00004E7C  4EB8 0C78 15370          jsr       _OSSchedUnlock
                    15371   ; *perr = OS_ERR_TMR_NON_AVAIL;
00004E80  2043      15372          move.l    D3,A0
00004E82  10BC 0086 15373          move.b    #134,(A0)
                    15374   ; return ((OS_TMR *)0);
00004E86  4280      15375          clr.l     D0
00004E88  6000 0058 15376          bra       OSTmrCreate_3
                    15377   OSTmrCreate_4:
                    15378   ; }
                    15379   ; ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
00004E8C  2042      15380          move.l    D2,A0
00004E8E  117C 0001 15381          move.b    #1,35(A0)
00004E92  0023      
                    15382   ; ptmr->OSTmrDly         = dly;
00004E94  2042      15383          move.l    D2,A0
00004E96  216E 0008 15384          move.l    8(A6),22(A0)
00004E9A  0016      
                    15385   ; ptmr->OSTmrPeriod      = period;
00004E9C  2042      15386          move.l    D2,A0
00004E9E  216E 000C 15387          move.l    12(A6),26(A0)
00004EA2  001A      
                    15388   ; ptmr->OSTmrOpt         = opt;
00004EA4  2042      15389          move.l    D2,A0
00004EA6  116E 0013 15390          move.b    19(A6),34(A0)
00004EAA  0022      
                    15391   ; ptmr->OSTmrCallback    = callback;
00004EAC  2042      15392          move.l    D2,A0
00004EAE  216E 0014 15393          move.l    20(A6),2(A0)
00004EB2  0002      
                    15394   ; ptmr->OSTmrCallbackArg = callback_arg;
00004EB4  2042      15395          move.l    D2,A0
00004EB6  216E 0018 15396          move.l    24(A6),6(A0)
00004EBA  0006      
                    15397   ; #if OS_TMR_CFG_NAME_EN > 0u
                    15398   ; if (pname == (INT8U *)0) {                              /* Is 'pname' a NULL pointer?                             */
00004EBC  202E 001C 15399          move.l    28(A6),D0
00004EC0  660E      15400          bne.s     OSTmrCreate_6
                    15401   ; ptmr->OSTmrName    = (INT8U *)(void *)"?";
00004EC2  41F9 0000 15402          lea       @ucos_ii_1.L,A0
00004EC6  5A8E      
00004EC8  2242      15403          move.l    D2,A1
00004ECA  2348 001E 15404          move.l    A0,30(A1)
00004ECE  6008      15405          bra.s     OSTmrCreate_7
                    15406   OSTmrCreate_6:
                    15407   ; } else {
                    15408   ; ptmr->OSTmrName    = pname;
00004ED0  2042      15409          move.l    D2,A0
00004ED2  216E 001C 15410          move.l    28(A6),30(A0)
00004ED6  001E      
                    15411   OSTmrCreate_7:
                    15412   ; }
                    15413   ; #endif
                    15414   ; OSSchedUnlock();
00004ED8  4EB8 0C78 15415          jsr       _OSSchedUnlock
                    15416   ; *perr = OS_ERR_NONE;
00004EDC  2043      15417          move.l    D3,A0
00004EDE  4210      15418          clr.b     (A0)
                    15419   ; return (ptmr);
00004EE0  2002      15420          move.l    D2,D0
                    15421   OSTmrCreate_3:
00004EE2  4CDF 000C 15422          movem.l   (A7)+,D2/D3
00004EE6  4E5E      15423          unlk      A6
00004EE8  4E75      15424          rts
                    15425   ; }
                    15426   ; #endif
                    15427   ; /*$PAGE*/
                    15428   ; /*
                    15429   ; *********************************************************************************************************
                    15430   ; *                                           DELETE A TIMER
                    15431   ; *
                    15432   ; * Description: This function is called by your application code to delete a timer.
                    15433   ; *
                    15434   ; * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
                    15435   ; *
                    15436   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15437   ; *                               OS_ERR_NONE
                    15438   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15439   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15440   ; *                               OS_ERR_TMR_ISR            if the function was called from an ISR
                    15441   ; *                               OS_ERR_TMR_INACTIVE       if the timer was not created
                    15442   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15443   ; *
                    15444   ; * Returns    : OS_TRUE       If the call was successful
                    15445   ; *              OS_FALSE      If not
                    15446   ; *********************************************************************************************************
                    15447   ; */
                    15448   ; #if OS_TMR_EN > 0u
                    15449   ; BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                    15450   ; INT8U   *perr)
                    15451   ; {
                    15452   _OSTmrDel:
00004EEA  4E56 0000 15453          link      A6,#0
00004EEE  48E7 3020 15454          movem.l   D2/D3/A2,-(A7)
00004EF2  242E 000C 15455          move.l    12(A6),D2
00004EF6  262E 0008 15456          move.l    8(A6),D3
00004EFA  45F8 0C78 15457          lea       _OSSchedUnlock.L,A2
                    15458   ; #ifdef OS_SAFETY_CRITICAL
                    15459   ; if (perr == (INT8U *)0) {
                    15460   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15461   ; return (OS_FALSE);
                    15462   ; }
                    15463   ; #endif
                    15464   ; #if OS_ARG_CHK_EN > 0u
                    15465   ; if (ptmr == (OS_TMR *)0) {
                    15466   ; *perr = OS_ERR_TMR_INVALID;
                    15467   ; return (OS_FALSE);
                    15468   ; }
                    15469   ; #endif
                    15470   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
00004EFE  2043      15471          move.l    D3,A0
00004F00  1010      15472          move.b    (A0),D0
00004F02  0C00 0064 15473          cmp.b     #100,D0
00004F06  670C      15474          beq.s     OSTmrDel_1
                    15475   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00004F08  2042      15476          move.l    D2,A0
00004F0A  10BC 0089 15477          move.b    #137,(A0)
                    15478   ; return (OS_FALSE);
00004F0E  4200      15479          clr.b     D0
00004F10  6000 0090 15480          bra       OSTmrDel_3
                    15481   OSTmrDel_1:
                    15482   ; }
                    15483   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
00004F14  1039 0080 15484          move.b    _OSIntNesting.L,D0
00004F18  0246      
00004F1A  0C00 0000 15485          cmp.b     #0,D0
00004F1E  630C      15486          bls.s     OSTmrDel_4
                    15487   ; *perr  = OS_ERR_TMR_ISR;
00004F20  2042      15488          move.l    D2,A0
00004F22  10BC 008B 15489          move.b    #139,(A0)
                    15490   ; return (OS_FALSE);
00004F26  4200      15491          clr.b     D0
00004F28  6000 0078 15492          bra       OSTmrDel_3
                    15493   OSTmrDel_4:
                    15494   ; }
                    15495   ; OSSchedLock();
00004F2C  4EB8 0C48 15496          jsr       _OSSchedLock
                    15497   ; switch (ptmr->OSTmrState) {
00004F30  2043      15498          move.l    D3,A0
00004F32  1028 0023 15499          move.b    35(A0),D0
00004F36  C0BC 0000 15500          and.l     #255,D0
00004F3A  00FF      
00004F3C  0C80 0000 15501          cmp.l     #4,D0
00004F40  0004      
00004F42  6400 0054 15502          bhs       OSTmrDel_6
00004F46  E380      15503          asl.l     #1,D0
00004F48  303B 0806 15504          move.w    OSTmrDel_8(PC,D0.L),D0
00004F4C  4EFB 0002 15505          jmp       OSTmrDel_8(PC,D0.W)
                    15506   OSTmrDel_8:
00004F50  003C      15507          dc.w      OSTmrDel_12-OSTmrDel_8
00004F52  0028      15508          dc.w      OSTmrDel_10-OSTmrDel_8
00004F54  0028      15509          dc.w      OSTmrDel_10-OSTmrDel_8
00004F56  0008      15510          dc.w      OSTmrDel_9-OSTmrDel_8
                    15511   OSTmrDel_9:
                    15512   ; case OS_TMR_STATE_RUNNING:
                    15513   ; OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
00004F58  2F03      15514          move.l    D3,-(A7)
00004F5A  4EB9 0000 15515          jsr       @ucos_ii_OSTmr_Unlink
00004F5E  56D6      
00004F60  584F      15516          addq.w    #4,A7
                    15517   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
00004F62  2F03      15518          move.l    D3,-(A7)
00004F64  4EB9 0000 15519          jsr       @ucos_ii_OSTmr_Free
00004F68  541A      
00004F6A  584F      15520          addq.w    #4,A7
                    15521   ; OSSchedUnlock();
00004F6C  4E92      15522          jsr       (A2)
                    15523   ; *perr = OS_ERR_NONE;
00004F6E  2042      15524          move.l    D2,A0
00004F70  4210      15525          clr.b     (A0)
                    15526   ; return (OS_TRUE);
00004F72  7001      15527          moveq     #1,D0
00004F74  6000 002C 15528          bra       OSTmrDel_3
                    15529   OSTmrDel_10:
                    15530   ; case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
                    15531   ; case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
                    15532   ; OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
00004F78  2F03      15533          move.l    D3,-(A7)
00004F7A  4EB9 0000 15534          jsr       @ucos_ii_OSTmr_Free
00004F7E  541A      
00004F80  584F      15535          addq.w    #4,A7
                    15536   ; OSSchedUnlock();
00004F82  4E92      15537          jsr       (A2)
                    15538   ; *perr = OS_ERR_NONE;
00004F84  2042      15539          move.l    D2,A0
00004F86  4210      15540          clr.b     (A0)
                    15541   ; return (OS_TRUE);
00004F88  7001      15542          moveq     #1,D0
00004F8A  6016      15543          bra.s     OSTmrDel_3
                    15544   OSTmrDel_12:
                    15545   ; case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
                    15546   ; OSSchedUnlock();
00004F8C  4E92      15547          jsr       (A2)
                    15548   ; *perr = OS_ERR_TMR_INACTIVE;
00004F8E  2042      15549          move.l    D2,A0
00004F90  10BC 0087 15550          move.b    #135,(A0)
                    15551   ; return (OS_FALSE);
00004F94  4200      15552          clr.b     D0
00004F96  600A      15553          bra.s     OSTmrDel_3
                    15554   OSTmrDel_6:
                    15555   ; default:
                    15556   ; OSSchedUnlock();
00004F98  4E92      15557          jsr       (A2)
                    15558   ; *perr = OS_ERR_TMR_INVALID_STATE;
00004F9A  2042      15559          move.l    D2,A0
00004F9C  10BC 008D 15560          move.b    #141,(A0)
                    15561   ; return (OS_FALSE);
00004FA0  4200      15562          clr.b     D0
                    15563   OSTmrDel_3:
00004FA2  4CDF 040C 15564          movem.l   (A7)+,D2/D3/A2
00004FA6  4E5E      15565          unlk      A6
00004FA8  4E75      15566          rts
                    15567   ; }
                    15568   ; }
                    15569   ; #endif
                    15570   ; /*$PAGE*/
                    15571   ; /*
                    15572   ; *********************************************************************************************************
                    15573   ; *                                       GET THE NAME OF A TIMER
                    15574   ; *
                    15575   ; * Description: This function is called to obtain the name of a timer.
                    15576   ; *
                    15577   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
                    15578   ; *
                    15579   ; *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
                    15580   ; *
                    15581   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15582   ; *                               OS_ERR_NONE               The call was successful
                    15583   ; *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
                    15584   ; *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
                    15585   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15586   ; *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
                    15587   ; *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
                    15588   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15589   ; *
                    15590   ; * Returns    : The length of the string or 0 if the timer does not exist.
                    15591   ; *********************************************************************************************************
                    15592   ; */
                    15593   ; #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
                    15594   ; INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                    15595   ; INT8U   **pdest,
                    15596   ; INT8U    *perr)
                    15597   ; {
                    15598   _OSTmrNameGet:
00004FAA  4E56 FFFC 15599          link      A6,#-4
00004FAE  48E7 3020 15600          movem.l   D2/D3/A2,-(A7)
00004FB2  242E 0010 15601          move.l    16(A6),D2
00004FB6  45F8 0C78 15602          lea       _OSSchedUnlock.L,A2
00004FBA  262E 0008 15603          move.l    8(A6),D3
                    15604   ; INT8U  len;
                    15605   ; #ifdef OS_SAFETY_CRITICAL
                    15606   ; if (perr == (INT8U *)0) {
                    15607   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15608   ; return (0u);
                    15609   ; }
                    15610   ; #endif
                    15611   ; #if OS_ARG_CHK_EN > 0u
                    15612   ; if (pdest == (INT8U **)0) {
                    15613   ; *perr = OS_ERR_TMR_INVALID_DEST;
                    15614   ; return (0u);
                    15615   ; }
                    15616   ; if (ptmr == (OS_TMR *)0) {
                    15617   ; *perr = OS_ERR_TMR_INVALID;
                    15618   ; return (0u);
                    15619   ; }
                    15620   ; #endif
                    15621   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00004FBE  2043      15622          move.l    D3,A0
00004FC0  1010      15623          move.b    (A0),D0
00004FC2  0C00 0064 15624          cmp.b     #100,D0
00004FC6  670C      15625          beq.s     OSTmrNameGet_1
                    15626   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00004FC8  2042      15627          move.l    D2,A0
00004FCA  10BC 0089 15628          move.b    #137,(A0)
                    15629   ; return (0u);
00004FCE  4200      15630          clr.b     D0
00004FD0  6000 0082 15631          bra       OSTmrNameGet_3
                    15632   OSTmrNameGet_1:
                    15633   ; }
                    15634   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
00004FD4  1039 0080 15635          move.b    _OSIntNesting.L,D0
00004FD8  0246      
00004FDA  0C00 0000 15636          cmp.b     #0,D0
00004FDE  630C      15637          bls.s     OSTmrNameGet_4
                    15638   ; *perr = OS_ERR_NAME_GET_ISR;
00004FE0  2042      15639          move.l    D2,A0
00004FE2  10BC 0011 15640          move.b    #17,(A0)
                    15641   ; return (0u);
00004FE6  4200      15642          clr.b     D0
00004FE8  6000 006A 15643          bra       OSTmrNameGet_3
                    15644   OSTmrNameGet_4:
                    15645   ; }
                    15646   ; OSSchedLock();
00004FEC  4EB8 0C48 15647          jsr       _OSSchedLock
                    15648   ; switch (ptmr->OSTmrState) {
00004FF0  2043      15649          move.l    D3,A0
00004FF2  1028 0023 15650          move.b    35(A0),D0
00004FF6  C0BC 0000 15651          and.l     #255,D0
00004FFA  00FF      
00004FFC  0C80 0000 15652          cmp.l     #4,D0
00005000  0004      
00005002  6400 0046 15653          bhs       OSTmrNameGet_6
00005006  E380      15654          asl.l     #1,D0
00005008  303B 0806 15655          move.w    OSTmrNameGet_8(PC,D0.L),D0
0000500C  4EFB 0002 15656          jmp       OSTmrNameGet_8(PC,D0.W)
                    15657   OSTmrNameGet_8:
00005010  002E      15658          dc.w      OSTmrNameGet_12-OSTmrNameGet_8
00005012  0008      15659          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
00005014  0008      15660          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
00005016  0008      15661          dc.w      OSTmrNameGet_9-OSTmrNameGet_8
                    15662   OSTmrNameGet_9:
                    15663   ; case OS_TMR_STATE_RUNNING:
                    15664   ; case OS_TMR_STATE_STOPPED:
                    15665   ; case OS_TMR_STATE_COMPLETED:
                    15666   ; *pdest = ptmr->OSTmrName;
00005018  2043      15667          move.l    D3,A0
0000501A  226E 000C 15668          move.l    12(A6),A1
0000501E  22A8 001E 15669          move.l    30(A0),(A1)
                    15670   ; len    = OS_StrLen(*pdest);
00005022  206E 000C 15671          move.l    12(A6),A0
00005026  2F10      15672          move.l    (A0),-(A7)
00005028  4EB8 14A2 15673          jsr       _OS_StrLen
0000502C  584F      15674          addq.w    #4,A7
0000502E  1D40 FFFF 15675          move.b    D0,-1(A6)
                    15676   ; OSSchedUnlock();
00005032  4E92      15677          jsr       (A2)
                    15678   ; *perr = OS_ERR_NONE;
00005034  2042      15679          move.l    D2,A0
00005036  4210      15680          clr.b     (A0)
                    15681   ; return (len);
00005038  102E FFFF 15682          move.b    -1(A6),D0
0000503C  6016      15683          bra.s     OSTmrNameGet_3
                    15684   OSTmrNameGet_12:
                    15685   ; case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
                    15686   ; OSSchedUnlock();
0000503E  4E92      15687          jsr       (A2)
                    15688   ; *perr = OS_ERR_TMR_INACTIVE;
00005040  2042      15689          move.l    D2,A0
00005042  10BC 0087 15690          move.b    #135,(A0)
                    15691   ; return (0u);
00005046  4200      15692          clr.b     D0
00005048  600A      15693          bra.s     OSTmrNameGet_3
                    15694   OSTmrNameGet_6:
                    15695   ; default:
                    15696   ; OSSchedUnlock();
0000504A  4E92      15697          jsr       (A2)
                    15698   ; *perr = OS_ERR_TMR_INVALID_STATE;
0000504C  2042      15699          move.l    D2,A0
0000504E  10BC 008D 15700          move.b    #141,(A0)
                    15701   ; return (0u);
00005052  4200      15702          clr.b     D0
                    15703   OSTmrNameGet_3:
00005054  4CDF 040C 15704          movem.l   (A7)+,D2/D3/A2
00005058  4E5E      15705          unlk      A6
0000505A  4E75      15706          rts
                    15707   ; }
                    15708   ; }
                    15709   ; #endif
                    15710   ; /*$PAGE*/
                    15711   ; /*
                    15712   ; *********************************************************************************************************
                    15713   ; *                          GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
                    15714   ; *
                    15715   ; * Description: This function is called to get the number of ticks before a timer times out.
                    15716   ; *
                    15717   ; * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
                    15718   ; *
                    15719   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15720   ; *                               OS_ERR_NONE
                    15721   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    15722   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15723   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    15724   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    15725   ; *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
                    15726   ; *
                    15727   ; * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments. 
                    15728   ; *              In other words, if OSTmr_Task() is signaled every 1/10 of a second then the returned 
                    15729   ; *              value represents the number of 1/10 of a second remaining before the timer expires.
                    15730   ; *********************************************************************************************************
                    15731   ; */
                    15732   ; #if OS_TMR_EN > 0u
                    15733   ; INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                    15734   ; INT8U   *perr)
                    15735   ; {
                    15736   _OSTmrRemainGet:
0000505C  4E56 0000 15737          link      A6,#0
00005060  48E7 3820 15738          movem.l   D2/D3/D4/A2,-(A7)
00005064  242E 000C 15739          move.l    12(A6),D2
00005068  262E 0008 15740          move.l    8(A6),D3
0000506C  45F8 0C78 15741          lea       _OSSchedUnlock.L,A2
                    15742   ; INT32U  remain;
                    15743   ; #ifdef OS_SAFETY_CRITICAL
                    15744   ; if (perr == (INT8U *)0) {
                    15745   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15746   ; return (0u);
                    15747   ; }
                    15748   ; #endif
                    15749   ; #if OS_ARG_CHK_EN > 0u
                    15750   ; if (ptmr == (OS_TMR *)0) {
                    15751   ; *perr = OS_ERR_TMR_INVALID;
                    15752   ; return (0u);
                    15753   ; }
                    15754   ; #endif
                    15755   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00005070  2043      15756          move.l    D3,A0
00005072  1010      15757          move.b    (A0),D0
00005074  0C00 0064 15758          cmp.b     #100,D0
00005078  670C      15759          beq.s     OSTmrRemainGet_1
                    15760   ; *perr = OS_ERR_TMR_INVALID_TYPE;
0000507A  2042      15761          move.l    D2,A0
0000507C  10BC 0089 15762          move.b    #137,(A0)
                    15763   ; return (0u);
00005080  4280      15764          clr.l     D0
00005082  6000 00CE 15765          bra       OSTmrRemainGet_3
                    15766   OSTmrRemainGet_1:
                    15767   ; }
                    15768   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
00005086  1039 0080 15769          move.b    _OSIntNesting.L,D0
0000508A  0246      
0000508C  0C00 0000 15770          cmp.b     #0,D0
00005090  630C      15771          bls.s     OSTmrRemainGet_4
                    15772   ; *perr = OS_ERR_TMR_ISR;
00005092  2042      15773          move.l    D2,A0
00005094  10BC 008B 15774          move.b    #139,(A0)
                    15775   ; return (0u);
00005098  4280      15776          clr.l     D0
0000509A  6000 00B6 15777          bra       OSTmrRemainGet_3
                    15778   OSTmrRemainGet_4:
                    15779   ; }
                    15780   ; OSSchedLock();
0000509E  4EB8 0C48 15781          jsr       _OSSchedLock
                    15782   ; switch (ptmr->OSTmrState) {
000050A2  2043      15783          move.l    D3,A0
000050A4  1028 0023 15784          move.b    35(A0),D0
000050A8  C0BC 0000 15785          and.l     #255,D0
000050AC  00FF      
000050AE  0C80 0000 15786          cmp.l     #4,D0
000050B2  0004      
000050B4  6400 0092 15787          bhs       OSTmrRemainGet_6
000050B8  E380      15788          asl.l     #1,D0
000050BA  303B 0806 15789          move.w    OSTmrRemainGet_8(PC,D0.L),D0
000050BE  4EFB 0002 15790          jmp       OSTmrRemainGet_8(PC,D0.W)
                    15791   OSTmrRemainGet_8:
000050C2  007A      15792          dc.w      OSTmrRemainGet_12-OSTmrRemainGet_8
000050C4  0022      15793          dc.w      OSTmrRemainGet_10-OSTmrRemainGet_8
000050C6  0070      15794          dc.w      OSTmrRemainGet_11-OSTmrRemainGet_8
000050C8  0008      15795          dc.w      OSTmrRemainGet_9-OSTmrRemainGet_8
                    15796   OSTmrRemainGet_9:
                    15797   ; case OS_TMR_STATE_RUNNING:
                    15798   ; remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
000050CA  2043      15799          move.l    D3,A0
000050CC  2028 0012 15800          move.l    18(A0),D0
000050D0  90B9 0080 15801          sub.l     _OSTmrTime.L,D0
000050D4  0CBE      
000050D6  2800      15802          move.l    D0,D4
                    15803   ; OSSchedUnlock();
000050D8  4E92      15804          jsr       (A2)
                    15805   ; *perr  = OS_ERR_NONE;
000050DA  2042      15806          move.l    D2,A0
000050DC  4210      15807          clr.b     (A0)
                    15808   ; return (remain);
000050DE  2004      15809          move.l    D4,D0
000050E0  6000 0070 15810          bra       OSTmrRemainGet_3
                    15811   OSTmrRemainGet_10:
                    15812   ; case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
                    15813   ; switch (ptmr->OSTmrOpt) {
000050E4  2043      15814          move.l    D3,A0
000050E6  1028 0022 15815          move.b    34(A0),D0
000050EA  C0BC 0000 15816          and.l     #255,D0
000050EE  00FF      
000050F0  0C80 0000 15817          cmp.l     #2,D0
000050F4  0002      
000050F6  670C      15818          beq.s     OSTmrRemainGet_16
000050F8  6228      15819          bhi.s     OSTmrRemainGet_17
000050FA  0C80 0000 15820          cmp.l     #1,D0
000050FE  0001      
00005100  6720      15821          beq.s     OSTmrRemainGet_17
00005102  601E      15822          bra.s     OSTmrRemainGet_17
                    15823   OSTmrRemainGet_16:
                    15824   ; case OS_TMR_OPT_PERIODIC:
                    15825   ; if (ptmr->OSTmrDly == 0u) {
00005104  2043      15826          move.l    D3,A0
00005106  2028 0016 15827          move.l    22(A0),D0
0000510A  6608      15828          bne.s     OSTmrRemainGet_19
                    15829   ; remain = ptmr->OSTmrPeriod;
0000510C  2043      15830          move.l    D3,A0
0000510E  2828 001A 15831          move.l    26(A0),D4
00005112  6006      15832          bra.s     OSTmrRemainGet_20
                    15833   OSTmrRemainGet_19:
                    15834   ; } else {
                    15835   ; remain = ptmr->OSTmrDly;
00005114  2043      15836          move.l    D3,A0
00005116  2828 0016 15837          move.l    22(A0),D4
                    15838   OSTmrRemainGet_20:
                    15839   ; }
                    15840   ; OSSchedUnlock();
0000511A  4E92      15841          jsr       (A2)
                    15842   ; *perr  = OS_ERR_NONE;
0000511C  2042      15843          move.l    D2,A0
0000511E  4210      15844          clr.b     (A0)
                    15845   ; break;
00005120  600C      15846          bra.s     OSTmrRemainGet_15
                    15847   OSTmrRemainGet_17:
                    15848   ; case OS_TMR_OPT_ONE_SHOT:
                    15849   ; default:
                    15850   ; remain = ptmr->OSTmrDly;
00005122  2043      15851          move.l    D3,A0
00005124  2828 0016 15852          move.l    22(A0),D4
                    15853   ; OSSchedUnlock();
00005128  4E92      15854          jsr       (A2)
                    15855   ; *perr  = OS_ERR_NONE;
0000512A  2042      15856          move.l    D2,A0
0000512C  4210      15857          clr.b     (A0)
                    15858   ; break;
                    15859   OSTmrRemainGet_15:
                    15860   ; }
                    15861   ; return (remain);
0000512E  2004      15862          move.l    D4,D0
00005130  6020      15863          bra.s     OSTmrRemainGet_3
                    15864   OSTmrRemainGet_11:
                    15865   ; case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
                    15866   ; OSSchedUnlock();
00005132  4E92      15867          jsr       (A2)
                    15868   ; *perr = OS_ERR_NONE;
00005134  2042      15869          move.l    D2,A0
00005136  4210      15870          clr.b     (A0)
                    15871   ; return (0u);
00005138  4280      15872          clr.l     D0
0000513A  6016      15873          bra.s     OSTmrRemainGet_3
                    15874   OSTmrRemainGet_12:
                    15875   ; case OS_TMR_STATE_UNUSED:
                    15876   ; OSSchedUnlock();
0000513C  4E92      15877          jsr       (A2)
                    15878   ; *perr = OS_ERR_TMR_INACTIVE;
0000513E  2042      15879          move.l    D2,A0
00005140  10BC 0087 15880          move.b    #135,(A0)
                    15881   ; return (0u);
00005144  4280      15882          clr.l     D0
00005146  600A      15883          bra.s     OSTmrRemainGet_3
                    15884   OSTmrRemainGet_6:
                    15885   ; default:
                    15886   ; OSSchedUnlock();
00005148  4E92      15887          jsr       (A2)
                    15888   ; *perr = OS_ERR_TMR_INVALID_STATE;
0000514A  2042      15889          move.l    D2,A0
0000514C  10BC 008D 15890          move.b    #141,(A0)
                    15891   ; return (0u);
00005150  4280      15892          clr.l     D0
                    15893   OSTmrRemainGet_3:
00005152  4CDF 041C 15894          movem.l   (A7)+,D2/D3/D4/A2
00005156  4E5E      15895          unlk      A6
00005158  4E75      15896          rts
                    15897   ; }
                    15898   ; }
                    15899   ; #endif
                    15900   ; /*$PAGE*/
                    15901   ; /*
                    15902   ; *********************************************************************************************************
                    15903   ; *                                  FIND OUT WHAT STATE A TIMER IS IN
                    15904   ; *
                    15905   ; * Description: This function is called to determine what state the timer is in:
                    15906   ; *
                    15907   ; *                  OS_TMR_STATE_UNUSED     the timer has not been created
                    15908   ; *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
                    15909   ; *                  OS_TMR_STATE_COMPLETED  the timer is in ONE-SHOT mode and has completed it's timeout
                    15910   ; *                  OS_TMR_STATE_RUNNING    the timer is currently running
                    15911   ; *
                    15912   ; * Arguments  : ptmr          Is a pointer to the desired timer
                    15913   ; *
                    15914   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    15915   ; *                               OS_ERR_NONE
                    15916   ; *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
                    15917   ; *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
                    15918   ; *                               OS_ERR_TMR_ISR            if the call was made from an ISR
                    15919   ; *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
                    15920   ; *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
                    15921   ; *
                    15922   ; * Returns    : The current state of the timer (see description).
                    15923   ; *********************************************************************************************************
                    15924   ; */
                    15925   ; #if OS_TMR_EN > 0u
                    15926   ; INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                    15927   ; INT8U   *perr)
                    15928   ; {
                    15929   _OSTmrStateGet:
0000515A  4E56 0000 15930          link      A6,#0
0000515E  48E7 3000 15931          movem.l   D2/D3,-(A7)
00005162  242E 000C 15932          move.l    12(A6),D2
                    15933   ; INT8U  state;
                    15934   ; #ifdef OS_SAFETY_CRITICAL
                    15935   ; if (perr == (INT8U *)0) {
                    15936   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    15937   ; return (0u);
                    15938   ; }
                    15939   ; #endif
                    15940   ; #if OS_ARG_CHK_EN > 0u
                    15941   ; if (ptmr == (OS_TMR *)0) {
                    15942   ; *perr = OS_ERR_TMR_INVALID;
                    15943   ; return (0u);
                    15944   ; }
                    15945   ; #endif
                    15946   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
00005166  206E 0008 15947          move.l    8(A6),A0
0000516A  1010      15948          move.b    (A0),D0
0000516C  0C00 0064 15949          cmp.b     #100,D0
00005170  670C      15950          beq.s     OSTmrStateGet_1
                    15951   ; *perr = OS_ERR_TMR_INVALID_TYPE;
00005172  2042      15952          move.l    D2,A0
00005174  10BC 0089 15953          move.b    #137,(A0)
                    15954   ; return (0u);
00005178  4200      15955          clr.b     D0
0000517A  6000 005A 15956          bra       OSTmrStateGet_3
                    15957   OSTmrStateGet_1:
                    15958   ; }
                    15959   ; if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
0000517E  1039 0080 15960          move.b    _OSIntNesting.L,D0
00005182  0246      
00005184  0C00 0000 15961          cmp.b     #0,D0
00005188  630C      15962          bls.s     OSTmrStateGet_4
                    15963   ; *perr = OS_ERR_TMR_ISR;
0000518A  2042      15964          move.l    D2,A0
0000518C  10BC 008B 15965          move.b    #139,(A0)
                    15966   ; return (0u);
00005190  4200      15967          clr.b     D0
00005192  6000 0042 15968          bra       OSTmrStateGet_3
                    15969   OSTmrStateGet_4:
                    15970   ; }
                    15971   ; OSSchedLock();
00005196  4EB8 0C48 15972          jsr       _OSSchedLock
                    15973   ; state = ptmr->OSTmrState;
0000519A  206E 0008 15974          move.l    8(A6),A0
0000519E  1628 0023 15975          move.b    35(A0),D3
                    15976   ; switch (state) {
000051A2  C6BC 0000 15977          and.l     #255,D3
000051A6  00FF      
000051A8  2003      15978          move.l    D3,D0
000051AA  0C80 0000 15979          cmp.l     #4,D0
000051AE  0004      
000051B0  6418      15980          bhs.s     OSTmrStateGet_6
000051B2  E380      15981          asl.l     #1,D0
000051B4  303B 0806 15982          move.w    OSTmrStateGet_8(PC,D0.L),D0
000051B8  4EFB 0002 15983          jmp       OSTmrStateGet_8(PC,D0.W)
                    15984   OSTmrStateGet_8:
000051BC  0008      15985          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000051BE  0008      15986          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000051C0  0008      15987          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
000051C2  0008      15988          dc.w      OSTmrStateGet_9-OSTmrStateGet_8
                    15989   OSTmrStateGet_9:
                    15990   ; case OS_TMR_STATE_UNUSED:
                    15991   ; case OS_TMR_STATE_STOPPED:
                    15992   ; case OS_TMR_STATE_COMPLETED:
                    15993   ; case OS_TMR_STATE_RUNNING:
                    15994   ; *perr = OS_ERR_NONE;
000051C4  2042      15995          move.l    D2,A0
000051C6  4210      15996          clr.b     (A0)
                    15997   ; break;
000051C8  6006      15998          bra.s     OSTmrStateGet_7
                    15999   OSTmrStateGet_6:
                    16000   ; default:
                    16001   ; *perr = OS_ERR_TMR_INVALID_STATE;
000051CA  2042      16002          move.l    D2,A0
000051CC  10BC 008D 16003          move.b    #141,(A0)
                    16004   ; break;
                    16005   OSTmrStateGet_7:
                    16006   ; }
                    16007   ; OSSchedUnlock();
000051D0  4EB8 0C78 16008          jsr       _OSSchedUnlock
                    16009   ; return (state);
000051D4  1003      16010          move.b    D3,D0
                    16011   OSTmrStateGet_3:
000051D6  4CDF 000C 16012          movem.l   (A7)+,D2/D3
000051DA  4E5E      16013          unlk      A6
000051DC  4E75      16014          rts
                    16015   ; }
                    16016   ; #endif
                    16017   ; /*$PAGE*/
                    16018   ; /*
                    16019   ; *********************************************************************************************************
                    16020   ; *                                            START A TIMER
                    16021   ; *
                    16022   ; * Description: This function is called by your application code to start a timer.
                    16023   ; *
                    16024   ; * Arguments  : ptmr          Is a pointer to an OS_TMR
                    16025   ; *
                    16026   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16027   ; *                               OS_ERR_NONE
                    16028   ; *                               OS_ERR_TMR_INVALID
                    16029   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16030   ; *                               OS_ERR_TMR_ISR             if the call was made from an ISR
                    16031   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16032   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16033   ; *
                    16034   ; * Returns    : OS_TRUE    if the timer was started
                    16035   ; *              OS_FALSE   if an error was detected
                    16036   ; *********************************************************************************************************
                    16037   ; */
                    16038   ; #if OS_TMR_EN > 0u
                    16039   ; BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                    16040   ; INT8U    *perr)
                    16041   ; {
                    16042   _OSTmrStart:
000051DE  4E56 0000 16043          link      A6,#0
000051E2  48E7 3020 16044          movem.l   D2/D3/A2,-(A7)
000051E6  242E 000C 16045          move.l    12(A6),D2
000051EA  262E 0008 16046          move.l    8(A6),D3
000051EE  45F8 0C78 16047          lea       _OSSchedUnlock.L,A2
                    16048   ; #ifdef OS_SAFETY_CRITICAL
                    16049   ; if (perr == (INT8U *)0) {
                    16050   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16051   ; return (OS_FALSE);
                    16052   ; }
                    16053   ; #endif
                    16054   ; #if OS_ARG_CHK_EN > 0u
                    16055   ; if (ptmr == (OS_TMR *)0) {
                    16056   ; *perr = OS_ERR_TMR_INVALID;
                    16057   ; return (OS_FALSE);
                    16058   ; }
                    16059   ; #endif
                    16060   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
000051F2  2043      16061          move.l    D3,A0
000051F4  1010      16062          move.b    (A0),D0
000051F6  0C00 0064 16063          cmp.b     #100,D0
000051FA  670C      16064          beq.s     OSTmrStart_1
                    16065   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000051FC  2042      16066          move.l    D2,A0
000051FE  10BC 0089 16067          move.b    #137,(A0)
                    16068   ; return (OS_FALSE);
00005202  4200      16069          clr.b     D0
00005204  6000 0094 16070          bra       OSTmrStart_3
                    16071   OSTmrStart_1:
                    16072   ; }
                    16073   ; if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
00005208  1039 0080 16074          move.b    _OSIntNesting.L,D0
0000520C  0246      
0000520E  0C00 0000 16075          cmp.b     #0,D0
00005212  630C      16076          bls.s     OSTmrStart_4
                    16077   ; *perr  = OS_ERR_TMR_ISR;
00005214  2042      16078          move.l    D2,A0
00005216  10BC 008B 16079          move.b    #139,(A0)
                    16080   ; return (OS_FALSE);
0000521A  4200      16081          clr.b     D0
0000521C  6000 007C 16082          bra       OSTmrStart_3
                    16083   OSTmrStart_4:
                    16084   ; }
                    16085   ; OSSchedLock();
00005220  4EB8 0C48 16086          jsr       _OSSchedLock
                    16087   ; switch (ptmr->OSTmrState) {
00005224  2043      16088          move.l    D3,A0
00005226  1028 0023 16089          move.b    35(A0),D0
0000522A  C0BC 0000 16090          and.l     #255,D0
0000522E  00FF      
00005230  0C80 0000 16091          cmp.l     #4,D0
00005234  0004      
00005236  6400 0058 16092          bhs       OSTmrStart_6
0000523A  E380      16093          asl.l     #1,D0
0000523C  303B 0806 16094          move.w    OSTmrStart_8(PC,D0.L),D0
00005240  4EFB 0002 16095          jmp       OSTmrStart_8(PC,D0.W)
                    16096   OSTmrStart_8:
00005244  0040      16097          dc.w      OSTmrStart_12-OSTmrStart_8
00005246  002A      16098          dc.w      OSTmrStart_10-OSTmrStart_8
00005248  002A      16099          dc.w      OSTmrStart_10-OSTmrStart_8
0000524A  0008      16100          dc.w      OSTmrStart_9-OSTmrStart_8
                    16101   OSTmrStart_9:
                    16102   ; case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
                    16103   ; OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
0000524C  2F03      16104          move.l    D3,-(A7)
0000524E  4EB9 0000 16105          jsr       @ucos_ii_OSTmr_Unlink
00005252  56D6      
00005254  584F      16106          addq.w    #4,A7
                    16107   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
00005256  42A7      16108          clr.l     -(A7)
00005258  2F03      16109          move.l    D3,-(A7)
0000525A  4EB9 0000 16110          jsr       @ucos_ii_OSTmr_Link
0000525E  5602      
00005260  504F      16111          addq.w    #8,A7
                    16112   ; OSSchedUnlock();
00005262  4E92      16113          jsr       (A2)
                    16114   ; *perr = OS_ERR_NONE;
00005264  2042      16115          move.l    D2,A0
00005266  4210      16116          clr.b     (A0)
                    16117   ; return (OS_TRUE);
00005268  7001      16118          moveq     #1,D0
0000526A  6000 002E 16119          bra       OSTmrStart_3
                    16120   OSTmrStart_10:
                    16121   ; case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
                    16122   ; case OS_TMR_STATE_COMPLETED:
                    16123   ; OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
0000526E  42A7      16124          clr.l     -(A7)
00005270  2F03      16125          move.l    D3,-(A7)
00005272  4EB9 0000 16126          jsr       @ucos_ii_OSTmr_Link
00005276  5602      
00005278  504F      16127          addq.w    #8,A7
                    16128   ; OSSchedUnlock();
0000527A  4E92      16129          jsr       (A2)
                    16130   ; *perr = OS_ERR_NONE;
0000527C  2042      16131          move.l    D2,A0
0000527E  4210      16132          clr.b     (A0)
                    16133   ; return (OS_TRUE);
00005280  7001      16134          moveq     #1,D0
00005282  6016      16135          bra.s     OSTmrStart_3
                    16136   OSTmrStart_12:
                    16137   ; case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
                    16138   ; OSSchedUnlock();
00005284  4E92      16139          jsr       (A2)
                    16140   ; *perr = OS_ERR_TMR_INACTIVE;
00005286  2042      16141          move.l    D2,A0
00005288  10BC 0087 16142          move.b    #135,(A0)
                    16143   ; return (OS_FALSE);
0000528C  4200      16144          clr.b     D0
0000528E  600A      16145          bra.s     OSTmrStart_3
                    16146   OSTmrStart_6:
                    16147   ; default:
                    16148   ; OSSchedUnlock();
00005290  4E92      16149          jsr       (A2)
                    16150   ; *perr = OS_ERR_TMR_INVALID_STATE;
00005292  2042      16151          move.l    D2,A0
00005294  10BC 008D 16152          move.b    #141,(A0)
                    16153   ; return (OS_FALSE);
00005298  4200      16154          clr.b     D0
                    16155   OSTmrStart_3:
0000529A  4CDF 040C 16156          movem.l   (A7)+,D2/D3/A2
0000529E  4E5E      16157          unlk      A6
000052A0  4E75      16158          rts
                    16159   ; }
                    16160   ; }
                    16161   ; #endif
                    16162   ; /*$PAGE*/
                    16163   ; /*
                    16164   ; *********************************************************************************************************
                    16165   ; *                                            STOP A TIMER
                    16166   ; *
                    16167   ; * Description: This function is called by your application code to stop a timer.
                    16168   ; *
                    16169   ; * Arguments  : ptmr          Is a pointer to the timer to stop.
                    16170   ; *
                    16171   ; *              opt           Allows you to specify an option to this functions which can be:
                    16172   ; *
                    16173   ; *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
                    16174   ; *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the 
                    16175   ; *                                                        callback argument specified when the timer 
                    16176   ; *                                                        was created.
                    16177   ; *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the 
                    16178   ; *                                                        callback argument specified in THIS function call.
                    16179   ; *
                    16180   ; *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
                    16181   ; *                            function instead of the timer's callback argument.  In other words, use 
                    16182   ; *                            'callback_arg' passed in THIS function INSTEAD of ptmr->OSTmrCallbackArg.
                    16183   ; *
                    16184   ; *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
                    16185   ; *                               OS_ERR_NONE
                    16186   ; *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
                    16187   ; *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
                    16188   ; *                               OS_ERR_TMR_ISR             if the function was called from an ISR
                    16189   ; *                               OS_ERR_TMR_INACTIVE        if the timer was not created
                    16190   ; *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
                    16191   ; *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
                    16192   ; *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
                    16193   ; *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function defined
                    16194   ; *
                    16195   ; * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_TRUE)
                    16196   ; *              OS_FALSE      If not
                    16197   ; *********************************************************************************************************
                    16198   ; */
                    16199   ; #if OS_TMR_EN > 0u
                    16200   ; BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    16201   ; INT8U    opt,
                    16202   ; void    *callback_arg,
                    16203   ; INT8U   *perr)
                    16204   ; {
                    16205   _OSTmrStop:
000052A2  4E56 0000 16206          link      A6,#0
000052A6  48E7 3820 16207          movem.l   D2/D3/D4/A2,-(A7)
000052AA  242E 0014 16208          move.l    20(A6),D2
000052AE  262E 0008 16209          move.l    8(A6),D3
000052B2  45F8 0C78 16210          lea       _OSSchedUnlock.L,A2
                    16211   ; OS_TMR_CALLBACK  pfnct;
                    16212   ; #ifdef OS_SAFETY_CRITICAL
                    16213   ; if (perr == (INT8U *)0) {
                    16214   ; OS_SAFETY_CRITICAL_EXCEPTION();
                    16215   ; return (OS_FALSE);
                    16216   ; }
                    16217   ; #endif
                    16218   ; #if OS_ARG_CHK_EN > 0u
                    16219   ; if (ptmr == (OS_TMR *)0) {
                    16220   ; *perr = OS_ERR_TMR_INVALID;
                    16221   ; return (OS_FALSE);
                    16222   ; }
                    16223   ; #endif
                    16224   ; if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
000052B6  2043      16225          move.l    D3,A0
000052B8  1010      16226          move.b    (A0),D0
000052BA  0C00 0064 16227          cmp.b     #100,D0
000052BE  670C      16228          beq.s     OSTmrStop_1
                    16229   ; *perr = OS_ERR_TMR_INVALID_TYPE;
000052C0  2042      16230          move.l    D2,A0
000052C2  10BC 0089 16231          move.b    #137,(A0)
                    16232   ; return (OS_FALSE);
000052C6  4200      16233          clr.b     D0
000052C8  6000 00F2 16234          bra       OSTmrStop_3
                    16235   OSTmrStop_1:
                    16236   ; }
                    16237   ; if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
000052CC  1039 0080 16238          move.b    _OSIntNesting.L,D0
000052D0  0246      
000052D2  0C00 0000 16239          cmp.b     #0,D0
000052D6  630C      16240          bls.s     OSTmrStop_4
                    16241   ; *perr  = OS_ERR_TMR_ISR;
000052D8  2042      16242          move.l    D2,A0
000052DA  10BC 008B 16243          move.b    #139,(A0)
                    16244   ; return (OS_FALSE);
000052DE  4200      16245          clr.b     D0
000052E0  6000 00DA 16246          bra       OSTmrStop_3
                    16247   OSTmrStop_4:
                    16248   ; }
                    16249   ; OSSchedLock();
000052E4  4EB8 0C48 16250          jsr       _OSSchedLock
                    16251   ; switch (ptmr->OSTmrState) {
000052E8  2043      16252          move.l    D3,A0
000052EA  1028 0023 16253          move.b    35(A0),D0
000052EE  C0BC 0000 16254          and.l     #255,D0
000052F2  00FF      
000052F4  0C80 0000 16255          cmp.l     #4,D0
000052F8  0004      
000052FA  6400 00B6 16256          bhs       OSTmrStop_6
000052FE  E380      16257          asl.l     #1,D0
00005300  303B 0806 16258          move.w    OSTmrStop_8(PC,D0.L),D0
00005304  4EFB 0002 16259          jmp       OSTmrStop_8(PC,D0.W)
                    16260   OSTmrStop_8:
00005308  009E      16261          dc.w      OSTmrStop_12-OSTmrStop_8
0000530A  0092      16262          dc.w      OSTmrStop_10-OSTmrStop_8
0000530C  0092      16263          dc.w      OSTmrStop_10-OSTmrStop_8
0000530E  0008      16264          dc.w      OSTmrStop_9-OSTmrStop_8
                    16265   OSTmrStop_9:
                    16266   ; case OS_TMR_STATE_RUNNING:
                    16267   ; OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
00005310  2F03      16268          move.l    D3,-(A7)
00005312  4EB9 0000 16269          jsr       @ucos_ii_OSTmr_Unlink
00005316  56D6      
00005318  584F      16270          addq.w    #4,A7
                    16271   ; *perr = OS_ERR_NONE;
0000531A  2042      16272          move.l    D2,A0
0000531C  4210      16273          clr.b     (A0)
                    16274   ; switch (opt) {
0000531E  102E 000F 16275          move.b    15(A6),D0
00005322  C0BC 0000 16276          and.l     #255,D0
00005326  00FF      
00005328  0C80 0000 16277          cmp.l     #3,D0
0000532C  0003      
0000532E  6718      16278          beq.s     OSTmrStop_16
00005330  620A      16279          bhi.s     OSTmrStop_20
00005332  4A80      16280          tst.l     D0
00005334  6700 0056 16281          beq       OSTmrStop_18
00005338  6000 0054 16282          bra       OSTmrStop_14
                    16283   OSTmrStop_20:
0000533C  0C80 0000 16284          cmp.l     #4,D0
00005340  0004      
00005342  6728      16285          beq.s     OSTmrStop_17
00005344  6000 0048 16286          bra       OSTmrStop_14
                    16287   OSTmrStop_16:
                    16288   ; case OS_TMR_OPT_CALLBACK:
                    16289   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
00005348  2043      16290          move.l    D3,A0
0000534A  2828 0002 16291          move.l    2(A0),D4
                    16292   ; if (pfnct != (OS_TMR_CALLBACK)0) {
0000534E  4A84      16293          tst.l     D4
00005350  6710      16294          beq.s     OSTmrStop_21
                    16295   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
00005352  2043      16296          move.l    D3,A0
00005354  2F28 0006 16297          move.l    6(A0),-(A7)
00005358  2F03      16298          move.l    D3,-(A7)
0000535A  2044      16299          move.l    D4,A0
0000535C  4E90      16300          jsr       (A0)
0000535E  504F      16301          addq.w    #8,A7
00005360  6006      16302          bra.s     OSTmrStop_22
                    16303   OSTmrStop_21:
                    16304   ; } else {
                    16305   ; *perr = OS_ERR_TMR_NO_CALLBACK;
00005362  2042      16306          move.l    D2,A0
00005364  10BC 008F 16307          move.b    #143,(A0)
                    16308   OSTmrStop_22:
                    16309   ; }
                    16310   ; break;
00005368  6000 002A 16311          bra       OSTmrStop_15
                    16312   OSTmrStop_17:
                    16313   ; case OS_TMR_OPT_CALLBACK_ARG:
                    16314   ; pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
0000536C  2043      16315          move.l    D3,A0
0000536E  2828 0002 16316          move.l    2(A0),D4
                    16317   ; if (pfnct != (OS_TMR_CALLBACK)0) {
00005372  4A84      16318          tst.l     D4
00005374  670E      16319          beq.s     OSTmrStop_23
                    16320   ; (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
00005376  2F2E 0010 16321          move.l    16(A6),-(A7)
0000537A  2F03      16322          move.l    D3,-(A7)
0000537C  2044      16323          move.l    D4,A0
0000537E  4E90      16324          jsr       (A0)
00005380  504F      16325          addq.w    #8,A7
00005382  6006      16326          bra.s     OSTmrStop_24
                    16327   OSTmrStop_23:
                    16328   ; } else {
                    16329   ; *perr = OS_ERR_TMR_NO_CALLBACK;
00005384  2042      16330          move.l    D2,A0
00005386  10BC 008F 16331          move.b    #143,(A0)
                    16332   OSTmrStop_24:
                    16333   ; }
                    16334   ; break;
0000538A  6008      16335          bra.s     OSTmrStop_15
                    16336   OSTmrStop_18:
                    16337   ; case OS_TMR_OPT_NONE:
                    16338   ; break;
0000538C  6006      16339          bra.s     OSTmrStop_15
                    16340   OSTmrStop_14:
                    16341   ; default:
                    16342   ; *perr = OS_ERR_TMR_INVALID_OPT;
0000538E  2042      16343          move.l    D2,A0
00005390  10BC 0084 16344          move.b    #132,(A0)
                    16345   ; break;
                    16346   OSTmrStop_15:
                    16347   ; }
                    16348   ; OSSchedUnlock();
00005394  4E92      16349          jsr       (A2)
                    16350   ; return (OS_TRUE);
00005396  7001      16351          moveq     #1,D0
00005398  6022      16352          bra.s     OSTmrStop_3
                    16353   OSTmrStop_10:
                    16354   ; case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
                    16355   ; case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
                    16356   ; OSSchedUnlock();
0000539A  4E92      16357          jsr       (A2)
                    16358   ; *perr = OS_ERR_TMR_STOPPED;
0000539C  2042      16359          move.l    D2,A0
0000539E  10BC 008E 16360          move.b    #142,(A0)
                    16361   ; return (OS_TRUE);
000053A2  7001      16362          moveq     #1,D0
000053A4  6016      16363          bra.s     OSTmrStop_3
                    16364   OSTmrStop_12:
                    16365   ; case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
                    16366   ; OSSchedUnlock();
000053A6  4E92      16367          jsr       (A2)
                    16368   ; *perr = OS_ERR_TMR_INACTIVE;
000053A8  2042      16369          move.l    D2,A0
000053AA  10BC 0087 16370          move.b    #135,(A0)
                    16371   ; return (OS_FALSE);
000053AE  4200      16372          clr.b     D0
000053B0  600A      16373          bra.s     OSTmrStop_3
                    16374   OSTmrStop_6:
                    16375   ; default:
                    16376   ; OSSchedUnlock();
000053B2  4E92      16377          jsr       (A2)
                    16378   ; *perr = OS_ERR_TMR_INVALID_STATE;
000053B4  2042      16379          move.l    D2,A0
000053B6  10BC 008D 16380          move.b    #141,(A0)
                    16381   ; return (OS_FALSE);
000053BA  4200      16382          clr.b     D0
                    16383   OSTmrStop_3:
000053BC  4CDF 041C 16384          movem.l   (A7)+,D2/D3/D4/A2
000053C0  4E5E      16385          unlk      A6
000053C2  4E75      16386          rts
                    16387   ; }
                    16388   ; }
                    16389   ; #endif
                    16390   ; /*$PAGE*/
                    16391   ; /*
                    16392   ; *********************************************************************************************************
                    16393   ; *                             SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
                    16394   ; *
                    16395   ; * Description: This function is typically called by the ISR that occurs at the timer tick rate and is 
                    16396   ; *              used to signal to OSTmr_Task() that it's time to update the timers.
                    16397   ; *
                    16398   ; * Arguments  : none
                    16399   ; *
                    16400   ; * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
                    16401   ; *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle 
                    16402   ; *                                  the timers. This would indicate that your system is heavily loaded.
                    16403   ; *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for 
                    16404   ; *                                  signaling is created by uC/OS-II.
                    16405   ; *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore 
                    16406   ; *                                  used for signaling is created by uC/OS-II.
                    16407   ; *********************************************************************************************************
                    16408   ; */
                    16409   ; #if OS_TMR_EN > 0u
                    16410   ; INT8U  OSTmrSignal (void)
                    16411   ; {
                    16412   _OSTmrSignal:
000053C4  4E56 FFFC 16413          link      A6,#-4
                    16414   ; INT8U  err;
                    16415   ; err = OSSemPost(OSTmrSemSignal);
000053C8  2F39 0080 16416          move.l    _OSTmrSemSignal.L,-(A7)
000053CC  0CC6      
000053CE  4EB8 3F34 16417          jsr       _OSSemPost
000053D2  584F      16418          addq.w    #4,A7
000053D4  1D40 FFFF 16419          move.b    D0,-1(A6)
                    16420   ; return (err);
000053D8  102E FFFF 16421          move.b    -1(A6),D0
000053DC  4E5E      16422          unlk      A6
000053DE  4E75      16423          rts
                    16424   ; }
                    16425   ; #endif
                    16426   ; /*$PAGE*/
                    16427   ; /*
                    16428   ; *********************************************************************************************************
                    16429   ; *                                      ALLOCATE AND FREE A TIMER
                    16430   ; *
                    16431   ; * Description: This function is called to allocate a timer.
                    16432   ; *
                    16433   ; * Arguments  : none
                    16434   ; *
                    16435   ; * Returns    : a pointer to a timer if one is available
                    16436   ; *********************************************************************************************************
                    16437   ; */
                    16438   ; #if OS_TMR_EN > 0u
                    16439   ; static  OS_TMR  *OSTmr_Alloc (void)
                    16440   ; {
                    16441   @ucos_ii_OSTmr_Alloc:
000053E0  48E7 2020 16442          movem.l   D2/A2,-(A7)
000053E4  45F9 0080 16443          lea       _OSTmrFreeList.L,A2
000053E8  0F0A      
                    16444   ; OS_TMR *ptmr;
                    16445   ; if (OSTmrFreeList == (OS_TMR *)0) {
000053EA  2012      16446          move.l    (A2),D0
000053EC  6604      16447          bne.s     @ucos_ii_OSTmr_Alloc_1
                    16448   ; return ((OS_TMR *)0);
000053EE  4280      16449          clr.l     D0
000053F0  6022      16450          bra.s     @ucos_ii_OSTmr_Alloc_3
                    16451   @ucos_ii_OSTmr_Alloc_1:
                    16452   ; }
                    16453   ; ptmr            = (OS_TMR *)OSTmrFreeList;
000053F2  2412      16454          move.l    (A2),D2
                    16455   ; OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
000053F4  2042      16456          move.l    D2,A0
000053F6  24A8 000A 16457          move.l    10(A0),(A2)
                    16458   ; ptmr->OSTmrNext = (OS_TCB *)0;
000053FA  2042      16459          move.l    D2,A0
000053FC  42A8 000A 16460          clr.l     10(A0)
                    16461   ; ptmr->OSTmrPrev = (OS_TCB *)0;
00005400  2042      16462          move.l    D2,A0
00005402  42A8 000E 16463          clr.l     14(A0)
                    16464   ; OSTmrUsed++;
00005406  5279 0080 16465          addq.w    #1,_OSTmrUsed.L
0000540A  0CBC      
                    16466   ; OSTmrFree--;
0000540C  5379 0080 16467          subq.w    #1,_OSTmrFree.L
00005410  0CBA      
                    16468   ; return (ptmr);
00005412  2002      16469          move.l    D2,D0
                    16470   @ucos_ii_OSTmr_Alloc_3:
00005414  4CDF 0404 16471          movem.l   (A7)+,D2/A2
00005418  4E75      16472          rts
                    16473   ; }
                    16474   ; #endif
                    16475   ; /*
                    16476   ; *********************************************************************************************************
                    16477   ; *                                   RETURN A TIMER TO THE FREE LIST
                    16478   ; *
                    16479   ; * Description: This function is called to return a timer object to the free list of timers.
                    16480   ; *
                    16481   ; * Arguments  : ptmr     is a pointer to the timer to free
                    16482   ; *
                    16483   ; * Returns    : none
                    16484   ; *********************************************************************************************************
                    16485   ; */
                    16486   ; #if OS_TMR_EN > 0u
                    16487   ; static  void  OSTmr_Free (OS_TMR *ptmr)
                    16488   ; {
                    16489   @ucos_ii_OSTmr_Free:
0000541A  4E56 0000 16490          link      A6,#0
0000541E  2F02      16491          move.l    D2,-(A7)
00005420  242E 0008 16492          move.l    8(A6),D2
                    16493   ; ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
00005424  2042      16494          move.l    D2,A0
00005426  4228 0023 16495          clr.b     35(A0)
                    16496   ; ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
0000542A  2042      16497          move.l    D2,A0
0000542C  4228 0022 16498          clr.b     34(A0)
                    16499   ; ptmr->OSTmrPeriod      = 0u;
00005430  2042      16500          move.l    D2,A0
00005432  42A8 001A 16501          clr.l     26(A0)
                    16502   ; ptmr->OSTmrMatch       = 0u;
00005436  2042      16503          move.l    D2,A0
00005438  42A8 0012 16504          clr.l     18(A0)
                    16505   ; ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
0000543C  2042      16506          move.l    D2,A0
0000543E  42A8 0002 16507          clr.l     2(A0)
                    16508   ; ptmr->OSTmrCallbackArg = (void *)0;
00005442  2042      16509          move.l    D2,A0
00005444  42A8 0006 16510          clr.l     6(A0)
                    16511   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16512   ; ptmr->OSTmrName        = (INT8U *)(void *)"?";
00005448  41F9 0000 16513          lea       @ucos_ii_1.L,A0
0000544C  5A8E      
0000544E  2242      16514          move.l    D2,A1
00005450  2348 001E 16515          move.l    A0,30(A1)
                    16516   ; #endif
                    16517   ; ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
00005454  2042      16518          move.l    D2,A0
00005456  42A8 000E 16519          clr.l     14(A0)
                    16520   ; ptmr->OSTmrNext        = OSTmrFreeList;
0000545A  2042      16521          move.l    D2,A0
0000545C  2179 0080 16522          move.l    _OSTmrFreeList.L,10(A0)
00005460  0F0A 000A 
                    16523   ; OSTmrFreeList          = ptmr;
00005464  23C2 0080 16524          move.l    D2,_OSTmrFreeList.L
00005468  0F0A      
                    16525   ; OSTmrUsed--;                                       /* Update timer object statistics                              */
0000546A  5379 0080 16526          subq.w    #1,_OSTmrUsed.L
0000546E  0CBC      
                    16527   ; OSTmrFree++;
00005470  5279 0080 16528          addq.w    #1,_OSTmrFree.L
00005474  0CBA      
00005476  241F      16529          move.l    (A7)+,D2
00005478  4E5E      16530          unlk      A6
0000547A  4E75      16531          rts
                    16532   ; }
                    16533   ; #endif
                    16534   ; /*$PAGE*/
                    16535   ; /*
                    16536   ; *********************************************************************************************************
                    16537   ; *                                                    INITIALIZATION
                    16538   ; *                                          INITIALIZE THE FREE LIST OF TIMERS
                    16539   ; *
                    16540   ; * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
                    16541   ; *
                    16542   ; * Arguments  : none
                    16543   ; *
                    16544   ; * Returns    : none
                    16545   ; *********************************************************************************************************
                    16546   ; */
                    16547   ; #if OS_TMR_EN > 0u
                    16548   ; void  OSTmr_Init (void)
                    16549   ; {
                    16550   _OSTmr_Init:
0000547C  4E56 FFF8 16551          link      A6,#-8
00005480  48E7 3020 16552          movem.l   D2/D3/A2,-(A7)
00005484  45F9 0080 16553          lea       _OSTmrTbl.L,A2
00005488  0CCA      
                    16554   ; #if OS_EVENT_NAME_EN > 0u
                    16555   ; INT8U    err;
                    16556   ; #endif
                    16557   ; INT16U   ix;
                    16558   ; INT16U   ix_next;
                    16559   ; OS_TMR  *ptmr1;
                    16560   ; OS_TMR  *ptmr2;
                    16561   ; OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
0000548A  4878 0240 16562          pea       576
0000548E  2F0A      16563          move.l    A2,-(A7)
00005490  4EB8 13AC 16564          jsr       _OS_MemClr
00005494  504F      16565          addq.w    #8,A7
                    16566   ; OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
00005496  4878 0020 16567          pea       32
0000549A  4879 0080 16568          pea       _OSTmrWheelTbl.L
0000549E  100E      
000054A0  4EB8 13AC 16569          jsr       _OS_MemClr
000054A4  504F      16570          addq.w    #8,A7
                    16571   ; for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
000054A6  4243      16572          clr.w     D3
                    16573   OSTmr_Init_1:
000054A8  0C43 000F 16574          cmp.w     #15,D3
000054AC  6400 0056 16575          bhs       OSTmr_Init_3
                    16576   ; ix_next = ix + 1u;
000054B0  3003      16577          move.w    D3,D0
000054B2  5240      16578          addq.w    #1,D0
000054B4  3D40 FFFA 16579          move.w    D0,-6(A6)
                    16580   ; ptmr1 = &OSTmrTbl[ix];
000054B8  200A      16581          move.l    A2,D0
000054BA  C6BC 0000 16582          and.l     #65535,D3
000054BE  FFFF      
000054C0  2203      16583          move.l    D3,D1
000054C2  C3FC 0024 16584          muls      #36,D1
000054C6  D081      16585          add.l     D1,D0
000054C8  2400      16586          move.l    D0,D2
                    16587   ; ptmr2 = &OSTmrTbl[ix_next];
000054CA  200A      16588          move.l    A2,D0
000054CC  322E FFFA 16589          move.w    -6(A6),D1
000054D0  C2BC 0000 16590          and.l     #65535,D1
000054D4  FFFF      
000054D6  C3FC 0024 16591          muls      #36,D1
000054DA  D081      16592          add.l     D1,D0
000054DC  2D40 FFFC 16593          move.l    D0,-4(A6)
                    16594   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
000054E0  2042      16595          move.l    D2,A0
000054E2  10BC 0064 16596          move.b    #100,(A0)
                    16597   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
000054E6  2042      16598          move.l    D2,A0
000054E8  4228 0023 16599          clr.b     35(A0)
                    16600   ; ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
000054EC  2042      16601          move.l    D2,A0
000054EE  216E FFFC 16602          move.l    -4(A6),10(A0)
000054F2  000A      
                    16603   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16604   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
000054F4  41F9 0000 16605          lea       @ucos_ii_1.L,A0
000054F8  5A8E      
000054FA  2242      16606          move.l    D2,A1
000054FC  2348 001E 16607          move.l    A0,30(A1)
00005500  5243      16608          addq.w    #1,D3
00005502  60A4      16609          bra       OSTmr_Init_1
                    16610   OSTmr_Init_3:
                    16611   ; #endif
                    16612   ; }
                    16613   ; ptmr1               = &OSTmrTbl[ix];
00005504  200A      16614          move.l    A2,D0
00005506  C6BC 0000 16615          and.l     #65535,D3
0000550A  FFFF      
0000550C  2203      16616          move.l    D3,D1
0000550E  C3FC 0024 16617          muls      #36,D1
00005512  D081      16618          add.l     D1,D0
00005514  2400      16619          move.l    D0,D2
                    16620   ; ptmr1->OSTmrType    = OS_TMR_TYPE;
00005516  2042      16621          move.l    D2,A0
00005518  10BC 0064 16622          move.b    #100,(A0)
                    16623   ; ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
0000551C  2042      16624          move.l    D2,A0
0000551E  4228 0023 16625          clr.b     35(A0)
                    16626   ; ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
00005522  2042      16627          move.l    D2,A0
00005524  42A8 000A 16628          clr.l     10(A0)
                    16629   ; #if OS_TMR_CFG_NAME_EN > 0u
                    16630   ; ptmr1->OSTmrName    = (INT8U *)(void *)"?";
00005528  41F9 0000 16631          lea       @ucos_ii_1.L,A0
0000552C  5A8E      
0000552E  2242      16632          move.l    D2,A1
00005530  2348 001E 16633          move.l    A0,30(A1)
                    16634   ; #endif
                    16635   ; OSTmrTime           = 0u;
00005534  42B9 0080 16636          clr.l     _OSTmrTime.L
00005538  0CBE      
                    16637   ; OSTmrUsed           = 0u;
0000553A  4279 0080 16638          clr.w     _OSTmrUsed.L
0000553E  0CBC      
                    16639   ; OSTmrFree           = OS_TMR_CFG_MAX;
00005540  33FC 0010 16640          move.w    #16,_OSTmrFree.L
00005544  0080 0CBA 
                    16641   ; OSTmrFreeList       = &OSTmrTbl[0];
00005548  23CA 0080 16642          move.l    A2,_OSTmrFreeList.L
0000554C  0F0A      
                    16643   ; OSTmrSem            = OSSemCreate(1u);
0000554E  4878 0001 16644          pea       1
00005552  4EB8 3BEC 16645          jsr       _OSSemCreate
00005556  584F      16646          addq.w    #4,A7
00005558  23C0 0080 16647          move.l    D0,_OSTmrSem.L
0000555C  0CC2      
                    16648   ; OSTmrSemSignal      = OSSemCreate(0u);
0000555E  42A7      16649          clr.l     -(A7)
00005560  4EB8 3BEC 16650          jsr       _OSSemCreate
00005564  584F      16651          addq.w    #4,A7
00005566  23C0 0080 16652          move.l    D0,_OSTmrSemSignal.L
0000556A  0CC6      
                    16653   ; #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores                 */
                    16654   ; OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
0000556C  486E FFF9 16655          pea       -7(A6)
00005570  4879 0000 16656          pea       @ucos_ii_4.L
00005574  5AAC      
00005576  2F39 0080 16657          move.l    _OSTmrSem.L,-(A7)
0000557A  0CC2      
0000557C  4EB8 07BA 16658          jsr       _OSEventNameSet
00005580  DEFC 000C 16659          add.w     #12,A7
                    16660   ; OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
00005584  486E FFF9 16661          pea       -7(A6)
00005588  4879 0000 16662          pea       @ucos_ii_5.L
0000558C  5ABE      
0000558E  2F39 0080 16663          move.l    _OSTmrSemSignal.L,-(A7)
00005592  0CC6      
00005594  4EB8 07BA 16664          jsr       _OSEventNameSet
00005598  DEFC 000C 16665          add.w     #12,A7
                    16666   ; #endif
                    16667   ; OSTmr_InitTask();
0000559C  4EB9 0000 16668          jsr       @ucos_ii_OSTmr_InitTask
000055A0  55AA      
000055A2  4CDF 040C 16669          movem.l   (A7)+,D2/D3/A2
000055A6  4E5E      16670          unlk      A6
000055A8  4E75      16671          rts
                    16672   ; }
                    16673   ; #endif
                    16674   ; /*$PAGE*/
                    16675   ; /*
                    16676   ; *********************************************************************************************************
                    16677   ; *                                INITIALIZE THE TIMER MANAGEMENT TASK
                    16678   ; *
                    16679   ; * Description: This function is called by OSTmrInit() to create the timer management task.
                    16680   ; *                               * Arguments  : none
                    16681   ; *
                    16682   ; * Returns    : none
                    16683   ; *********************************************************************************************************
                    16684   ; */
                    16685   ; #if OS_TMR_EN > 0u
                    16686   ; static  void  OSTmr_InitTask (void)
                    16687   ; {
                    16688   @ucos_ii_OSTmr_InitTask:
000055AA  4E56 FFFC 16689          link      A6,#-4
                    16690   ; #if OS_TASK_NAME_EN > 0u
                    16691   ; INT8U  err;
                    16692   ; #endif
                    16693   ; #if OS_TASK_CREATE_EXT_EN > 0u
                    16694   ; #if OS_STK_GROWTH == 1u
                    16695   ; (void)OSTaskCreateExt(OSTmr_Task,
000055AE  4878 0003 16696          pea       3
000055B2  42A7      16697          clr.l     -(A7)
000055B4  4878 0080 16698          pea       128
000055B8  4879 0080 16699          pea       _OSTmrTaskStk.L
000055BC  0F0E      
000055BE  4878 FFFD 16700          pea       65533
000055C2  4878 0005 16701          pea       5
000055C6  41F9 0080 16702          lea       _OSTmrTaskStk.L,A0
000055CA  0F0E      
000055CC  D0FC 00FE 16703          add.w     #254,A0
000055D0  2F08      16704          move.l    A0,-(A7)
000055D2  42A7      16705          clr.l     -(A7)
000055D4  4879 0000 16706          pea       @ucos_ii_OSTmr_Task.L
000055D8  5774      
000055DA  4EB8 4362 16707          jsr       _OSTaskCreateExt
000055DE  DEFC 0024 16708          add.w     #36,A7
000055E2  C0BC 0000 16709          and.l     #255,D0
000055E6  00FF      
                    16710   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    16711   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
                    16712   ; OS_TASK_TMR_PRIO,
                    16713   ; OS_TASK_TMR_ID,
                    16714   ; &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
                    16715   ; OS_TASK_TMR_STK_SIZE,
                    16716   ; (void *)0,                                       /* No TCB extension                        */
                    16717   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    16718   ; #else
                    16719   ; (void)OSTaskCreateExt(OSTmr_Task,
                    16720   ; (void *)0,                                       /* No arguments passed to OSTmrTask()      */
                    16721   ; &OSTmrTaskStk[0],                                /* Set Top-Of-Stack                        */
                    16722   ; OS_TASK_TMR_PRIO,
                    16723   ; OS_TASK_TMR_ID,
                    16724   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack                     */
                    16725   ; OS_TASK_TMR_STK_SIZE,
                    16726   ; (void *)0,                                       /* No TCB extension                        */
                    16727   ; OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
                    16728   ; #endif
                    16729   ; #else
                    16730   ; #if OS_STK_GROWTH == 1u
                    16731   ; (void)OSTaskCreate(OSTmr_Task,
                    16732   ; (void *)0,
                    16733   ; &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
                    16734   ; OS_TASK_TMR_PRIO);
                    16735   ; #else
                    16736   ; (void)OSTaskCreate(OSTmr_Task,
                    16737   ; (void *)0,
                    16738   ; &OSTmrTaskStk[0],
                    16739   ; OS_TASK_TMR_PRIO);
                    16740   ; #endif
                    16741   ; #endif
                    16742   ; #if OS_TASK_NAME_EN > 0u
                    16743   ; OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
000055E8  486E FFFF 16744          pea       -1(A6)
000055EC  4879 0000 16745          pea       @ucos_ii_6.L
000055F0  5AD2      
000055F2  4878 0005 16746          pea       5
000055F6  4EB8 476E 16747          jsr       _OSTaskNameSet
000055FA  DEFC 000C 16748          add.w     #12,A7
000055FE  4E5E      16749          unlk      A6
00005600  4E75      16750          rts
                    16751   ; #endif
                    16752   ; }
                    16753   ; #endif
                    16754   ; /*$PAGE*/
                    16755   ; /*
                    16756   ; *********************************************************************************************************
                    16757   ; *                                 INSERT A TIMER INTO THE TIMER WHEEL
                    16758   ; *
                    16759   ; * Description: This function is called to insert the timer into the timer wheel.  The timer is always 
                    16760   ; *              inserted at the beginning of the list.
                    16761   ; *
                    16762   ; * Arguments  : ptmr          Is a pointer to the timer to insert.
                    16763   ; *
                    16764   ; *              type          Is either:
                    16765   ; *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expired
                    16766   ; *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
                    16767   ; *
                    16768   ; * Returns    : none
                    16769   ; *********************************************************************************************************
                    16770   ; */
                    16771   ; #if OS_TMR_EN > 0u
                    16772   ; static  void  OSTmr_Link (OS_TMR  *ptmr,
                    16773   ; INT8U    type)
                    16774   ; {
                    16775   @ucos_ii_OSTmr_Link:
00005602  4E56 FFFC 16776          link      A6,#-4
00005606  48E7 3820 16777          movem.l   D2/D3/D4/A2,-(A7)
0000560A  242E 0008 16778          move.l    8(A6),D2
0000560E  45F9 0080 16779          lea       _OSTmrTime.L,A2
00005612  0CBE      
                    16780   ; OS_TMR       *ptmr1;
                    16781   ; OS_TMR_WHEEL *pspoke;
                    16782   ; INT16U        spoke;
                    16783   ; ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
00005614  2042      16784          move.l    D2,A0
00005616  117C 0003 16785          move.b    #3,35(A0)
0000561A  0023      
                    16786   ; if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
0000561C  102E 000F 16787          move.b    15(A6),D0
00005620  0C00 0001 16788          cmp.b     #1,D0
00005624  6610      16789          bne.s     @ucos_ii_OSTmr_Link_1
                    16790   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
00005626  2042      16791          move.l    D2,A0
00005628  2028 001A 16792          move.l    26(A0),D0
0000562C  D092      16793          add.l     (A2),D0
0000562E  2042      16794          move.l    D2,A0
00005630  2140 0012 16795          move.l    D0,18(A0)
00005634  6026      16796          bra.s     @ucos_ii_OSTmr_Link_4
                    16797   @ucos_ii_OSTmr_Link_1:
                    16798   ; } else {
                    16799   ; if (ptmr->OSTmrDly == 0u) {
00005636  2042      16800          move.l    D2,A0
00005638  2028 0016 16801          move.l    22(A0),D0
0000563C  6610      16802          bne.s     @ucos_ii_OSTmr_Link_3
                    16803   ; ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
0000563E  2042      16804          move.l    D2,A0
00005640  2028 001A 16805          move.l    26(A0),D0
00005644  D092      16806          add.l     (A2),D0
00005646  2042      16807          move.l    D2,A0
00005648  2140 0012 16808          move.l    D0,18(A0)
0000564C  600E      16809          bra.s     @ucos_ii_OSTmr_Link_4
                    16810   @ucos_ii_OSTmr_Link_3:
                    16811   ; } else {
                    16812   ; ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
0000564E  2042      16813          move.l    D2,A0
00005650  2028 0016 16814          move.l    22(A0),D0
00005654  D092      16815          add.l     (A2),D0
00005656  2042      16816          move.l    D2,A0
00005658  2140 0012 16817          move.l    D0,18(A0)
                    16818   @ucos_ii_OSTmr_Link_4:
                    16819   ; }
                    16820   ; }
                    16821   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
0000565C  2002      16822          move.l    D2,D0
0000565E  0680 0000 16823          add.l     #18,D0
00005662  0012      
00005664  2040      16824          move.l    D0,A0
00005666  2F10      16825          move.l    (A0),-(A7)
00005668  4878 0008 16826          pea       8
0000566C  4EB9 0000 16827          jsr       ULDIV
00005670  59B0      
00005672  202F 0004 16828          move.l    4(A7),D0
00005676  504F      16829          addq.w    #8,A7
00005678  3D40 FFFE 16830          move.w    D0,-2(A6)
                    16831   ; pspoke = &OSTmrWheelTbl[spoke];
0000567C  41F9 0080 16832          lea       _OSTmrWheelTbl.L,A0
00005680  100E      
00005682  302E FFFE 16833          move.w    -2(A6),D0
00005686  C0BC 0000 16834          and.l     #65535,D0
0000568A  FFFF      
0000568C  E588      16835          lsl.l     #2,D0
0000568E  D1C0      16836          add.l     D0,A0
00005690  2608      16837          move.l    A0,D3
                    16838   ; if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
00005692  2043      16839          move.l    D3,A0
00005694  2010      16840          move.l    (A0),D0
00005696  6614      16841          bne.s     @ucos_ii_OSTmr_Link_5
                    16842   ; pspoke->OSTmrFirst   = ptmr;
00005698  2043      16843          move.l    D3,A0
0000569A  2082      16844          move.l    D2,(A0)
                    16845   ; ptmr->OSTmrNext      = (OS_TMR *)0;
0000569C  2042      16846          move.l    D2,A0
0000569E  42A8 000A 16847          clr.l     10(A0)
                    16848   ; pspoke->OSTmrEntries = 1u;
000056A2  2043      16849          move.l    D3,A0
000056A4  317C 0001 16850          move.w    #1,4(A0)
000056A8  0004      
000056AA  601C      16851          bra.s     @ucos_ii_OSTmr_Link_6
                    16852   @ucos_ii_OSTmr_Link_5:
                    16853   ; } else {
                    16854   ; ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
000056AC  2043      16855          move.l    D3,A0
000056AE  2810      16856          move.l    (A0),D4
                    16857   ; pspoke->OSTmrFirst   = ptmr;
000056B0  2043      16858          move.l    D3,A0
000056B2  2082      16859          move.l    D2,(A0)
                    16860   ; ptmr->OSTmrNext      = (void *)ptmr1;
000056B4  2042      16861          move.l    D2,A0
000056B6  2144 000A 16862          move.l    D4,10(A0)
                    16863   ; ptmr1->OSTmrPrev     = (void *)ptmr;
000056BA  2044      16864          move.l    D4,A0
000056BC  2142 000E 16865          move.l    D2,14(A0)
                    16866   ; pspoke->OSTmrEntries++;
000056C0  2003      16867          move.l    D3,D0
000056C2  5880      16868          addq.l    #4,D0
000056C4  2040      16869          move.l    D0,A0
000056C6  5250      16870          addq.w    #1,(A0)
                    16871   @ucos_ii_OSTmr_Link_6:
                    16872   ; }
                    16873   ; ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
000056C8  2042      16874          move.l    D2,A0
000056CA  42A8 000E 16875          clr.l     14(A0)
000056CE  4CDF 041C 16876          movem.l   (A7)+,D2/D3/D4/A2
000056D2  4E5E      16877          unlk      A6
000056D4  4E75      16878          rts
                    16879   ; }
                    16880   ; #endif
                    16881   ; /*$PAGE*/
                    16882   ; /*
                    16883   ; *********************************************************************************************************
                    16884   ; *                                 REMOVE A TIMER FROM THE TIMER WHEEL
                    16885   ; *
                    16886   ; * Description: This function is called to remove the timer from the timer wheel.
                    16887   ; *
                    16888   ; * Arguments  : ptmr          Is a pointer to the timer to remove.
                    16889   ; *
                    16890   ; * Returns    : none
                    16891   ; *********************************************************************************************************
                    16892   ; */
                    16893   ; #if OS_TMR_EN > 0u
                    16894   ; static  void  OSTmr_Unlink (OS_TMR *ptmr)
                    16895   ; {
                    16896   @ucos_ii_OSTmr_Unlink:
000056D6  4E56 FFFC 16897          link      A6,#-4
000056DA  48E7 3C00 16898          movem.l   D2/D3/D4/D5,-(A7)
000056DE  242E 0008 16899          move.l    8(A6),D2
                    16900   ; OS_TMR        *ptmr1;
                    16901   ; OS_TMR        *ptmr2;
                    16902   ; OS_TMR_WHEEL  *pspoke;
                    16903   ; INT16U         spoke;
                    16904   ; spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
000056E2  2002      16905          move.l    D2,D0
000056E4  0680 0000 16906          add.l     #18,D0
000056E8  0012      
000056EA  2040      16907          move.l    D0,A0
000056EC  2F10      16908          move.l    (A0),-(A7)
000056EE  4878 0008 16909          pea       8
000056F2  4EB9 0000 16910          jsr       ULDIV
000056F6  59B0      
000056F8  202F 0004 16911          move.l    4(A7),D0
000056FC  504F      16912          addq.w    #8,A7
000056FE  3D40 FFFE 16913          move.w    D0,-2(A6)
                    16914   ; pspoke = &OSTmrWheelTbl[spoke];
00005702  41F9 0080 16915          lea       _OSTmrWheelTbl.L,A0
00005706  100E      
00005708  302E FFFE 16916          move.w    -2(A6),D0
0000570C  C0BC 0000 16917          and.l     #65535,D0
00005710  FFFF      
00005712  E588      16918          lsl.l     #2,D0
00005714  D1C0      16919          add.l     D0,A0
00005716  2A08      16920          move.l    A0,D5
                    16921   ; if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
00005718  2045      16922          move.l    D5,A0
0000571A  B490      16923          cmp.l     (A0),D2
0000571C  6616      16924          bne.s     @ucos_ii_OSTmr_Unlink_1
                    16925   ; ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
0000571E  2042      16926          move.l    D2,A0
00005720  2628 000A 16927          move.l    10(A0),D3
                    16928   ; pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
00005724  2045      16929          move.l    D5,A0
00005726  2083      16930          move.l    D3,(A0)
                    16931   ; if (ptmr1 != (OS_TMR *)0) {
00005728  4A83      16932          tst.l     D3
0000572A  6706      16933          beq.s     @ucos_ii_OSTmr_Unlink_3
                    16934   ; ptmr1->OSTmrPrev = (void *)0;
0000572C  2043      16935          move.l    D3,A0
0000572E  42A8 000E 16936          clr.l     14(A0)
                    16937   @ucos_ii_OSTmr_Unlink_3:
00005732  601C      16938          bra.s     @ucos_ii_OSTmr_Unlink_5
                    16939   @ucos_ii_OSTmr_Unlink_1:
                    16940   ; }
                    16941   ; } else {
                    16942   ; ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
00005734  2042      16943          move.l    D2,A0
00005736  2628 000E 16944          move.l    14(A0),D3
                    16945   ; ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
0000573A  2042      16946          move.l    D2,A0
0000573C  2828 000A 16947          move.l    10(A0),D4
                    16948   ; ptmr1->OSTmrNext = ptmr2;
00005740  2043      16949          move.l    D3,A0
00005742  2144 000A 16950          move.l    D4,10(A0)
                    16951   ; if (ptmr2 != (OS_TMR *)0) {
00005746  4A84      16952          tst.l     D4
00005748  6706      16953          beq.s     @ucos_ii_OSTmr_Unlink_5
                    16954   ; ptmr2->OSTmrPrev = (void *)ptmr1;
0000574A  2044      16955          move.l    D4,A0
0000574C  2143 000E 16956          move.l    D3,14(A0)
                    16957   @ucos_ii_OSTmr_Unlink_5:
                    16958   ; }
                    16959   ; }
                    16960   ; ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
00005750  2042      16961          move.l    D2,A0
00005752  117C 0001 16962          move.b    #1,35(A0)
00005756  0023      
                    16963   ; ptmr->OSTmrNext  = (void *)0;
00005758  2042      16964          move.l    D2,A0
0000575A  42A8 000A 16965          clr.l     10(A0)
                    16966   ; ptmr->OSTmrPrev  = (void *)0;
0000575E  2042      16967          move.l    D2,A0
00005760  42A8 000E 16968          clr.l     14(A0)
                    16969   ; pspoke->OSTmrEntries--;
00005764  2005      16970          move.l    D5,D0
00005766  5880      16971          addq.l    #4,D0
00005768  2040      16972          move.l    D0,A0
0000576A  5350      16973          subq.w    #1,(A0)
0000576C  4CDF 003C 16974          movem.l   (A7)+,D2/D3/D4/D5
00005770  4E5E      16975          unlk      A6
00005772  4E75      16976          rts
                    16977   ; }
                    16978   ; #endif
                    16979   ; /*$PAGE*/
                    16980   ; /*
                    16981   ; *********************************************************************************************************
                    16982   ; *                                        TIMER MANAGEMENT TASK
                    16983   ; *
                    16984   ; * Description: This task is created by OSTmrInit().
                    16985   ; *
                    16986   ; * Arguments  : none
                    16987   ; *
                    16988   ; * Returns    : none
                    16989   ; *********************************************************************************************************
                    16990   ; */
                    16991   ; #if OS_TMR_EN > 0u
                    16992   ; static  void  OSTmr_Task (void *p_arg)
                    16993   ; {
                    16994   @ucos_ii_OSTmr_Task:
00005774  4E56 FFF4 16995          link      A6,#-12
00005778  48E7 3020 16996          movem.l   D2/D3/A2,-(A7)
0000577C  45F9 0080 16997          lea       _OSTmrTime.L,A2
00005780  0CBE      
                    16998   ; INT8U            err;
                    16999   ; OS_TMR          *ptmr;
                    17000   ; OS_TMR          *ptmr_next;
                    17001   ; OS_TMR_CALLBACK  pfnct;
                    17002   ; OS_TMR_WHEEL    *pspoke;
                    17003   ; INT16U           spoke;
                    17004   ; p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
                    17005   ; for (;;) {
                    17006   @ucos_ii_OSTmr_Task_1:
                    17007   ; OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
00005782  486E FFF5 17008          pea       -11(A6)
00005786  42A7      17009          clr.l     -(A7)
00005788  2F39 0080 17010          move.l    _OSTmrSemSignal.L,-(A7)
0000578C  0CC6      
0000578E  4EB8 3D72 17011          jsr       _OSSemPend
00005792  DEFC 000C 17012          add.w     #12,A7
                    17013   ; OSSchedLock();
00005796  4EB8 0C48 17014          jsr       _OSSchedLock
                    17015   ; OSTmrTime++;                                             /* Increment the current time                        */
0000579A  5292      17016          addq.l    #1,(A2)
                    17017   ; spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
0000579C  2F12      17018          move.l    (A2),-(A7)
0000579E  4878 0008 17019          pea       8
000057A2  4EB9 0000 17020          jsr       ULDIV
000057A6  59B0      
000057A8  202F 0004 17021          move.l    4(A7),D0
000057AC  504F      17022          addq.w    #8,A7
000057AE  3D40 FFFE 17023          move.w    D0,-2(A6)
                    17024   ; pspoke = &OSTmrWheelTbl[spoke];
000057B2  41F9 0080 17025          lea       _OSTmrWheelTbl.L,A0
000057B6  100E      
000057B8  302E FFFE 17026          move.w    -2(A6),D0
000057BC  C0BC 0000 17027          and.l     #65535,D0
000057C0  FFFF      
000057C2  E588      17028          lsl.l     #2,D0
000057C4  D1C0      17029          add.l     D0,A0
000057C6  2D48 FFFA 17030          move.l    A0,-6(A6)
                    17031   ; ptmr   = pspoke->OSTmrFirst;
000057CA  206E FFFA 17032          move.l    -6(A6),A0
000057CE  2410      17033          move.l    (A0),D2
                    17034   ; while (ptmr != (OS_TMR *)0) {
                    17035   @ucos_ii_OSTmr_Task_4:
000057D0  4A82      17036          tst.l     D2
000057D2  6700 005E 17037          beq       @ucos_ii_OSTmr_Task_6
                    17038   ; ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
000057D6  2042      17039          move.l    D2,A0
000057D8  2D68 000A 17040          move.l    10(A0),-10(A6)
000057DC  FFF6      
                    17041   ; /* ... timer could get unlinked from the wheel.      */
                    17042   ; if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
000057DE  2042      17043          move.l    D2,A0
000057E0  2012      17044          move.l    (A2),D0
000057E2  B0A8 0012 17045          cmp.l     18(A0),D0
000057E6  6600 0044 17046          bne       @ucos_ii_OSTmr_Task_11
                    17047   ; OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
000057EA  2F02      17048          move.l    D2,-(A7)
000057EC  4EB8 56D6 17049          jsr       @ucos_ii_OSTmr_Unlink
000057F0  584F      17050          addq.w    #4,A7
                    17051   ; if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
000057F2  2042      17052          move.l    D2,A0
000057F4  1028 0022 17053          move.b    34(A0),D0
000057F8  0C00 0002 17054          cmp.b     #2,D0
000057FC  660E      17055          bne.s     @ucos_ii_OSTmr_Task_9
                    17056   ; OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
000057FE  4878 0001 17057          pea       1
00005802  2F02      17058          move.l    D2,-(A7)
00005804  4EB8 5602 17059          jsr       @ucos_ii_OSTmr_Link
00005808  504F      17060          addq.w    #8,A7
0000580A  6008      17061          bra.s     @ucos_ii_OSTmr_Task_10
                    17062   @ucos_ii_OSTmr_Task_9:
                    17063   ; } else {
                    17064   ; ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
0000580C  2042      17065          move.l    D2,A0
0000580E  117C 0002 17066          move.b    #2,35(A0)
00005812  0023      
                    17067   @ucos_ii_OSTmr_Task_10:
                    17068   ; }
                    17069   ; pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
00005814  2042      17070          move.l    D2,A0
00005816  2628 0002 17071          move.l    2(A0),D3
                    17072   ; if (pfnct != (OS_TMR_CALLBACK)0) {
0000581A  4A83      17073          tst.l     D3
0000581C  670E      17074          beq.s     @ucos_ii_OSTmr_Task_11
                    17075   ; (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
0000581E  2042      17076          move.l    D2,A0
00005820  2F28 0006 17077          move.l    6(A0),-(A7)
00005824  2F02      17078          move.l    D2,-(A7)
00005826  2043      17079          move.l    D3,A0
00005828  4E90      17080          jsr       (A0)
0000582A  504F      17081          addq.w    #8,A7
                    17082   @ucos_ii_OSTmr_Task_11:
                    17083   ; }
                    17084   ; }
                    17085   ; ptmr = ptmr_next;
0000582C  242E FFF6 17086          move.l    -10(A6),D2
00005830  609E      17087          bra       @ucos_ii_OSTmr_Task_4
                    17088   @ucos_ii_OSTmr_Task_6:
                    17089   ; }
                    17090   ; OSSchedUnlock();
00005832  4EB8 0C78 17091          jsr       _OSSchedUnlock
00005836  6000 FF4A 17092          bra       @ucos_ii_OSTmr_Task_1
                    17093   ; /*
                    17094   ; *********************************************************************************************************
                    17095   ; *                                                uC/OS-II
                    17096   ; *                                          The Real-Time Kernel
                    17097   ; *
                    17098   ; *                              (c) Copyright 1992-2009, Micrium, Weston, FL
                    17099   ; *                                           All Rights Reserved
                    17100   ; *
                    17101   ; * File    : uCOS_II.C
                    17102   ; * By      : Jean J. Labrosse
                    17103   ; * Version : V2.91
                    17104   ; *
                    17105   ; * LICENSING TERMS:
                    17106   ; * ---------------
                    17107   ; *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
                    17108   ; * If you plan on using  uC/OS-II  in a commercial product you need to contact Micrim to properly license 
                    17109   ; * its use in your product. We provide ALL the source code for your convenience and to help you experience 
                    17110   ; * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
                    17111   ; * licensing fee.
                    17112   ; *********************************************************************************************************
                    17113   ; */
                    17114   ; #define  OS_GLOBALS                           /* Declare GLOBAL variables                              */
                    17115   ; #include <ucos_ii.h>
                    17116   ; #define  OS_MASTER_FILE                       /* Prevent the following files from including includes.h */
                    17117   ; #include <os_core.c>
                    17118   ; #include <os_flag.c>
                    17119   ; #include <os_mbox.c>
                    17120   ; #include <os_mem.c>
                    17121   ; #include <os_mutex.c>
                    17122   ; #include <os_q.c>
                    17123   ; #include <os_sem.c>
                    17124   ; #include <os_task.c>
                    17125   ; #include <os_time.c>
                    17126   ; #include <os_tmr.c>
                    17127   ; C:\IDE68K\EM-LAB\EX10_1.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    17128   ; /* HELLO.C  -  The mother of all C programs */
                    17129   ; /* This program can be compiled by loading hello.prj in the
                    17130   ; * "Project|Open project" menu. It displays the well-known string
                    17131   ; * "Hello, world!".
                    17132   ; *
                    17133   ; * Author: Kernighan & Ritchie
                    17134   ; */
                    17135   ; #include <ucos_ii.h>
                    17136   ; #define STACKSIZE 256
                    17137   ; /* Mailbox between switches and LED display */
                    17138   ; OS_EVENT *Mailbox;
                    17139   ; /* Stacks */
                    17140   ; OS_STK SwitchReadStack[STACKSIZE];
                    17141   ; OS_STK LedsWriteStack[STACKSIZE];
                    17142   ; /* Pointers to I/O devices */
                    17143   ; INT8U *const Switch = (INT8U *)0xE001;
                    17144   ; INT8U *const LEDS = (INT8U *)0xE003;
                    17145   ; /* Prototypes */
                    17146   ; void SimInit(void);
                    17147   ; void SwitchRead(void *);
                    17148   ; void LedsWrite(void *);
                    17149   ; void main(void)
                    17150   ; {
                    17151   _main:
                    17152   ; SimInit();
0000583A  4EB9 0000 17153          jsr       _SimInit
0000583E  5898      
                    17154   ; OSInit();
00005840  4EB8 0B5C 17155          jsr       _OSInit
                    17156   ; Mailbox = OSMboxCreate(OS_NULL);
00005844  42A7      17157          clr.l     -(A7)
00005846  4EB8 22BC 17158          jsr       _OSMboxCreate
0000584A  584F      17159          addq.w    #4,A7
0000584C  23C0 0080 17160          move.l    D0,_Mailbox.L
00005850  102E      
                    17161   ; OSTaskCreate(SwitchRead, OS_NULL, &SwitchReadStack[STACKSIZE], 10);
00005852  4878 000A 17162          pea       10
00005856  41F9 0080 17163          lea       _SwitchReadStack.L,A0
0000585A  1032      
0000585C  D0FC 0200 17164          add.w     #512,A0
00005860  2F08      17165          move.l    A0,-(A7)
00005862  42A7      17166          clr.l     -(A7)
00005864  4879 0000 17167          pea       _SwitchRead.L
00005868  58A2      
0000586A  4EB8 4294 17168          jsr       _OSTaskCreate
0000586E  DEFC 0010 17169          add.w     #16,A7
                    17170   ; OSTaskCreate(LedsWrite, OS_NULL, &LedsWriteStack[STACKSIZE], 11);
00005872  4878 000B 17171          pea       11
00005876  41F9 0080 17172          lea       _LedsWriteStack.L,A0
0000587A  1232      
0000587C  D0FC 0200 17173          add.w     #512,A0
00005880  2F08      17174          move.l    A0,-(A7)
00005882  42A7      17175          clr.l     -(A7)
00005884  4879 0000 17176          pea       _LedsWrite.L
00005888  58E6      
0000588A  4EB8 4294 17177          jsr       _OSTaskCreate
0000588E  DEFC 0010 17178          add.w     #16,A7
                    17179   ; OSStart();
00005892  4EB8 0CC4 17180          jsr       _OSStart
00005896  4E75      17181          rts
                    17182   ; }
                    17183   ; void SimInit()
                    17184   ; {
                    17185   _SimInit:
                    17186   ; _trap(15);        /* Show Switches window */
00005898  4E4F      17187          trap      #15
                    17188   ; _word(31);
0000589A  001F      17189          dc.w      31
                    17190   ; _trap(15);        /* Show LEDs window */
0000589C  4E4F      17191          trap      #15
                    17192   ; _word(32);
0000589E  0020      17193          dc.w      32
000058A0  4E75      17194          rts
                    17195   ; }
                    17196   ; void SwitchRead(void *pdata)
                    17197   ; {
                    17198   _SwitchRead:
000058A2  4E56 FFFC 17199          link      A6,#-4
                    17200   ; INT8U SwitchState = 0;
000058A6  422E FFFF 17201          clr.b     -1(A6)
                    17202   ; for (;;) {
                    17203   SwitchRead_1:
                    17204   ; if (SwitchState != *Switch) {
000058AA  2079 0000 17205          move.l    _Switch.L,A0
000058AE  5BE0      
000058B0  102E FFFF 17206          move.b    -1(A6),D0
000058B4  B010      17207          cmp.b     (A0),D0
000058B6  671A      17208          beq.s     SwitchRead_4
                    17209   ; SwitchState = *Switch;
000058B8  2079 0000 17210          move.l    _Switch.L,A0
000058BC  5BE0      
000058BE  1D50 FFFF 17211          move.b    (A0),-1(A6)
                    17212   ; OSMboxPost(Mailbox, &SwitchState);
000058C2  486E FFFF 17213          pea       -1(A6)
000058C6  2F39 0080 17214          move.l    _Mailbox.L,-(A7)
000058CA  102E      
000058CC  4EB8 261C 17215          jsr       _OSMboxPost
000058D0  504F      17216          addq.w    #8,A7
                    17217   SwitchRead_4:
                    17218   ; }
                    17219   ; OSTimeDlyHMSM(0, 0, 1, 0);
000058D2  42A7      17220          clr.l     -(A7)
000058D4  4878 0001 17221          pea       1
000058D8  42A7      17222          clr.l     -(A7)
000058DA  42A7      17223          clr.l     -(A7)
000058DC  4EB8 4C8A 17224          jsr       _OSTimeDlyHMSM
000058E0  DEFC 0010 17225          add.w     #16,A7
000058E4  60C4      17226          bra       SwitchRead_1
                    17227   ; }
                    17228   ; }
                    17229   ; void LedsWrite(void *pdata)
                    17230   ; {
                    17231   _LedsWrite:
000058E6  4E56 FFF8 17232          link      A6,#-8
                    17233   ; INT8U *msg;
                    17234   ; INT8U err;
                    17235   ; for (;;) {
                    17236   LedsWrite_1:
                    17237   ; msg = (INT8U *) OSMboxPend(Mailbox, 0, &err);
000058EA  486E FFFF 17238          pea       -1(A6)
000058EE  42A7      17239          clr.l     -(A7)
000058F0  2F39 0080 17240          move.l    _Mailbox.L,-(A7)
000058F4  102E      
000058F6  4EB8 2442 17241          jsr       _OSMboxPend
000058FA  DEFC 000C 17242          add.w     #12,A7
000058FE  2D40 FFFA 17243          move.l    D0,-6(A6)
                    17244   ; *LEDS = *msg;
00005902  206E FFFA 17245          move.l    -6(A6),A0
00005906  2279 0000 17246          move.l    _LEDS.L,A1
0000590A  5BE4      
0000590C  1290      17247          move.b    (A0),(A1)
0000590E  60DA      17248          bra       LedsWrite_1
                    17249   ; }
                    17250   ; }
                    17251   ULMUL:
00005910  4E56 0000 17252          link    A6,#0
00005914  48E7 C000 17253          movem.l D0/D1,-(A7)
00005918  222E 0008 17254          move.l  8(A6),D1
0000591C  202E 000C 17255          move.l  12(A6),D0
00005920  602C      17256          bra.s   lmul_3
                    17257   LMUL:
00005922  4E56 0000 17258          link    A6,#0
00005926  48E7 C000 17259          movem.l D0/D1,-(A7)
0000592A  222E 0008 17260          move.l  8(A6),D1
0000592E  202E 000C 17261          move.l  12(A6),D0
00005932  4A80      17262          tst.l   D0
00005934  6A0A      17263          bpl.s   lmul_1
00005936  4480      17264          neg.l   D0
00005938  4A81      17265          tst.l   D1
0000593A  6A0A      17266          bpl.s   lmul_2
0000593C  4481      17267          neg.l   D1
0000593E  600E      17268          bra.s   lmul_3
                    17269   lmul_1:
00005940  4A81      17270          tst.l   D1
00005942  6A0A      17271          bpl.s   lmul_3
00005944  4481      17272          neg.l   D1
                    17273   lmul_2:
00005946  6114      17274          bsr.s   domul
00005948  4481      17275          neg.l   D1
0000594A  4080      17276          negx.l  D0
0000594C  6002      17277          bra.s   lmul_4
                    17278   lmul_3:
0000594E  610C      17279          bsr.s   domul
                    17280   lmul_4:
00005950  2D41 0008 17281          move.l  D1,8(A6)
00005954  4CDF 0003 17282          movem.l (A7)+,D0/D1
00005958  4E5E      17283          unlk    A6
0000595A  4E75      17284          rts
                    17285   domul:
0000595C  0C81 0000 17286          cmpi.l  #$FFFF,D1
00005960  FFFF      
00005962  620C      17287          bhi.s   domul_1
00005964  0C80 0000 17288          cmpi.l  #$FFFF,D0
00005968  FFFF      
0000596A  620E      17289          bhi.s   domul_2
0000596C  C2C0      17290          mulu    D0,D1
0000596E  4E75      17291          rts
                    17292   domul_1:
00005970  0C80 0000 17293          cmpi.l  #$FFFF,D0
00005974  FFFF      
00005976  6218      17294          bhi.s   domul_4
00005978  6002      17295          bra.s   domul_3
                    17296   domul_2
0000597A  C141      17297          exg     D0,D1
                    17298   domul_3:
0000597C  2F02      17299          move.l  D2,-(A7)
0000597E  2401      17300          move.l  D1,D2
00005980  4842      17301          swap    D2
00005982  C2C0      17302          mulu    D0,D1
00005984  C4C0      17303          mulu    D0,D2
00005986  4842      17304          swap    D2
00005988  4242      17305          clr.w   D2
0000598A  D282      17306          add.l   D2,D1
0000598C  241F      17307          move.l  (A7)+,D2
0000598E  4E75      17308          rts
                    17309   domul_4:
00005990  48E7 3000 17310          movem.l D2/D3,-(A7)
00005994  2401      17311          move.l  D1,D2
00005996  2601      17312          move.l  D1,D3
00005998  C2C0      17313          mulu    D0,D1
0000599A  4842      17314          swap    D2
0000599C  C4C0      17315          mulu    D0,D2
0000599E  4840      17316          swap    D0
000059A0  C6C0      17317          mulu    D0,D3
000059A2  D483      17318          add.l   D3,D2
000059A4  4842      17319          swap    D2
000059A6  4242      17320          clr.w   D2
000059A8  D282      17321          add.l   D2,D1
000059AA  4CDF 000C 17322          movem.l (A7)+,D2/D3
000059AE  4E75      17323          rts
                    17324   ULDIV:
000059B0  4E56 0000 17325          link    A6,#0
000059B4  48E7 C000 17326          movem.l D0/D1,-(A7)
000059B8  222E 0008 17327          move.l  8(A6),D1
000059BC  202E 000C 17328          move.l  12(A6),D0
000059C0  6036      17329          bra.s   ldiv_3
                    17330   LDIV:
000059C2  4E56 0000 17331          link    A6,#0
000059C6  48E7 C000 17332          movem.l D0/D1,-(A7)
000059CA  222E 0008 17333          move.l  8(A6),D1
000059CE  202E 000C 17334          move.l  12(A6),D0
000059D2  4A80      17335          tst.l   D0
000059D4  6A0E      17336          bpl.s   ldiv_1
000059D6  4480      17337          neg.l   D0
000059D8  4A81      17338          tst.l   D1
000059DA  6A14      17339          bpl.s   ldiv_2
000059DC  4481      17340          neg.l   D1
000059DE  612A      17341          bsr.s   dodiv
000059E0  4481      17342          neg.l   D1
000059E2  6016      17343          bra.s   ldiv_4
                    17344   ldiv_1:
000059E4  4A81      17345          tst.l   D1
000059E6  6A10      17346          bpl.s   ldiv_3
000059E8  4481      17347          neg.l   D1
000059EA  611E      17348          bsr.s   dodiv
000059EC  4480      17349          neg.l   D0
000059EE  600A      17350          bra.s   ldiv_4
                    17351   ldiv_2:
000059F0  6118      17352          bsr.s   dodiv
000059F2  4480      17353          neg.l   D0
000059F4  4481      17354          neg.l   D1
000059F6  6002      17355          bra.s   ldiv_4
                    17356   ldiv_3:
000059F8  6110      17357          bsr.s   dodiv
                    17358   ldiv_4:
000059FA  2D40 0008 17359          move.l  D0,8(A6)
000059FE  2D41 000C 17360          move.l  D1,12(A6)
00005A02  4CDF 0003 17361          movem.l (A7)+,D0/D1
00005A06  4E5E      17362          unlk    A6
00005A08  4E75      17363          rts
                    17364   dodiv:
00005A0A  0C81 0000 17365          cmpi.l  #$FFFF,D1
00005A0E  FFFF      
00005A10  6236      17366          bhi.s   dodiv_2
00005A12  0C80 0000 17367          cmpi.l  #$FFFF,D0
00005A16  FFFF      
00005A18  6210      17368          bhi.s   dodiv_1
00005A1A  80C1      17369          divu    D1,D0
00005A1C  2200      17370          move.l  D0,D1
00005A1E  4241      17371          clr.w   D1
00005A20  4841      17372          swap    D1
00005A22  0280 0000 17373          andi.l  #$FFFF,D0
00005A26  FFFF      
00005A28  4E75      17374          rts
                    17375   dodiv_1:
00005A2A  48A7 A000 17376          movem.w D0/D2,-(A7)
00005A2E  4240      17377          clr.w   D0
00005A30  4840      17378          swap    D0
00005A32  80C1      17379          divu    D1,D0
00005A34  3400      17380          move.w  D0,D2
00005A36  301F      17381          move.w  (A7)+,D0
00005A38  80C1      17382          divu    D1,D0
00005A3A  4840      17383          swap    D0
00005A3C  4281      17384          clr.l   D1
00005A3E  3200      17385          move.w  D0,D1
00005A40  3002      17386          move.w  D2,D0
00005A42  4840      17387          swap    D0
00005A44  341F      17388          move.w  (A7)+,D2
00005A46  4E75      17389          rts
                    17390   dodiv_2:
00005A48  48E7 3800 17391          movem.l D2/D3/D4,-(A7)
00005A4C  2401      17392          move.l  D1,D2
00005A4E  4242      17393          clr.w   D2
00005A50  4842      17394          swap    D2
00005A52  5282      17395          addq.l  #1,D2
00005A54  2600      17396          move.l  D0,D3
00005A56  2801      17397          move.l  D1,D4
00005A58  2202      17398          move.l  D2,D1
00005A5A  61CE      17399          bsr.s   dodiv_1
00005A5C  2204      17400          move.l  D4,D1
00005A5E  82C2      17401          divu    D2,D1
00005A60  80C1      17402          divu    D1,D0
00005A62  0280 0000 17403          andi.l  #$FFFF,D0
00005A66  FFFF      
                    17404   dodiv_3:
00005A68  2204      17405          move.l  D4,D1
00005A6A  2404      17406          move.l  D4,D2
00005A6C  4842      17407          swap    D2
00005A6E  C2C0      17408          mulu    D0,D1
00005A70  C4C0      17409          mulu    D0,D2
00005A72  4842      17410          swap    D2
00005A74  D282      17411          add.l   D2,D1
00005A76  9283      17412          sub.l   D3,D1
00005A78  620A      17413          bhi.s   dodiv_4
00005A7A  4481      17414          neg.l   D1
00005A7C  B881      17415          cmp.l   D1,D4
00005A7E  6208      17416          bhi.s   dodiv_5
00005A80  5280      17417          addq.l  #1,D0
00005A82  60E4      17418          bra.s   dodiv_3
                    17419   dodiv_4:
00005A84  5380      17420          subq.l  #1,D0
00005A86  60E0      17421          bra.s   dodiv_3
                    17422   dodiv_5:
00005A88  4CDF 001C 17423          movem.l (A7)+,D2/D3/D4
00005A8C  4E75      17424          rts
                    17425          section   const
          0000 5A8E 17426   const      equ         *
                    17427   
                    17428   @ucos_ii_1:
00005A8E  3F00      17429          dc.b      63,0
                    17430   @ucos_ii_2:
00005A90  7543 2F4F 17431          dc.b      117,67,47,79,83,45,73,73,32,73,100,108,101,0
00005A94  532D 4949 
00005A98  2049 646C 
00005A9C  6500      
                    17432   @ucos_ii_3:
00005A9E  7543 2F4F 17433          dc.b      117,67,47,79,83,45,73,73,32,83,116,97,116,0
00005AA2  532D 4949 
00005AA6  2053 7461 
00005AAA  7400      
                    17434   @ucos_ii_4:
00005AAC  7543 2F4F 17435          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,76,111
00005AB0  532D 4949 
00005AB4  2054 6D72 
00005AB8  4C6F      
00005ABA  636B 00   17436          dc.b      99,107,0
                    17437   @ucos_ii_5:
00005ABE  7543 2F4F 17438          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,83,105
00005AC2  532D 4949 
00005AC6  2054 6D72 
00005ACA  5369      
00005ACC  676E 616C 17439          dc.b      103,110,97,108,0
00005AD0  00        
                    17440   @ucos_ii_6:
00005AD2  7543 2F4F 17441          dc.b      117,67,47,79,83,45,73,73,32,84,109,114,0
00005AD6  532D 4949 
00005ADA  2054 6D72 
00005ADE  00        
                    17442   _OSUnMapTbl:
00005AE0  0000 0100 17443          dc.b      0,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0
00005AE4  0200 0100 
00005AE8  0300 0100 
00005AEC  0200 0100 
00005AF0  0400 0100 
00005AF4  0200      
00005AF6  0100 0300 17444          dc.b      1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0
00005AFA  0100 0200 
00005AFE  0100 0500 
00005B02  0100 0200 
00005B06  0100 0300 
00005B0A  0100      
00005B0C  0200 0100 17445          dc.b      2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0
00005B10  0400 0100 
00005B14  0200 0100 
00005B18  0300 0100 
00005B1C  0200 0100 
00005B20  0600      
00005B22  0100 0200 17446          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0
00005B26  0100 0300 
00005B2A  0100 0200 
00005B2E  0100 0400 
00005B32  0100 0200 
00005B36  0100      
00005B38  0300 0100 17447          dc.b      3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0
00005B3C  0200 0100 
00005B40  0500 0100 
00005B44  0200 0100 
00005B48  0300 0100 
00005B4C  0200      
00005B4E  0100 0400 17448          dc.b      1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0
00005B52  0100 0200 
00005B56  0100 0300 
00005B5A  0100 0200 
00005B5E  0100 0700 
00005B62  0100      
00005B64  0200 0100 17449          dc.b      2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0
00005B68  0300 0100 
00005B6C  0200 0100 
00005B70  0400 0100 
00005B74  0200 0100 
00005B78  0300      
00005B7A  0100 0200 17450          dc.b      1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0
00005B7E  0100 0500 
00005B82  0100 0200 
00005B86  0100 0300 
00005B8A  0100 0200 
00005B8E  0100      
00005B90  0400 0100 17451          dc.b      4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0
00005B94  0200 0100 
00005B98  0300 0100 
00005B9C  0200 0100 
00005BA0  0600 0100 
00005BA4  0200      
00005BA6  0100 0300 17452          dc.b      1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0
00005BAA  0100 0200 
00005BAE  0100 0400 
00005BB2  0100 0200 
00005BB6  0100 0300 
00005BBA  0100      
00005BBC  0200 0100 17453          dc.b      2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0
00005BC0  0500 0100 
00005BC4  0200 0100 
00005BC8  0300 0100 
00005BCC  0200 0100 
00005BD0  0400      
00005BD2  0100 0200 17454          dc.b      1,0,2,0,1,0,3,0,1,0,2,0,1,0
00005BD6  0100 0300 
00005BDA  0100 0200 
00005BDE  0100      
                    17455   _Switch:
00005BE0  0000 E001 17456          dc.l      57345
                    17457   _LEDS:
00005BE4  0000 E003 17458          dc.l      57347
                    17459          section   data
          0000 5BE8 17460   end_ROM    equ         *
00800000            17461              org         RAM
          0080 0000 17462   begin_RAM  equ         *
          0080 0000 17463   data       equ         *
                    17464   
                    17465          section   bss
          0080 0000 17466   bss        equ         *
                    17467   
                    17468   __ungetbuf:                            ; ungetbuffer for stdio functions
00800000            17469              ds.l        1
                    17470   __timezone:                            ; difference, in seconds, between local time and UTC
00800004            17471              ds.l        1
                    17472   __daylight:                            ; flag, '1' for daylight saving time, '0' for standard time.
00800008            17473              ds.l        1
                    17474   __romsize:                             ; size of ROM used by program
0080000C            17475              ds.l        1
                    17476   __ramsize:                             ; size of RAM used by program
00800010            17477              ds.l        1
                    17478   
                    17479   _OSTmrTickCtr:
00800014            17480          ds.b      1
                    17481   _OSCtxSwCtr:
00800016            17482          ds.b      4
                    17483   _OSEventFreeList:
0080001A            17484          ds.b      4
                    17485   _OSEventTbl:
0080001E            17486          ds.b      220
                    17487   _OSFlagTbl:
008000FA            17488          ds.b      60
                    17489   _OSFlagFreeList:
00800136            17490          ds.b      4
                    17491   _OSCPUUsage:
0080013A            17492          ds.b      1
                    17493   _OSIdleCtrMax:
0080013C            17494          ds.b      4
                    17495   _OSIdleCtrRun:
00800140            17496          ds.b      4
                    17497   _OSStatRdy:
00800144            17498          ds.b      1
                    17499   _OSTaskStatStk:
00800146            17500          ds.b      256
                    17501   _OSIntNesting:
00800246            17502          ds.b      1
                    17503   _OSLockNesting:
00800248            17504          ds.b      1
                    17505   _OSPrioCur:
0080024A            17506          ds.b      1
                    17507   _OSPrioHighRdy:
0080024C            17508          ds.b      1
                    17509   _OSRdyGrp:
0080024E            17510          ds.b      1
                    17511   _OSRdyTbl:
00800250            17512          ds.b      8
                    17513   _OSRunning:
00800258            17514          ds.b      1
                    17515   _OSTaskCtr:
0080025A            17516          ds.b      1
                    17517   _OSIdleCtr:
0080025C            17518          ds.b      4
                    17519   _OSTaskIdleStk:
00800260            17520          ds.b      256
                    17521   _OSTCBCur:
00800360            17522          ds.b      4
                    17523   _OSTCBFreeList:
00800364            17524          ds.b      4
                    17525   _OSTCBHighRdy:
00800368            17526          ds.b      4
                    17527   _OSTCBList:
0080036C            17528          ds.b      4
                    17529   _OSTCBPrioTbl:
00800370            17530          ds.b      256
                    17531   _OSTCBTbl:
00800470            17532          ds.b      1892
                    17533   _OSMemFreeList:
00800BD4            17534          ds.b      4
                    17535   _OSMemTbl:
00800BD8            17536          ds.b      120
                    17537   _OSQFreeList:
00800C50            17538          ds.b      4
                    17539   _OSQTbl:
00800C54            17540          ds.b      96
                    17541   _OSTaskRegNextAvailID:
00800CB4            17542          ds.b      1
                    17543   _OSTime:
00800CB6            17544          ds.b      4
                    17545   _OSTmrFree:
00800CBA            17546          ds.b      2
                    17547   _OSTmrUsed:
00800CBC            17548          ds.b      2
                    17549   _OSTmrTime:
00800CBE            17550          ds.b      4
                    17551   _OSTmrSem:
00800CC2            17552          ds.b      4
                    17553   _OSTmrSemSignal:
00800CC6            17554          ds.b      4
                    17555   _OSTmrTbl:
00800CCA            17556          ds.b      576
                    17557   _OSTmrFreeList:
00800F0A            17558          ds.b      4
                    17559   _OSTmrTaskStk:
00800F0E            17560          ds.b      256
                    17561   _OSTmrWheelTbl:
0080100E            17562          ds.b      32
                    17563   _Mailbox:
0080102E            17564          ds.b      4
                    17565   _SwitchReadStack:
00801032            17566          ds.b      512
                    17567   _LedsWriteStack:
00801232            17568          ds.b      512
                    17569          section   heap
          0080 1432 17570   end_RAM    equ         *
          0080 1432 17571   heap       equ         *
                    17572   
          0084 0000 17573   __stack    equ         RAM+RAMsize     ; stack for main function, no longer needed after OSStart() is called
          0000 0000

Assembly errors: 0
